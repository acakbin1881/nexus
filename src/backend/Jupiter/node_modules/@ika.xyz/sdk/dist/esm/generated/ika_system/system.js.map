{
  "version": 3,
  "sources": ["../../../../src/generated/ika_system/system.ts"],
  "sourcesContent": ["/**************************************************************\n * THIS FILE IS GENERATED AND SHOULD NOT BE MANUALLY MODIFIED *\n **************************************************************/\n\n\n/**\n * # Ika System Module\n * \n * The `ika_system::system` module provides the core system state management for\n * the Ika network. It acts as the central coordinator for validators, staking,\n * epochs, and network governance.\n * \n * ## Overview\n * \n * The module implements a versioned wrapper pattern around the core system state:\n * \n * - `System`: A shared object that serves as the public interface and version\n *   manager\n * - `SystemInner`: The actual system state implementation containing all business\n *   logic\n * - `ProtocolCap`: Capability object for privileged system operations\n * \n * ## Architecture\n * \n * The system uses a two-layer architecture:\n * \n * ### System Wrapper Layer\n * \n * The `System` struct is a thin wrapper that:\n * \n * - Maintains version information for upgrades\n * - Stores the package ID for authorization\n * - Holds the inner system state as a dynamic field\n * - Provides a stable public interface across versions\n * \n * ### SystemInner Layer\n * \n * The `SystemInner` struct contains all the core functionality:\n * \n * - Validator set management and operations\n * - Epoch progression and timing\n * - Staking and delegation logic\n * - Protocol treasury and rewards distribution\n * - dWallet network coordination\n * - System parameter management\n * \n * ## Key Responsibilities\n * \n * ### Validator Management\n * \n * - Adding/removing validator candidates\n * - Managing validator metadata and configuration\n * - Handling validator state transitions (PreActive \u2192 Active \u2192 Withdrawing)\n * - Processing validator reports and governance actions\n * \n * ### Staking Operations\n * \n * - Processing stake additions and withdrawals\n * - Managing staked IKA tokens and rewards\n * - Calculating token exchange rates across epochs\n * - Handling delegation to validators\n * \n * ### Epoch Management\n * \n * - Coordinating epoch transitions\n * - Processing mid-epoch reconfigurations\n * - Managing epoch timing and duration\n * - Distributing stake subsidies and rewards\n * \n * ### dWallet Integration\n * \n * - Coordinating with dWallet 2PC MPC system\n * - Managing encryption keys and DKG processes\n * - Handling pricing and curve configurations\n * - Processing dWallet network operations\n * \n * ### System Governance\n * \n * - Managing protocol upgrades via UpgradeCap\n * - Processing system parameter changes\n * - Handling protocol version transitions\n * - Coordinating checkpoint message processing\n * \n * ## State Management\n * \n * The system maintains state across multiple components:\n * \n * - **ValidatorSet**: Current and pending validator configurations\n * - **ProtocolTreasury**: Rewards, subsidies, and fee management\n * - **BLS Committee**: Cryptographic committee for consensus\n * - **Token Exchange Rates**: Historical staking reward calculations\n * - **Pending Values**: Future epoch configuration changes\n * \n * ## Ika System Upgrade Guide\n * \n * `System` is a versioned wrapper around `SystemInner` that provides upgrade\n * capabilities. The `SystemInner` object is stored as a dynamic field with the\n * version as the key. There are multiple approaches to upgrade the system state:\n * \n * The simplest approach is to add dynamic fields to the `extra_fields` field of\n * `SystemInner` or any of its subtypes. This is useful for rapid changes, small\n * modifications, or experimental features.\n * \n * To perform a proper type upgrade of `SystemInner`, follow these steps:\n * \n * 1.  Define a new `SystemInnerV2` type in system_inner.move.\n * 2.  Create a data migration function that transforms `SystemInner` to\n *     `SystemInnerV2`.\n * 3.  Update the `VERSION` constant to 2 and replace all references to\n *     `SystemInner` with `SystemInnerV2` in both system.move and\n *     system_inner.move.\n * 4.  Modify the `migrate` function to handle the version upgrade by:\n *     - Removing the old inner object from the dynamic field\n *     - Applying the data migration transformation\n *     - Adding the new inner object with the updated version\n * 5.  Update the `inner()` and `inner_mut()` functions to work with the new\n *     version.\n * \n * Along with the Move changes, update the Rust code:\n * \n * 1.  Define a new `SystemInnerV2` struct that matches the Move type.\n * 2.  Update the `System` enum to include the new version variant.\n * 3.  Update relevant system state getter functions to handle the new version.\n * \n * To upgrade Validator types:\n * \n * 1.  Define a new Validator version (e.g. ValidatorV2) in validator.move.\n * 2.  Create migration functions to convert between validator versions.\n * 3.  Update validator creation and access functions to use the new version.\n * 4.  Update the validator set and related components to handle the new validator\n *     type.\n * \n * In Rust, add new cases to handle the upgraded validator types in the appropriate\n * getter functions. Validator upgrades can be done independently of SystemInner\n * upgrades, but ensure version consistency across related components.\n */\n\nimport { MoveStruct, normalizeMoveArguments, type RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport { type Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/system::system';\nexport const System = new MoveStruct({ name: `${$moduleName}::System`, fields: {\n        id: object.UID,\n        version: bcs.u64(),\n        package_id: bcs.Address,\n        new_package_id: bcs.option(bcs.Address),\n        migration_epoch: bcs.option(bcs.u64())\n    } });\nexport interface InitializeArguments {\n    self: RawTransactionArgument<string>;\n    maxValidatorChangeCount: RawTransactionArgument<number | bigint>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface InitializeOptions {\n    package?: string;\n    arguments: InitializeArguments | [\n        self: RawTransactionArgument<string>,\n        maxValidatorChangeCount: RawTransactionArgument<number | bigint>,\n        cap: RawTransactionArgument<string>\n    ];\n}\nexport function initialize(options: InitializeOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        'u64',\n        `${packageAddress}::protocol_cap::ProtocolCap`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"maxValidatorChangeCount\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'initialize',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface RequestAddValidatorCandidateArguments {\n    self: RawTransactionArgument<string>;\n    name: RawTransactionArgument<string>;\n    protocolPubkeyBytes: RawTransactionArgument<number[]>;\n    networkPubkeyBytes: RawTransactionArgument<number[]>;\n    consensusPubkeyBytes: RawTransactionArgument<number[]>;\n    mpcDataBytes: RawTransactionArgument<string>;\n    proofOfPossessionBytes: RawTransactionArgument<number[]>;\n    networkAddress: RawTransactionArgument<string>;\n    p2pAddress: RawTransactionArgument<string>;\n    consensusAddress: RawTransactionArgument<string>;\n    commissionRate: RawTransactionArgument<number>;\n    metadata: RawTransactionArgument<string>;\n}\nexport interface RequestAddValidatorCandidateOptions {\n    package?: string;\n    arguments: RequestAddValidatorCandidateArguments | [\n        self: RawTransactionArgument<string>,\n        name: RawTransactionArgument<string>,\n        protocolPubkeyBytes: RawTransactionArgument<number[]>,\n        networkPubkeyBytes: RawTransactionArgument<number[]>,\n        consensusPubkeyBytes: RawTransactionArgument<number[]>,\n        mpcDataBytes: RawTransactionArgument<string>,\n        proofOfPossessionBytes: RawTransactionArgument<number[]>,\n        networkAddress: RawTransactionArgument<string>,\n        p2pAddress: RawTransactionArgument<string>,\n        consensusAddress: RawTransactionArgument<string>,\n        commissionRate: RawTransactionArgument<number>,\n        metadata: RawTransactionArgument<string>\n    ];\n}\n/**\n * Can be called by anyone who wishes to become a validator candidate and starts\n * accruing delegated stakes in their staking pool. Once they have at least\n * `MIN_VALIDATOR_JOINING_STAKE` amount of stake they can call\n * `request_add_validator` to officially become an active validator at the next\n * epoch. Aborts if the caller is already a pending or active validator, or a\n * validator candidate. Note: `proof_of_possession_bytes` MUST be a valid signature\n * using sui_address and protocol_pubkey_bytes. To produce a valid PoP, run [fn\n * test_proof_of_possession_bytes].\n */\nexport function requestAddValidatorCandidate(options: RequestAddValidatorCandidateOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n        'vector<u8>',\n        'vector<u8>',\n        'vector<u8>',\n        '0x0000000000000000000000000000000000000000000000000000000000000002::table_vec::TableVec<vector<u8>>',\n        'vector<u8>',\n        '0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n        '0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n        '0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n        'u16',\n        `${packageAddress}::validator_metadata::ValidatorMetadata`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"name\", \"protocolPubkeyBytes\", \"networkPubkeyBytes\", \"consensusPubkeyBytes\", \"mpcDataBytes\", \"proofOfPossessionBytes\", \"networkAddress\", \"p2pAddress\", \"consensusAddress\", \"commissionRate\", \"metadata\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'request_add_validator_candidate',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface RequestRemoveValidatorCandidateArguments {\n    self: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface RequestRemoveValidatorCandidateOptions {\n    package?: string;\n    arguments: RequestRemoveValidatorCandidateArguments | [\n        self: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * Called by a validator candidate to remove themselves from the candidacy. After\n * this call their staking pool becomes deactivate.\n */\nexport function requestRemoveValidatorCandidate(options: RequestRemoveValidatorCandidateOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::validator_cap::ValidatorCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'request_remove_validator_candidate',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface RequestAddValidatorArguments {\n    self: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface RequestAddValidatorOptions {\n    package?: string;\n    arguments: RequestAddValidatorArguments | [\n        self: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * Called by a validator candidate to add themselves to the active validator set\n * beginning next epoch. Aborts if the validator is a duplicate with one of the\n * pending or active validators, or if the amount of stake the validator has\n * doesn't meet the min threshold, or if the number of new validators for the next\n * epoch has already reached the maximum.\n */\nexport function requestAddValidator(options: RequestAddValidatorOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::validator_cap::ValidatorCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'request_add_validator',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface RequestRemoveValidatorArguments {\n    self: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface RequestRemoveValidatorOptions {\n    package?: string;\n    arguments: RequestRemoveValidatorArguments | [\n        self: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * A validator can call this function to request a removal in the next epoch. We\n * use the sender of `ctx` to look up the validator (i.e. sender must match the\n * sui_address in the validator). At the end of the epoch, the `validator` object\n * will be returned to the sui_address of the validator.\n */\nexport function requestRemoveValidator(options: RequestRemoveValidatorOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::validator_cap::ValidatorCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'request_remove_validator',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface SetNextCommissionArguments {\n    self: RawTransactionArgument<string>;\n    newCommissionRate: RawTransactionArgument<number>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface SetNextCommissionOptions {\n    package?: string;\n    arguments: SetNextCommissionArguments | [\n        self: RawTransactionArgument<string>,\n        newCommissionRate: RawTransactionArgument<number>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * A validator can call this function to set a new commission rate, updated at the\n * end of the epoch.\n */\nexport function setNextCommission(options: SetNextCommissionOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        'u16',\n        `${packageAddress}::validator_cap::ValidatorOperationCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"newCommissionRate\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'set_next_commission',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface RequestAddStakeArguments {\n    self: RawTransactionArgument<string>;\n    stake: RawTransactionArgument<string>;\n    validatorId: RawTransactionArgument<string>;\n}\nexport interface RequestAddStakeOptions {\n    package?: string;\n    arguments: RequestAddStakeArguments | [\n        self: RawTransactionArgument<string>,\n        stake: RawTransactionArgument<string>,\n        validatorId: RawTransactionArgument<string>\n    ];\n}\n/** Add stake to a validator's staking pool. */\nexport function requestAddStake(options: RequestAddStakeOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::ika::IKA>`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::object::ID'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"stake\", \"validatorId\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'request_add_stake',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface RequestWithdrawStakeArguments {\n    self: RawTransactionArgument<string>;\n    stakedIka: RawTransactionArgument<string>;\n}\nexport interface RequestWithdrawStakeOptions {\n    package?: string;\n    arguments: RequestWithdrawStakeArguments | [\n        self: RawTransactionArgument<string>,\n        stakedIka: RawTransactionArgument<string>\n    ];\n}\n/**\n * Marks the amount as a withdrawal to be processed and removes it from the stake\n * weight of the node. Allows the user to call withdraw_stake after the epoch\n * change to the next epoch and shard transfer is done.\n */\nexport function requestWithdrawStake(options: RequestWithdrawStakeOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::staked_ika::StakedIka`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"stakedIka\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'request_withdraw_stake',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface WithdrawStakeArguments {\n    self: RawTransactionArgument<string>;\n    stakedIka: RawTransactionArgument<string>;\n}\nexport interface WithdrawStakeOptions {\n    package?: string;\n    arguments: WithdrawStakeArguments | [\n        self: RawTransactionArgument<string>,\n        stakedIka: RawTransactionArgument<string>\n    ];\n}\n/** Withdraws the staked amount from the staking pool. */\nexport function withdrawStake(options: WithdrawStakeOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::staked_ika::StakedIka`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"stakedIka\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'withdraw_stake',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface ReportValidatorArguments {\n    self: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n    reporteeId: RawTransactionArgument<string>;\n}\nexport interface ReportValidatorOptions {\n    package?: string;\n    arguments: ReportValidatorArguments | [\n        self: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>,\n        reporteeId: RawTransactionArgument<string>\n    ];\n}\n/**\n * Report a validator as a bad or non-performant actor in the system. Succeeds if\n * all the following are satisfied:\n *\n * 1.  both the reporter in `cap` and the input `reportee_id` are active\n *     validators.\n * 2.  reporter and reportee not the same address.\n * 3.  the cap object is still valid. This function is idempotent.\n */\nexport function reportValidator(options: ReportValidatorOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::validator_cap::ValidatorOperationCap`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::object::ID'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"cap\", \"reporteeId\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'report_validator',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface UndoReportValidatorArguments {\n    self: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n    reporteeId: RawTransactionArgument<string>;\n}\nexport interface UndoReportValidatorOptions {\n    package?: string;\n    arguments: UndoReportValidatorArguments | [\n        self: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>,\n        reporteeId: RawTransactionArgument<string>\n    ];\n}\n/**\n * Undo a `report_validator` action. Aborts if\n *\n * 1.  the reportee is not a currently active validator or\n * 2.  the sender has not previously reported the `reportee_id`, or\n * 3.  the cap is not valid\n */\nexport function undoReportValidator(options: UndoReportValidatorOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::validator_cap::ValidatorOperationCap`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::object::ID'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"cap\", \"reporteeId\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'undo_report_validator',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface RotateOperationCapArguments {\n    self: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface RotateOperationCapOptions {\n    package?: string;\n    arguments: RotateOperationCapArguments | [\n        self: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * Create a new `ValidatorOperationCap` and registers it. The original object is\n * thus revoked.\n */\nexport function rotateOperationCap(options: RotateOperationCapOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::validator_cap::ValidatorCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'rotate_operation_cap',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface RotateCommissionCapArguments {\n    self: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface RotateCommissionCapOptions {\n    package?: string;\n    arguments: RotateCommissionCapArguments | [\n        self: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * Create a new `ValidatorCommissionCap` and registers it. The original object is\n * thus revoked.\n */\nexport function rotateCommissionCap(options: RotateCommissionCapOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::validator_cap::ValidatorCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'rotate_commission_cap',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface CollectCommissionArguments {\n    self: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n    amount: RawTransactionArgument<number | bigint | null>;\n}\nexport interface CollectCommissionOptions {\n    package?: string;\n    arguments: CollectCommissionArguments | [\n        self: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>,\n        amount: RawTransactionArgument<number | bigint | null>\n    ];\n}\n/**\n * Withdraws the commission from the validator. Amount is optional, if not\n * provided, the full commission is withdrawn.\n */\nexport function collectCommission(options: CollectCommissionOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::validator_cap::ValidatorCommissionCap`,\n        '0x0000000000000000000000000000000000000000000000000000000000000001::option::Option<u64>'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"cap\", \"amount\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'collect_commission',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface SetValidatorNameArguments {\n    self: RawTransactionArgument<string>;\n    name: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface SetValidatorNameOptions {\n    package?: string;\n    arguments: SetValidatorNameArguments | [\n        self: RawTransactionArgument<string>,\n        name: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/** Set a validator's name. */\nexport function setValidatorName(options: SetValidatorNameOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n        `${packageAddress}::validator_cap::ValidatorOperationCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"name\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'set_validator_name',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface ValidatorMetadataArguments {\n    self: RawTransactionArgument<string>;\n    validatorId: RawTransactionArgument<string>;\n}\nexport interface ValidatorMetadataOptions {\n    package?: string;\n    arguments: ValidatorMetadataArguments | [\n        self: RawTransactionArgument<string>,\n        validatorId: RawTransactionArgument<string>\n    ];\n}\n/** Get a validator's metadata. */\nexport function validatorMetadata(options: ValidatorMetadataOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::object::ID'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"validatorId\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'validator_metadata',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface SetValidatorMetadataArguments {\n    self: RawTransactionArgument<string>;\n    metadata: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface SetValidatorMetadataOptions {\n    package?: string;\n    arguments: SetValidatorMetadataArguments | [\n        self: RawTransactionArgument<string>,\n        metadata: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\nexport function setValidatorMetadata(options: SetValidatorMetadataOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::validator_metadata::ValidatorMetadata`,\n        `${packageAddress}::validator_cap::ValidatorOperationCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"metadata\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'set_validator_metadata',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface SetNextEpochNetworkAddressArguments {\n    self: RawTransactionArgument<string>;\n    networkAddress: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface SetNextEpochNetworkAddressOptions {\n    package?: string;\n    arguments: SetNextEpochNetworkAddressArguments | [\n        self: RawTransactionArgument<string>,\n        networkAddress: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * Sets a validator's network address. The change will only take effects starting\n * from the next epoch.\n */\nexport function setNextEpochNetworkAddress(options: SetNextEpochNetworkAddressOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n        `${packageAddress}::validator_cap::ValidatorOperationCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"networkAddress\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'set_next_epoch_network_address',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface SetNextEpochP2pAddressArguments {\n    self: RawTransactionArgument<string>;\n    p2pAddress: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface SetNextEpochP2pAddressOptions {\n    package?: string;\n    arguments: SetNextEpochP2pAddressArguments | [\n        self: RawTransactionArgument<string>,\n        p2pAddress: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * Sets a validator's p2p address. The change will only take effects starting from\n * the next epoch.\n */\nexport function setNextEpochP2pAddress(options: SetNextEpochP2pAddressOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n        `${packageAddress}::validator_cap::ValidatorOperationCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"p2pAddress\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'set_next_epoch_p2p_address',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface SetNextEpochConsensusAddressArguments {\n    self: RawTransactionArgument<string>;\n    consensusAddress: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface SetNextEpochConsensusAddressOptions {\n    package?: string;\n    arguments: SetNextEpochConsensusAddressArguments | [\n        self: RawTransactionArgument<string>,\n        consensusAddress: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * Sets a validator's consensus address. The change will only take effects starting\n * from the next epoch.\n */\nexport function setNextEpochConsensusAddress(options: SetNextEpochConsensusAddressOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n        `${packageAddress}::validator_cap::ValidatorOperationCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"consensusAddress\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'set_next_epoch_consensus_address',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface SetNextEpochProtocolPubkeyBytesArguments {\n    self: RawTransactionArgument<string>;\n    protocolPubkey: RawTransactionArgument<number[]>;\n    proofOfPossessionBytes: RawTransactionArgument<number[]>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface SetNextEpochProtocolPubkeyBytesOptions {\n    package?: string;\n    arguments: SetNextEpochProtocolPubkeyBytesArguments | [\n        self: RawTransactionArgument<string>,\n        protocolPubkey: RawTransactionArgument<number[]>,\n        proofOfPossessionBytes: RawTransactionArgument<number[]>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * Sets a validator's public key of protocol key and proof of possession. The\n * change will only take effects starting from the next epoch.\n */\nexport function setNextEpochProtocolPubkeyBytes(options: SetNextEpochProtocolPubkeyBytesOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        'vector<u8>',\n        'vector<u8>',\n        `${packageAddress}::validator_cap::ValidatorOperationCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"protocolPubkey\", \"proofOfPossessionBytes\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'set_next_epoch_protocol_pubkey_bytes',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface SetNextEpochNetworkPubkeyBytesArguments {\n    self: RawTransactionArgument<string>;\n    networkPubkey: RawTransactionArgument<number[]>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface SetNextEpochNetworkPubkeyBytesOptions {\n    package?: string;\n    arguments: SetNextEpochNetworkPubkeyBytesArguments | [\n        self: RawTransactionArgument<string>,\n        networkPubkey: RawTransactionArgument<number[]>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * Sets a validator's public key of network key. The change will only take effects\n * starting from the next epoch.\n */\nexport function setNextEpochNetworkPubkeyBytes(options: SetNextEpochNetworkPubkeyBytesOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        'vector<u8>',\n        `${packageAddress}::validator_cap::ValidatorOperationCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"networkPubkey\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'set_next_epoch_network_pubkey_bytes',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface SetNextEpochConsensusPubkeyBytesArguments {\n    self: RawTransactionArgument<string>;\n    consensusPubkeyBytes: RawTransactionArgument<number[]>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface SetNextEpochConsensusPubkeyBytesOptions {\n    package?: string;\n    arguments: SetNextEpochConsensusPubkeyBytesArguments | [\n        self: RawTransactionArgument<string>,\n        consensusPubkeyBytes: RawTransactionArgument<number[]>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * Sets a validator's public key of worker key. The change will only take effects\n * starting from the next epoch.\n */\nexport function setNextEpochConsensusPubkeyBytes(options: SetNextEpochConsensusPubkeyBytesOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        'vector<u8>',\n        `${packageAddress}::validator_cap::ValidatorOperationCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"consensusPubkeyBytes\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'set_next_epoch_consensus_pubkey_bytes',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface SetNextEpochMpcDataBytesArguments {\n    self: RawTransactionArgument<string>;\n    mpcData: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface SetNextEpochMpcDataBytesOptions {\n    package?: string;\n    arguments: SetNextEpochMpcDataBytesArguments | [\n        self: RawTransactionArgument<string>,\n        mpcData: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * Sets a validator's MPC public data. The change will only take effects starting\n * from the next epoch.\n */\nexport function setNextEpochMpcDataBytes(options: SetNextEpochMpcDataBytesOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::table_vec::TableVec<vector<u8>>',\n        `${packageAddress}::validator_cap::ValidatorOperationCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"mpcData\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'set_next_epoch_mpc_data_bytes',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface TokenExchangeRatesArguments {\n    self: RawTransactionArgument<string>;\n    validatorId: RawTransactionArgument<string>;\n}\nexport interface TokenExchangeRatesOptions {\n    package?: string;\n    arguments: TokenExchangeRatesArguments | [\n        self: RawTransactionArgument<string>,\n        validatorId: RawTransactionArgument<string>\n    ];\n}\n/**\n * Get the pool token exchange rate of a validator. Works for both active and\n * inactive pools.\n */\nexport function tokenExchangeRates(options: TokenExchangeRatesOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::object::ID'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"validatorId\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'token_exchange_rates',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface ActiveCommitteeArguments {\n    self: RawTransactionArgument<string>;\n}\nexport interface ActiveCommitteeOptions {\n    package?: string;\n    arguments: ActiveCommitteeArguments | [\n        self: RawTransactionArgument<string>\n    ];\n}\n/** Get the active committee of the current epoch. */\nexport function activeCommittee(options: ActiveCommitteeOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`\n    ] satisfies string[];\n    const parameterNames = [\"self\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'active_committee',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface NextEpochActiveCommitteeArguments {\n    self: RawTransactionArgument<string>;\n}\nexport interface NextEpochActiveCommitteeOptions {\n    package?: string;\n    arguments: NextEpochActiveCommitteeArguments | [\n        self: RawTransactionArgument<string>\n    ];\n}\n/** Get the active committee of the next epoch. */\nexport function nextEpochActiveCommittee(options: NextEpochActiveCommitteeOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`\n    ] satisfies string[];\n    const parameterNames = [\"self\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'next_epoch_active_committee',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface InitiateMidEpochReconfigurationArguments {\n    self: RawTransactionArgument<string>;\n}\nexport interface InitiateMidEpochReconfigurationOptions {\n    package?: string;\n    arguments: InitiateMidEpochReconfigurationArguments | [\n        self: RawTransactionArgument<string>\n    ];\n}\n/**\n * Locks the committee of the next epoch to allow starting the reconfiguration\n * process.\n */\nexport function initiateMidEpochReconfiguration(options: InitiateMidEpochReconfigurationOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock'\n    ] satisfies string[];\n    const parameterNames = [\"self\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'initiate_mid_epoch_reconfiguration',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface CreateSystemCurrentStatusInfoArguments {\n    self: RawTransactionArgument<string>;\n}\nexport interface CreateSystemCurrentStatusInfoOptions {\n    package?: string;\n    arguments: CreateSystemCurrentStatusInfoArguments | [\n        self: RawTransactionArgument<string>\n    ];\n}\n/** Create the system current status info. */\nexport function createSystemCurrentStatusInfo(options: CreateSystemCurrentStatusInfoOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock'\n    ] satisfies string[];\n    const parameterNames = [\"self\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'create_system_current_status_info',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface InitiateAdvanceEpochArguments {\n    self: RawTransactionArgument<string>;\n}\nexport interface InitiateAdvanceEpochOptions {\n    package?: string;\n    arguments: InitiateAdvanceEpochArguments | [\n        self: RawTransactionArgument<string>\n    ];\n}\n/** Initiates the advance epoch process. */\nexport function initiateAdvanceEpoch(options: InitiateAdvanceEpochOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock'\n    ] satisfies string[];\n    const parameterNames = [\"self\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'initiate_advance_epoch',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface AdvanceEpochArguments {\n    self: RawTransactionArgument<string>;\n    advanceEpochApprover: RawTransactionArgument<string>;\n}\nexport interface AdvanceEpochOptions {\n    package?: string;\n    arguments: AdvanceEpochArguments | [\n        self: RawTransactionArgument<string>,\n        advanceEpochApprover: RawTransactionArgument<string>\n    ];\n}\n/**\n * Advances the epoch to the next epoch. Can only be called after all the witnesses\n * have approved the advance epoch.\n */\nexport function advanceEpoch(options: AdvanceEpochOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::advance_epoch_approver::AdvanceEpochApprover`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"advanceEpochApprover\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'advance_epoch',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface VerifyValidatorCapArguments {\n    self: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface VerifyValidatorCapOptions {\n    package?: string;\n    arguments: VerifyValidatorCapArguments | [\n        self: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\nexport function verifyValidatorCap(options: VerifyValidatorCapOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::validator_cap::ValidatorCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'verify_validator_cap',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface VerifyOperationCapArguments {\n    self: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface VerifyOperationCapOptions {\n    package?: string;\n    arguments: VerifyOperationCapArguments | [\n        self: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\nexport function verifyOperationCap(options: VerifyOperationCapOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::validator_cap::ValidatorOperationCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'verify_operation_cap',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface VerifyCommissionCapArguments {\n    self: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface VerifyCommissionCapOptions {\n    package?: string;\n    arguments: VerifyCommissionCapArguments | [\n        self: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\nexport function verifyCommissionCap(options: VerifyCommissionCapOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::validator_cap::ValidatorCommissionCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'verify_commission_cap',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface AuthorizeUpgradeArguments {\n    self: RawTransactionArgument<string>;\n    packageId: RawTransactionArgument<string>;\n}\nexport interface AuthorizeUpgradeOptions {\n    package?: string;\n    arguments: AuthorizeUpgradeArguments | [\n        self: RawTransactionArgument<string>,\n        packageId: RawTransactionArgument<string>\n    ];\n}\nexport function authorizeUpgrade(options: AuthorizeUpgradeOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::object::ID'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"packageId\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'authorize_upgrade',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface CommitUpgradeArguments {\n    self: RawTransactionArgument<string>;\n    receipt: RawTransactionArgument<string>;\n    upgradePackageApprover: RawTransactionArgument<string>;\n}\nexport interface CommitUpgradeOptions {\n    package?: string;\n    arguments: CommitUpgradeArguments | [\n        self: RawTransactionArgument<string>,\n        receipt: RawTransactionArgument<string>,\n        upgradePackageApprover: RawTransactionArgument<string>\n    ];\n}\nexport function commitUpgrade(options: CommitUpgradeOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::package::UpgradeReceipt',\n        `${packageAddress}::upgrade_package_approver::UpgradePackageApprover`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"receipt\", \"upgradePackageApprover\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'commit_upgrade',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface FinalizeUpgradeArguments {\n    self: RawTransactionArgument<string>;\n    upgradePackageApprover: RawTransactionArgument<string>;\n}\nexport interface FinalizeUpgradeOptions {\n    package?: string;\n    arguments: FinalizeUpgradeArguments | [\n        self: RawTransactionArgument<string>,\n        upgradePackageApprover: RawTransactionArgument<string>\n    ];\n}\nexport function finalizeUpgrade(options: FinalizeUpgradeOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::upgrade_package_approver::UpgradePackageApprover`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"upgradePackageApprover\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'finalize_upgrade',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface ProcessCheckpointMessageByQuorumArguments {\n    self: RawTransactionArgument<string>;\n    signature: RawTransactionArgument<number[]>;\n    signersBitmap: RawTransactionArgument<number[]>;\n    message: RawTransactionArgument<number[]>;\n}\nexport interface ProcessCheckpointMessageByQuorumOptions {\n    package?: string;\n    arguments: ProcessCheckpointMessageByQuorumArguments | [\n        self: RawTransactionArgument<string>,\n        signature: RawTransactionArgument<number[]>,\n        signersBitmap: RawTransactionArgument<number[]>,\n        message: RawTransactionArgument<number[]>\n    ];\n}\nexport function processCheckpointMessageByQuorum(options: ProcessCheckpointMessageByQuorumOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        'vector<u8>',\n        'vector<u8>',\n        'vector<u8>'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"signature\", \"signersBitmap\", \"message\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'process_checkpoint_message_by_quorum',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface AddUpgradeCapByCapArguments {\n    self: RawTransactionArgument<string>;\n    upgradeCap: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface AddUpgradeCapByCapOptions {\n    package?: string;\n    arguments: AddUpgradeCapByCapArguments | [\n        self: RawTransactionArgument<string>,\n        upgradeCap: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\nexport function addUpgradeCapByCap(options: AddUpgradeCapByCapOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::package::UpgradeCap',\n        `${packageAddress}::protocol_cap::ProtocolCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"upgradeCap\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'add_upgrade_cap_by_cap',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface VerifyProtocolCapArguments {\n    self: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface VerifyProtocolCapOptions {\n    package?: string;\n    arguments: VerifyProtocolCapArguments | [\n        self: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\nexport function verifyProtocolCap(options: VerifyProtocolCapOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::protocol_cap::ProtocolCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'verify_protocol_cap',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface ProcessCheckpointMessageByCapArguments {\n    self: RawTransactionArgument<string>;\n    message: RawTransactionArgument<number[]>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface ProcessCheckpointMessageByCapOptions {\n    package?: string;\n    arguments: ProcessCheckpointMessageByCapArguments | [\n        self: RawTransactionArgument<string>,\n        message: RawTransactionArgument<number[]>,\n        cap: RawTransactionArgument<string>\n    ];\n}\nexport function processCheckpointMessageByCap(options: ProcessCheckpointMessageByCapOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        'vector<u8>',\n        `${packageAddress}::protocol_cap::ProtocolCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"message\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'process_checkpoint_message_by_cap',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface SetApprovedUpgradeByCapArguments {\n    self: RawTransactionArgument<string>;\n    packageId: RawTransactionArgument<string>;\n    digest: RawTransactionArgument<number[] | null>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface SetApprovedUpgradeByCapOptions {\n    package?: string;\n    arguments: SetApprovedUpgradeByCapArguments | [\n        self: RawTransactionArgument<string>,\n        packageId: RawTransactionArgument<string>,\n        digest: RawTransactionArgument<number[] | null>,\n        cap: RawTransactionArgument<string>\n    ];\n}\nexport function setApprovedUpgradeByCap(options: SetApprovedUpgradeByCapOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n        '0x0000000000000000000000000000000000000000000000000000000000000001::option::Option<vector<u8>>',\n        `${packageAddress}::protocol_cap::ProtocolCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"packageId\", \"digest\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'set_approved_upgrade_by_cap',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface SetOrRemoveWitnessApprovingAdvanceEpochByCapArguments {\n    self: RawTransactionArgument<string>;\n    witnessType: RawTransactionArgument<string>;\n    remove: RawTransactionArgument<boolean>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface SetOrRemoveWitnessApprovingAdvanceEpochByCapOptions {\n    package?: string;\n    arguments: SetOrRemoveWitnessApprovingAdvanceEpochByCapArguments | [\n        self: RawTransactionArgument<string>,\n        witnessType: RawTransactionArgument<string>,\n        remove: RawTransactionArgument<boolean>,\n        cap: RawTransactionArgument<string>\n    ];\n}\nexport function setOrRemoveWitnessApprovingAdvanceEpochByCap(options: SetOrRemoveWitnessApprovingAdvanceEpochByCapOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n        'bool',\n        `${packageAddress}::protocol_cap::ProtocolCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"witnessType\", \"remove\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'set_or_remove_witness_approving_advance_epoch_by_cap',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface TryMigrateByCapArguments {\n    self: RawTransactionArgument<string>;\n    cap: RawTransactionArgument<string>;\n}\nexport interface TryMigrateByCapOptions {\n    package?: string;\n    arguments: TryMigrateByCapArguments | [\n        self: RawTransactionArgument<string>,\n        cap: RawTransactionArgument<string>\n    ];\n}\n/**\n * Try to migrate the system object to the new package id using a cap.\n *\n * This function sets the new package id and version and can be modified in future\n * versions to migrate changes in the `system_inner` object if needed. This\n * function can be called immediately after the upgrade is committed.\n */\nexport function tryMigrateByCap(options: TryMigrateByCapOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::protocol_cap::ProtocolCap`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"cap\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'try_migrate_by_cap',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface TryMigrateArguments {\n    self: RawTransactionArgument<string>;\n}\nexport interface TryMigrateOptions {\n    package?: string;\n    arguments: TryMigrateArguments | [\n        self: RawTransactionArgument<string>\n    ];\n}\n/**\n * Try to migrate the system object to the new package id.\n *\n * This function sets the new package id and version and can be modified in future\n * versions to migrate changes in the `system_inner` object if needed. Call this\n * function after the migration epoch is reached.\n */\nexport function tryMigrate(options: TryMigrateOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`\n    ] satisfies string[];\n    const parameterNames = [\"self\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'try_migrate',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface VersionArguments {\n    self: RawTransactionArgument<string>;\n}\nexport interface VersionOptions {\n    package?: string;\n    arguments: VersionArguments | [\n        self: RawTransactionArgument<string>\n    ];\n}\nexport function version(options: VersionOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`\n    ] satisfies string[];\n    const parameterNames = [\"self\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'version',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface CalculateRewardsArguments {\n    self: RawTransactionArgument<string>;\n    validatorId: RawTransactionArgument<string>;\n    stakedPrincipal: RawTransactionArgument<number | bigint>;\n    activationEpoch: RawTransactionArgument<number | bigint>;\n    withdrawEpoch: RawTransactionArgument<number | bigint>;\n}\nexport interface CalculateRewardsOptions {\n    package?: string;\n    arguments: CalculateRewardsArguments | [\n        self: RawTransactionArgument<string>,\n        validatorId: RawTransactionArgument<string>,\n        stakedPrincipal: RawTransactionArgument<number | bigint>,\n        activationEpoch: RawTransactionArgument<number | bigint>,\n        withdrawEpoch: RawTransactionArgument<number | bigint>\n    ];\n}\n/**\n * Calculates the rewards for an amount with value `staked_principal`, staked in\n * the validator with the given `validator_id` between `activation_epoch` and\n * `withdraw_epoch`.\n *\n * This function can be used with `dev_inspect` to calculate the expected rewards\n * for a `StakedIka` object or, more generally, the returns provided by a given\n * validator over a given period.\n */\nexport function calculateRewards(options: CalculateRewardsOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n        'u64',\n        'u64',\n        'u64'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"validatorId\", \"stakedPrincipal\", \"activationEpoch\", \"withdrawEpoch\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'calculate_rewards',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface CanWithdrawStakedIkaEarlyArguments {\n    self: RawTransactionArgument<string>;\n    stakedIka: RawTransactionArgument<string>;\n}\nexport interface CanWithdrawStakedIkaEarlyOptions {\n    package?: string;\n    arguments: CanWithdrawStakedIkaEarlyArguments | [\n        self: RawTransactionArgument<string>,\n        stakedIka: RawTransactionArgument<string>\n    ];\n}\n/**\n * Call `staked_ika::can_withdraw_early` to allow calling this method in\n * applications.\n */\nexport function canWithdrawStakedIkaEarly(options: CanWithdrawStakedIkaEarlyOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `${packageAddress}::staked_ika::StakedIka`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"stakedIka\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'can_withdraw_staked_ika_early',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface EpochArguments {\n    self: RawTransactionArgument<string>;\n}\nexport interface EpochOptions {\n    package?: string;\n    arguments: EpochArguments | [\n        self: RawTransactionArgument<string>\n    ];\n}\n/**\n * Return the current epoch number. Useful for applications that need a\n * coarse-grained concept of time, since epochs are ever-increasing and epoch\n * changes are intended to happen every 24 hours.\n */\nexport function epoch(options: EpochOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`\n    ] satisfies string[];\n    const parameterNames = [\"self\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'epoch',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface ValidatorStakeAmountArguments {\n    self: RawTransactionArgument<string>;\n    validatorId: RawTransactionArgument<string>;\n}\nexport interface ValidatorStakeAmountOptions {\n    package?: string;\n    arguments: ValidatorStakeAmountArguments | [\n        self: RawTransactionArgument<string>,\n        validatorId: RawTransactionArgument<string>\n    ];\n}\n/**\n * Returns the total amount staked with `validator_id`. Aborts if `validator_id` is\n * not an active validator.\n */\nexport function validatorStakeAmount(options: ValidatorStakeAmountOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::object::ID'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"validatorId\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'validator_stake_amount',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface ClaimMetadataCapArguments {\n    self: RawTransactionArgument<string>;\n    currency: RawTransactionArgument<string>;\n}\nexport interface ClaimMetadataCapOptions {\n    package?: string;\n    arguments: ClaimMetadataCapArguments | [\n        self: RawTransactionArgument<string>,\n        currency: RawTransactionArgument<string>\n    ];\n}\nexport function claimMetadataCap(options: ClaimMetadataCapOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::system::System`,\n        `0x0000000000000000000000000000000000000000000000000000000000000002::coin_registry::Currency<${packageAddress}::ika::IKA>`\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"currency\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'system',\n        function: 'claim_metadata_cap',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}"],
  "mappings": "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",
  "names": []
}
