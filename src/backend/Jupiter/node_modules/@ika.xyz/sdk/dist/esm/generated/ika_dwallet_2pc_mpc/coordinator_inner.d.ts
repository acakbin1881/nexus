/**************************************************************
 * THIS FILE IS GENERATED AND SHOULD NOT BE MANUALLY MODIFIED *
 **************************************************************/
/**
 * # dWallet 2PC-MPC Coordinator Inner Module
 *
 * This module implements the core logic for creating and managing dWallets using
 * Multi-Party Computation (MPC) protocols. It provides a trustless and
 * decentralized approach to wallet creation and key management through distributed
 * key generation (DKG) and threshold signing protocols.
 *
 * ## Key Features
 *
 * - Distributed Key Generation (DKG) for secure key creation
 * - Threshold signing with presign optimization
 * - Network encryption key management and reconfiguration
 * - User encryption key registration and management
 * - Session-based MPC protocol coordination
 * - Epoch-based validator committee transitions
 * - Comprehensive pricing and fee management
 * - Support for multiple cryptographic curves and algorithms
 *
 * ## Architecture
 *
 * The module is organized around the `DWalletCoordinatorInner` struct which
 * manages:
 *
 * - dWallet lifecycle and state transitions
 * - MPC session coordination and scheduling
 * - Validator committee management
 * - Cryptographic algorithm support and emergency controls
 * - Economic incentives through pricing and fee collection
 */
import { MoveStruct, MoveEnum, type RawTransactionArgument } from '../utils/index.js';
import { type Transaction } from '@mysten/sui/transactions';
export declare const DWalletCoordinatorWitness: MoveStruct<{
    dummy_field: import("@mysten/bcs").BcsType<boolean, boolean, "bool">;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWalletCoordinatorWitness">;
export declare const DWalletCoordinatorInner: MoveStruct<{
    /** Current epoch number */
    current_epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    /** Session management and coordination */
    sessions_manager: MoveStruct<{
        registered_user_session_identifiers: MoveStruct<{
            id: MoveStruct<{
                id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
            }, "0x2::object::UID">;
            size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
        }, "0x2::table::Table">;
        user_sessions_keeper: MoveStruct<{
            sessions: MoveStruct<{
                id: MoveStruct<{
                    id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
                }, "0x2::object::UID">;
                size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
            }, "0x2::object_table::ObjectTable">;
            session_events: MoveStruct<{
                id: MoveStruct<{
                    id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
                }, "0x2::object::UID">;
                size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
            }, "0x2::bag::Bag">;
            started_sessions_count: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
            completed_sessions_count: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
            next_session_sequence_number: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
        }, "@local-pkg/2pc-mpc::sessions_manager::SessionsKeeper">;
        system_sessions_keeper: MoveStruct<{
            sessions: MoveStruct<{
                id: MoveStruct<{
                    id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
                }, "0x2::object::UID">;
                size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
            }, "0x2::object_table::ObjectTable">;
            session_events: MoveStruct<{
                id: MoveStruct<{
                    id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
                }, "0x2::object::UID">;
                size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
            }, "0x2::bag::Bag">;
            started_sessions_count: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
            completed_sessions_count: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
            next_session_sequence_number: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
        }, "@local-pkg/2pc-mpc::sessions_manager::SessionsKeeper">;
        last_user_initiated_session_to_complete_in_current_epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
        locked_last_user_initiated_session_to_complete_in_current_epoch: import("@mysten/bcs").BcsType<boolean, boolean, "bool">;
        max_active_sessions_buffer: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "@local-pkg/2pc-mpc::sessions_manager::SessionsManager">;
    /** All dWallet instances (DWallet ID -> DWallet) */
    dwallets: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "0x2::object_table::ObjectTable">;
    /**
     * Network encryption keys (Network encryption key ID ->
     * DWalletNetworkEncryptionKey)
     */
    dwallet_network_encryption_keys: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "0x2::object_table::ObjectTable">;
    /**
     * Number of network encryption keys reconfiguration have been completed for the
     * current epoch
     */
    epoch_dwallet_network_encryption_keys_reconfiguration_completed: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    /** User encryption keys (User encryption key address -> EncryptionKey) */
    encryption_keys: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "0x2::object_table::ObjectTable">;
    /**
     * Presign sessions for signature optimization (Presign session ID ->
     * PresignSession)
     */
    presign_sessions: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "0x2::object_table::ObjectTable">;
    /**
     * Partial user signatures for future signing (Partial user signature ID ->
     * PartialUserSignature)
     */
    partial_centralized_signed_messages: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "0x2::object_table::ObjectTable">;
    /** Pricing and fee management */
    pricing_and_fee_manager: MoveStruct<{
        current: MoveStruct<{
            pricing_map: MoveStruct<{
                contents: import("@mysten/bcs").BcsType<{
                    key: {
                        curve: number;
                        signature_algorithm: number | null;
                        protocol: number;
                    };
                    value: {
                        fee_ika: string;
                        gas_fee_reimbursement_sui: string;
                        gas_fee_reimbursement_sui_for_system_calls: string;
                    };
                }[], Iterable<{
                    key: {
                        curve: number;
                        signature_algorithm: number | null | undefined;
                        protocol: number;
                    };
                    value: {
                        fee_ika: string | number | bigint;
                        gas_fee_reimbursement_sui: string | number | bigint;
                        gas_fee_reimbursement_sui_for_system_calls: string | number | bigint;
                    };
                }> & {
                    length: number;
                }, string>;
            }, "0x2::vec_map::VecMap<@local-pkg/2pc-mpc::pricing::PricingInfoKey, @local-pkg/2pc-mpc::pricing::PricingInfoValue>">;
        }, "@local-pkg/2pc-mpc::pricing::PricingInfo">;
        default: MoveStruct<{
            pricing_map: MoveStruct<{
                contents: import("@mysten/bcs").BcsType<{
                    key: {
                        curve: number;
                        signature_algorithm: number | null;
                        protocol: number;
                    };
                    value: {
                        fee_ika: string;
                        gas_fee_reimbursement_sui: string;
                        gas_fee_reimbursement_sui_for_system_calls: string;
                    };
                }[], Iterable<{
                    key: {
                        curve: number;
                        signature_algorithm: number | null | undefined;
                        protocol: number;
                    };
                    value: {
                        fee_ika: string | number | bigint;
                        gas_fee_reimbursement_sui: string | number | bigint;
                        gas_fee_reimbursement_sui_for_system_calls: string | number | bigint;
                    };
                }> & {
                    length: number;
                }, string>;
            }, "0x2::vec_map::VecMap<@local-pkg/2pc-mpc::pricing::PricingInfoKey, @local-pkg/2pc-mpc::pricing::PricingInfoValue>">;
        }, "@local-pkg/2pc-mpc::pricing::PricingInfo">;
        validator_votes: MoveStruct<{
            id: MoveStruct<{
                id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
            }, "0x2::object::UID">;
            size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
        }, "0x2::table::Table">;
        pricing_calculation_votes: import("@mysten/bcs").BcsType<{
            bls_committee: {
                members: {
                    validator_id: string;
                    protocol_pubkey: {
                        bytes: number[];
                    };
                }[];
                aggregated_protocol_pubkey: {
                    bytes: number[];
                };
                quorum_threshold: string;
                validity_threshold: string;
            };
            default_pricing: {
                pricing_map: {
                    contents: {
                        key: {
                            curve: number;
                            signature_algorithm: number | null;
                            protocol: number;
                        };
                        value: {
                            fee_ika: string;
                            gas_fee_reimbursement_sui: string;
                            gas_fee_reimbursement_sui_for_system_calls: string;
                        };
                    }[];
                };
            };
            working_pricing: {
                pricing_map: {
                    contents: {
                        key: {
                            curve: number;
                            signature_algorithm: number | null;
                            protocol: number;
                        };
                        value: {
                            fee_ika: string;
                            gas_fee_reimbursement_sui: string;
                            gas_fee_reimbursement_sui_for_system_calls: string;
                        };
                    }[];
                };
            };
        } | null, {
            bls_committee: {
                members: Iterable<{
                    validator_id: string | Uint8Array<ArrayBufferLike>;
                    protocol_pubkey: {
                        bytes: Iterable<number> & {
                            length: number;
                        };
                    };
                }> & {
                    length: number;
                };
                aggregated_protocol_pubkey: {
                    bytes: Iterable<number> & {
                        length: number;
                    };
                };
                quorum_threshold: string | number | bigint;
                validity_threshold: string | number | bigint;
            };
            default_pricing: {
                pricing_map: {
                    contents: Iterable<{
                        key: {
                            curve: number;
                            signature_algorithm: number | null | undefined;
                            protocol: number;
                        };
                        value: {
                            fee_ika: string | number | bigint;
                            gas_fee_reimbursement_sui: string | number | bigint;
                            gas_fee_reimbursement_sui_for_system_calls: string | number | bigint;
                        };
                    }> & {
                        length: number;
                    };
                };
            };
            working_pricing: {
                pricing_map: {
                    contents: Iterable<{
                        key: {
                            curve: number;
                            signature_algorithm: number | null | undefined;
                            protocol: number;
                        };
                        value: {
                            fee_ika: string | number | bigint;
                            gas_fee_reimbursement_sui: string | number | bigint;
                            gas_fee_reimbursement_sui_for_system_calls: string | number | bigint;
                        };
                    }> & {
                        length: number;
                    };
                };
            };
        } | null | undefined, "Option<@local-pkg/2pc-mpc::pricing::PricingInfoCalculationVotes>">;
        gas_fee_reimbursement_sui_system_call_value: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
        gas_fee_reimbursement_sui_system_call_balance: MoveStruct<{
            value: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
        }, "0x2::balance::Balance">;
        fee_charged_ika: MoveStruct<{
            value: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
        }, "0x2::balance::Balance">;
    }, "@local-pkg/2pc-mpc::pricing_and_fee_manager::PricingAndFeeManager">;
    /** Current active validator committee */
    active_committee: MoveStruct<{
        members: import("@mysten/bcs").BcsType<{
            validator_id: string;
            protocol_pubkey: {
                bytes: number[];
            };
        }[], Iterable<{
            validator_id: string | Uint8Array<ArrayBufferLike>;
            protocol_pubkey: {
                bytes: Iterable<number> & {
                    length: number;
                };
            };
        }> & {
            length: number;
        }, string>;
        aggregated_protocol_pubkey: MoveStruct<{
            bytes: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
                length: number;
            }, string>;
        }, "0x2::group_ops::Element">;
        quorum_threshold: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
        validity_threshold: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "ika_common::bls_committee::BlsCommittee">;
    /** Next epoch active validator committee */
    next_epoch_active_committee: import("@mysten/bcs").BcsType<{
        members: {
            validator_id: string;
            protocol_pubkey: {
                bytes: number[];
            };
        }[];
        aggregated_protocol_pubkey: {
            bytes: number[];
        };
        quorum_threshold: string;
        validity_threshold: string;
    } | null, {
        members: Iterable<{
            validator_id: string | Uint8Array<ArrayBufferLike>;
            protocol_pubkey: {
                bytes: Iterable<number> & {
                    length: number;
                };
            };
        }> & {
            length: number;
        };
        aggregated_protocol_pubkey: {
            bytes: Iterable<number> & {
                length: number;
            };
        };
        quorum_threshold: string | number | bigint;
        validity_threshold: string | number | bigint;
    } | null | undefined, "Option<ika_common::bls_committee::BlsCommittee>">;
    /** Total number of messages processed */
    total_messages_processed: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    /** Last processed checkpoint sequence number */
    last_processed_checkpoint_sequence_number: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    /** Last checkpoint sequence number from previous epoch */
    previous_epoch_last_checkpoint_sequence_number: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    /** Cryptographic algorithm support configuration */
    support_config: MoveStruct<{
        supported_curves_to_signature_algorithms_to_hash_schemes: MoveStruct<{
            contents: import("@mysten/bcs").BcsType<{
                key: number;
                value: {
                    contents: {
                        key: number;
                        value: number[];
                    }[];
                };
            }[], Iterable<{
                key: number;
                value: {
                    contents: Iterable<{
                        key: number;
                        value: Iterable<number> & {
                            length: number;
                        };
                    }> & {
                        length: number;
                    };
                };
            }> & {
                length: number;
            }, string>;
        }, "0x2::vec_map::VecMap<u32, 0x2::vec_map::VecMap<u32, vector<u32>>>">;
        paused_curves: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
        paused_signature_algorithms: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
        paused_hash_schemes: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
        signature_algorithms_allowed_global_presign: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
    }, "@local-pkg/2pc-mpc::support_config::SupportConfig">;
    received_end_of_publish: import("@mysten/bcs").BcsType<boolean, boolean, "bool">;
    /** Any extra fields that's not defined statically */
    extra_fields: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "0x2::bag::Bag">;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWalletCoordinatorInner">;
export declare const DWalletCap: MoveStruct<{
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    /** ID of the controlled dWallet */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWalletCap">;
export declare const ImportedKeyDWalletCap: MoveStruct<{
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    /** ID of the controlled imported key dWallet */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::ImportedKeyDWalletCap">;
/** State of a dWallet network encryption key throughout its lifecycle */
export declare const DWalletNetworkEncryptionKeyState: MoveEnum<{
    /** DKG request was sent to the network, but didn't finish yet. */
    AwaitingNetworkDKG: null;
    /** Network DKG has completed successfully */
    NetworkDKGCompleted: null;
    /** Reconfiguration request was sent to the network, but didn't finish yet. */
    AwaitingNetworkReconfiguration: null;
    /** Network reconfiguration has completed successfully */
    NetworkReconfigurationCompleted: null;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWalletNetworkEncryptionKeyState">;
export declare const DWalletNetworkEncryptionKey: MoveStruct<{
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    /** Epoch when the network DKG was initiated */
    dkg_at_epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    /** Initial network DKG output (chunked for storage efficiency) */
    network_dkg_public_output: MoveStruct<{
        contents: MoveStruct<{
            id: MoveStruct<{
                id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
            }, "0x2::object::UID">;
            size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
        }, "0x2::table::Table">;
    }, "0x2::table_vec::TableVec">;
    /** Reconfiguration outputs indexed by epoch (Epoch -> Chunked Output) */
    reconfiguration_public_outputs: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "0x2::table::Table">;
    /** Parameters for network dkg */
    dkg_params_for_network: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Curves supported by this network encryption key */
    supported_curves: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Current operational state */
    state: MoveEnum<{
        /** DKG request was sent to the network, but didn't finish yet. */
        AwaitingNetworkDKG: null;
        /** Network DKG has completed successfully */
        NetworkDKGCompleted: null;
        /** Reconfiguration request was sent to the network, but didn't finish yet. */
        AwaitingNetworkReconfiguration: null;
        /** Network reconfiguration has completed successfully */
        NetworkReconfigurationCompleted: null;
    }, "@local-pkg/2pc-mpc::coordinator_inner::DWalletNetworkEncryptionKeyState">;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWalletNetworkEncryptionKey">;
export declare const EncryptionKey: MoveStruct<{
    /** Unique identifier for this encryption key */
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    /** Epoch when this key was created */
    created_at_epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    /** Cryptographic curve this key supports */
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Serialized encryption key data */
    encryption_key: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /**
     * Ed25519 signature proving encryption key authenticity, signed by the
     * `signer_public_key`. Used to verify the data originated from the
     * `signer_address`.
     */
    encryption_key_signature: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Ed25519 public key used to create the signature */
    signer_public_key: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Address of the encryption key owner */
    signer_address: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::EncryptionKey">;
/**
 * State of an encrypted user secret key share throughout verification and
 * acceptance
 */
export declare const EncryptedUserSecretKeyShareState: MoveEnum<{
    /** Waiting for network to verify the encryption proof */
    AwaitingNetworkVerification: null;
    /** Network has successfully verified the encryption */
    NetworkVerificationCompleted: null;
    /** Network has rejected the encryption verification */
    NetworkVerificationRejected: null;
    /** Key holder has signed and accepted the share */
    KeyHolderSigned: MoveStruct<{
        user_output_signature: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
    }, "EncryptedUserSecretKeyShareState.KeyHolderSigned">;
}, "@local-pkg/2pc-mpc::coordinator_inner::EncryptedUserSecretKeyShareState">;
export declare const EncryptedUserSecretKeyShare: MoveStruct<{
    /** Unique identifier for this encrypted share */
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    /** Epoch when this share was created */
    created_at_epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    /** ID of the dWallet this share belongs to */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /**
     * Encrypted secret share with zero-knowledge proof of correctness for the
     * dWallet's secret key share (of `dwallet_id`).
     */
    encrypted_centralized_secret_share_and_proof: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the encryption key used for encryption */
    encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Address of the encryption key owner */
    encryption_key_address: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Source share ID if this was created via re-encryption (None for DKG-created) */
    source_encrypted_user_secret_key_share_id: import("@mysten/bcs").BcsType<string | null, string | Uint8Array<ArrayBufferLike> | null | undefined, "Option<bytes[32]>">;
    /** Current verification and acceptance state */
    state: MoveEnum<{
        /** Waiting for network to verify the encryption proof */
        AwaitingNetworkVerification: null;
        /** Network has successfully verified the encryption */
        NetworkVerificationCompleted: null;
        /** Network has rejected the encryption verification */
        NetworkVerificationRejected: null;
        /** Key holder has signed and accepted the share */
        KeyHolderSigned: MoveStruct<{
            user_output_signature: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
                length: number;
            }, string>;
        }, "EncryptedUserSecretKeyShareState.KeyHolderSigned">;
    }, "@local-pkg/2pc-mpc::coordinator_inner::EncryptedUserSecretKeyShareState">;
}, "@local-pkg/2pc-mpc::coordinator_inner::EncryptedUserSecretKeyShare">;
export declare const UnverifiedPartialUserSignatureCap: MoveStruct<{
    /** Unique identifier for this capability */
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    /** ID of the associated partial user signature */
    partial_centralized_signed_message_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::UnverifiedPartialUserSignatureCap">;
export declare const VerifiedPartialUserSignatureCap: MoveStruct<{
    /** Unique identifier for this capability */
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    /** ID of the associated verified partial user signature */
    partial_centralized_signed_message_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::VerifiedPartialUserSignatureCap">;
export declare const VerifiedPresignCap: MoveStruct<{
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    /**
     * Target dWallet ID for dWallet-specific presigns
     *
     * - `Some(id)`: Can only be used with the specified dWallet (e.g. ECDSA
     *   requirement)
     * - `None`: Global presign, can be used with any compatible dWallet (e.g. Schnorr
     *   and EdDSA)
     */
    dwallet_id: import("@mysten/bcs").BcsType<string | null, string | Uint8Array<ArrayBufferLike> | null | undefined, "Option<bytes[32]>">;
    /** ID of the associated presign session */
    presign_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::VerifiedPresignCap">;
export declare const PartialUserSignatureState: MoveEnum<{
    AwaitingNetworkVerification: null;
    NetworkVerificationCompleted: null;
    NetworkVerificationRejected: null;
}, "@local-pkg/2pc-mpc::coordinator_inner::PartialUserSignatureState">;
export declare const PartialUserSignature: MoveStruct<{
    /** Unique identifier for this partial signature */
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    /** Epoch when this partial signature was created */
    created_at_epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    /** Presign capability (consumed to prevent reuse) */
    presign_cap: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        /**
         * Target dWallet ID for dWallet-specific presigns
         *
         * - `Some(id)`: Can only be used with the specified dWallet (e.g. ECDSA
         *   requirement)
         * - `None`: Global presign, can be used with any compatible dWallet (e.g. Schnorr
         *   and EdDSA)
         */
        dwallet_id: import("@mysten/bcs").BcsType<string | null, string | Uint8Array<ArrayBufferLike> | null | undefined, "Option<bytes[32]>">;
        /** ID of the associated presign session */
        presign_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "@local-pkg/2pc-mpc::coordinator_inner::VerifiedPresignCap">;
    /** ID of the dWallet that will complete the signature */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the capability that controls completion */
    cap_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Cryptographic curve for the signature */
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Signature algorithm to be used */
    signature_algorithm: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Hash scheme to apply to the message */
    hash_scheme: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Raw message bytes to be signed */
    message: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** User's partial signature on the message */
    message_centralized_signature: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Current verification state */
    state: MoveEnum<{
        AwaitingNetworkVerification: null;
        NetworkVerificationCompleted: null;
        NetworkVerificationRejected: null;
    }, "@local-pkg/2pc-mpc::coordinator_inner::PartialUserSignatureState">;
}, "@local-pkg/2pc-mpc::coordinator_inner::PartialUserSignature">;
/**
 * State of a dWallet throughout its creation and operational lifecycle.
 *
 * dWallets can be created through two paths:
 *
 * 1.  **DKG Path**: Distributed Key Generation with validator participation
 * 2.  **Import Path**: Importing existing private keys with network verification
 *
 * Both paths converge to the `Active` state where signing operations can be
 * performed.
 */
export declare const DWalletState: MoveEnum<{
    /** DKG first round has been requested from the network */
    DKGRequested: null;
    /** Network rejected the DKG first round request */
    NetworkRejectedDKGRequest: null;
    /** DKG first round completed, waiting for user to initiate second round */
    AwaitingUserDKGVerificationInitiation: MoveStruct<{
        first_round_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
    }, "DWalletState.AwaitingUserDKGVerificationInitiation">;
    /** DKG second round has been requested, waiting for network verification */
    AwaitingNetworkDKGVerification: null;
    /** Network rejected the DKG second round verification */
    NetworkRejectedDKGVerification: null;
    /** Imported key verification requested, waiting for network verification */
    AwaitingNetworkImportedKeyVerification: null;
    /** Network rejected the imported key verification */
    NetworkRejectedImportedKeyVerification: null;
    /** DKG/Import completed, waiting for key holder to sign and accept */
    AwaitingKeyHolderSignature: MoveStruct<{
        public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
    }, "DWalletState.AwaitingKeyHolderSignature">;
    /** dWallet is fully operational and ready for signing */
    Active: MoveStruct<{
        public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
    }, "DWalletState.Active">;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWalletState">;
export declare const DWallet: MoveStruct<{
    /** Unique identifier for the dWallet */
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    /** Epoch when this dWallet was created */
    created_at_epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    /** Elliptic curve used for cryptographic operations */
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
    /**
     * Public user secret key share (if trust-minimized mode is enabled)
     *
     * - `None`: Zero-trust mode - user participation required for signing
     * - `Some(share)`: Trust-minimized mode - network can sign independently
     */
    public_user_secret_key_share: import("@mysten/bcs").BcsType<number[] | null, (Iterable<number> & {
        length: number;
    }) | null | undefined, "Option<vector<u8>>">;
    /** ID of the capability that controls this dWallet */
    dwallet_cap_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Network encryption key used for securing this dWallet's network share */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Whether this dWallet was created from an imported key */
    is_imported_key_dwallet: import("@mysten/bcs").BcsType<boolean, boolean, "bool">;
    /**
     * Encrypted user secret key shares (Encryption user secret key share ID ->
     * EncryptedUserSecretKeyShare)
     */
    encrypted_user_secret_key_shares: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "0x2::object_table::ObjectTable">;
    /** Signing sessions (Sign ID -> SignSession) */
    sign_sessions: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "0x2::object_table::ObjectTable">;
    /** Current state of the dWallet */
    state: MoveEnum<{
        /** DKG first round has been requested from the network */
        DKGRequested: null;
        /** Network rejected the DKG first round request */
        NetworkRejectedDKGRequest: null;
        /** DKG first round completed, waiting for user to initiate second round */
        AwaitingUserDKGVerificationInitiation: MoveStruct<{
            first_round_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
                length: number;
            }, string>;
        }, "DWalletState.AwaitingUserDKGVerificationInitiation">;
        /** DKG second round has been requested, waiting for network verification */
        AwaitingNetworkDKGVerification: null;
        /** Network rejected the DKG second round verification */
        NetworkRejectedDKGVerification: null;
        /** Imported key verification requested, waiting for network verification */
        AwaitingNetworkImportedKeyVerification: null;
        /** Network rejected the imported key verification */
        NetworkRejectedImportedKeyVerification: null;
        /** DKG/Import completed, waiting for key holder to sign and accept */
        AwaitingKeyHolderSignature: MoveStruct<{
            public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
                length: number;
            }, string>;
        }, "DWalletState.AwaitingKeyHolderSignature">;
        /** dWallet is fully operational and ready for signing */
        Active: MoveStruct<{
            public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
                length: number;
            }, string>;
        }, "DWalletState.Active">;
    }, "@local-pkg/2pc-mpc::coordinator_inner::DWalletState">;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWallet">;
export declare const UnverifiedPresignCap: MoveStruct<{
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    /**
     * Target dWallet ID for dWallet-specific presigns
     *
     * - `Some(id)`: Can only be used with the specified dWallet (e.g. ECDSA
     *   requirement)
     * - `None`: Global presign, can be used with any compatible dWallet (e.g. Schnorr
     *   and EdDSA)
     */
    dwallet_id: import("@mysten/bcs").BcsType<string | null, string | Uint8Array<ArrayBufferLike> | null | undefined, "Option<bytes[32]>">;
    /** ID of the associated presign session */
    presign_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::UnverifiedPresignCap">;
/**
 * State progression of a presign session through its lifecycle.
 *
 * Presign sessions follow a linear progression from request to completion, with
 * potential rejection at the network validation stage.
 */
export declare const PresignState: MoveEnum<{
    /** Presign has been requested and is awaiting network processing */
    Requested: null;
    /**
     * Network rejected the presign request (invalid parameters, insufficient
     * resources, etc.)
     */
    NetworkRejected: null;
    /** Presign completed successfully with cryptographic material ready for use */
    Completed: MoveStruct<{
        presign: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
    }, "PresignState.Completed">;
}, "@local-pkg/2pc-mpc::coordinator_inner::PresignState">;
export declare const PresignSession: MoveStruct<{
    /** Unique identifier for this presign session */
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    /** Epoch when this presign was created */
    created_at_epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    /** Elliptic curve used for the presign */
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Signature algorithm this presign supports */
    signature_algorithm: import("@mysten/bcs").BcsType<number, number, "u32">;
    /**
     * Target dWallet ID (None for global presigns)
     *
     * - `Some(id)`: dWallet-specific presign (e.g. required for ECDSA)
     * - `None`: Global presign (e.g. available for Schnorr, EdDSA)
     */
    dwallet_id: import("@mysten/bcs").BcsType<string | null, string | Uint8Array<ArrayBufferLike> | null | undefined, "Option<bytes[32]>">;
    /** ID of the capability that controls this presign */
    cap_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Current state of the presign computation */
    state: MoveEnum<{
        /** Presign has been requested and is awaiting network processing */
        Requested: null;
        /**
         * Network rejected the presign request (invalid parameters, insufficient
         * resources, etc.)
         */
        NetworkRejected: null;
        /** Presign completed successfully with cryptographic material ready for use */
        Completed: MoveStruct<{
            presign: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
                length: number;
            }, string>;
        }, "PresignState.Completed">;
    }, "@local-pkg/2pc-mpc::coordinator_inner::PresignState">;
}, "@local-pkg/2pc-mpc::coordinator_inner::PresignSession">;
/**
 * State progression of a signing session through its lifecycle.
 *
 * Signing sessions combine user authorization with network cryptographic
 * operations to produce final signatures.
 */
export declare const SignState: MoveEnum<{
    /** Signature has been requested and is awaiting network processing */
    Requested: null;
    /**
     * Network rejected the signature request (invalid presign, unauthorized message,
     * etc.)
     */
    NetworkRejected: null;
    /** Signature completed successfully and ready for use */
    Completed: MoveStruct<{
        signature: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
    }, "SignState.Completed">;
}, "@local-pkg/2pc-mpc::coordinator_inner::SignState">;
export declare const SignSession: MoveStruct<{
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    /** Epoch when this signing session was initiated */
    created_at_epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    /** ID of the dWallet performing the signature */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Current state of the signing process */
    state: MoveEnum<{
        /** Signature has been requested and is awaiting network processing */
        Requested: null;
        /**
         * Network rejected the signature request (invalid presign, unauthorized message,
         * etc.)
         */
        NetworkRejected: null;
        /** Signature completed successfully and ready for use */
        Completed: MoveStruct<{
            signature: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
                length: number;
            }, string>;
        }, "SignState.Completed">;
    }, "@local-pkg/2pc-mpc::coordinator_inner::SignState">;
}, "@local-pkg/2pc-mpc::coordinator_inner::SignSession">;
export declare const MessageApproval: MoveStruct<{
    /** ID of the dWallet authorized to sign this message */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Cryptographic signature algorithm to use */
    signature_algorithm: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Hash scheme to apply to the message before signing */
    hash_scheme: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Raw message bytes to be signed */
    message: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
}, "@local-pkg/2pc-mpc::coordinator_inner::MessageApproval">;
export declare const ImportedKeyMessageApproval: MoveStruct<{
    /** ID of the imported key dWallet authorized to sign this message */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Cryptographic signature algorithm to use */
    signature_algorithm: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Hash scheme to apply to the message before signing */
    hash_scheme: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Raw message bytes to be signed */
    message: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
}, "@local-pkg/2pc-mpc::coordinator_inner::ImportedKeyMessageApproval">;
export declare const SignDuringDKGRequest: MoveStruct<{
    presign_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    presign: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
    signature_algorithm: import("@mysten/bcs").BcsType<number, number, "u32">;
    hash_scheme: import("@mysten/bcs").BcsType<number, number, "u32">;
    message: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    message_centralized_signature: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
}, "@local-pkg/2pc-mpc::coordinator_inner::SignDuringDKGRequest">;
export declare const DWalletNetworkDKGEncryptionKeyRequestEvent: MoveStruct<{
    /** ID of the network encryption key to be generated */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Parameters for the network */
    params_for_network: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWalletNetworkDKGEncryptionKeyRequestEvent">;
export declare const CompletedDWalletNetworkDKGEncryptionKeyEvent: MoveStruct<{
    /** ID of the successfully generated network encryption key */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::CompletedDWalletNetworkDKGEncryptionKeyEvent">;
export declare const RejectedDWalletNetworkDKGEncryptionKeyEvent: MoveStruct<{
    /** ID of the rejected network encryption key */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::RejectedDWalletNetworkDKGEncryptionKeyEvent">;
export declare const DWalletEncryptionKeyReconfigurationRequestEvent: MoveStruct<{
    /** ID of the network encryption key to be reconfigured */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWalletEncryptionKeyReconfigurationRequestEvent">;
export declare const CompletedDWalletEncryptionKeyReconfigurationEvent: MoveStruct<{
    /** ID of the successfully reconfigured network encryption key */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::CompletedDWalletEncryptionKeyReconfigurationEvent">;
export declare const RejectedDWalletEncryptionKeyReconfigurationEvent: MoveStruct<{
    /** ID of the network encryption key that failed reconfiguration */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::RejectedDWalletEncryptionKeyReconfigurationEvent">;
export declare const DWalletDKGFirstRoundRequestEvent: MoveStruct<{
    /** ID of the dWallet being created */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the capability that controls the dWallet */
    dwallet_cap_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Network encryption key for securing the dWallet's network share */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Elliptic curve for the dWallet's cryptographic operations */
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWalletDKGFirstRoundRequestEvent">;
export declare const CompletedDWalletDKGFirstRoundEvent: MoveStruct<{
    /** ID of the dWallet being created */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Public output from the first round of DKG */
    first_round_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
}, "@local-pkg/2pc-mpc::coordinator_inner::CompletedDWalletDKGFirstRoundEvent">;
export declare const RejectedDWalletDKGFirstRoundEvent: MoveStruct<{
    /** ID of the dWallet whose DKG first round was rejected */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::RejectedDWalletDKGFirstRoundEvent">;
export declare const DWalletDKGSecondRoundRequestEvent: MoveStruct<{
    /** ID of the encrypted user secret key share being created */
    encrypted_user_secret_key_share_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the dWallet being created through DKG */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Cryptographic output from the network's first round of DKG */
    first_round_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** User's public key share with cryptographic proof of correctness */
    centralized_public_key_share_and_proof: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the dWallet capability that authorizes this operation */
    dwallet_cap_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** User's encrypted secret key share with zero-knowledge proof */
    encrypted_centralized_secret_share_and_proof: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Serialized encryption key used to encrypt the user's secret share */
    encryption_key: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the encryption key object */
    encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Address of the encryption key owner */
    encryption_key_address: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** User's contribution to the DKG public output */
    user_public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Ed25519 public key for verifying the user's signature */
    signer_public_key: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the network encryption key for securing network shares */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Elliptic curve for the dWallet's cryptographic operations */
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWalletDKGSecondRoundRequestEvent">;
export declare const CompletedDWalletDKGSecondRoundEvent: MoveStruct<{
    /** ID of the successfully created dWallet */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Complete public output from the DKG process (public key and metadata) */
    public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the user's encrypted secret key share */
    encrypted_user_secret_key_share_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::CompletedDWalletDKGSecondRoundEvent">;
export declare const RejectedDWalletDKGSecondRoundEvent: MoveStruct<{
    /** ID of the dWallet whose DKG second round was rejected */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Public output that was being processed when rejection occurred */
    public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
}, "@local-pkg/2pc-mpc::coordinator_inner::RejectedDWalletDKGSecondRoundEvent">;
export declare const SignDuringDKGRequestEvent: MoveStruct<{
    sign_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    presign_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    presign: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    signature_algorithm: import("@mysten/bcs").BcsType<number, number, "u32">;
    hash_scheme: import("@mysten/bcs").BcsType<number, number, "u32">;
    message: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    message_centralized_signature: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
}, "@local-pkg/2pc-mpc::coordinator_inner::SignDuringDKGRequestEvent">;
export declare const UserSecretKeyShareEventType: MoveEnum<{
    Encrypted: MoveStruct<{
        encrypted_user_secret_key_share_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        encrypted_centralized_secret_share_and_proof: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
        encryption_key: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
        encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        encryption_key_address: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        signer_public_key: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
    }, "UserSecretKeyShareEventType.Encrypted">;
    Public: MoveStruct<{
        public_user_secret_key_share: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
    }, "UserSecretKeyShareEventType.Public">;
}, "@local-pkg/2pc-mpc::coordinator_inner::UserSecretKeyShareEventType">;
export declare const DWalletDKGRequestEvent: MoveStruct<{
    /** ID of the dWallet being created through DKG */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** User's public key share with cryptographic proof of correctness */
    centralized_public_key_share_and_proof: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** User's contribution to the DKG public output */
    user_public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the dWallet capability that authorizes this operation */
    dwallet_cap_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the network encryption key for securing network shares */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Elliptic curve for the dWallet's cryptographic operations */
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** User's secret key share */
    user_secret_key_share: MoveEnum<{
        Encrypted: MoveStruct<{
            encrypted_user_secret_key_share_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
            encrypted_centralized_secret_share_and_proof: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
                length: number;
            }, string>;
            encryption_key: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
                length: number;
            }, string>;
            encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
            encryption_key_address: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
            signer_public_key: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
                length: number;
            }, string>;
        }, "UserSecretKeyShareEventType.Encrypted">;
        Public: MoveStruct<{
            public_user_secret_key_share: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
                length: number;
            }, string>;
        }, "UserSecretKeyShareEventType.Public">;
    }, "@local-pkg/2pc-mpc::coordinator_inner::UserSecretKeyShareEventType">;
    /** Sign during DKG request */
    sign_during_dkg_request: import("@mysten/bcs").BcsType<{
        sign_id: string;
        presign_id: string;
        presign: number[];
        signature_algorithm: number;
        hash_scheme: number;
        message: number[];
        message_centralized_signature: number[];
    } | null, {
        sign_id: string | Uint8Array<ArrayBufferLike>;
        presign_id: string | Uint8Array<ArrayBufferLike>;
        presign: Iterable<number> & {
            length: number;
        };
        signature_algorithm: number;
        hash_scheme: number;
        message: Iterable<number> & {
            length: number;
        };
        message_centralized_signature: Iterable<number> & {
            length: number;
        };
    } | null | undefined, "Option<@local-pkg/2pc-mpc::coordinator_inner::SignDuringDKGRequestEvent>">;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWalletDKGRequestEvent">;
export declare const CompletedDWalletDKGEvent: MoveStruct<{
    /** ID of the successfully created dWallet */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Complete public output from the DKG process (public key and metadata) */
    public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the user's encrypted secret key share */
    encrypted_user_secret_key_share_id: import("@mysten/bcs").BcsType<string | null, string | Uint8Array<ArrayBufferLike> | null | undefined, "Option<bytes[32]>">;
    /** ID of the user's signature during DKG if it was requested */
    sign_id: import("@mysten/bcs").BcsType<string | null, string | Uint8Array<ArrayBufferLike> | null | undefined, "Option<bytes[32]>">;
}, "@local-pkg/2pc-mpc::coordinator_inner::CompletedDWalletDKGEvent">;
export declare const RejectedDWalletDKGEvent: MoveStruct<{
    /** ID of the dWallet whose DKG second round was rejected */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Public output that was being processed when rejection occurred */
    public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
}, "@local-pkg/2pc-mpc::coordinator_inner::RejectedDWalletDKGEvent">;
export declare const DWalletImportedKeyVerificationRequestEvent: MoveStruct<{
    /** ID of the imported key dWallet being verified */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the encrypted user secret key share being created */
    encrypted_user_secret_key_share_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** User's cryptographic message for importing computation */
    centralized_party_message: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the imported key dWallet capability */
    dwallet_cap_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** User's encrypted secret key share with proof of correctness */
    encrypted_centralized_secret_share_and_proof: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Serialized encryption key used for user share encryption */
    encryption_key: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the encryption key object */
    encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Address of the encryption key owner */
    encryption_key_address: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** User's public key contribution and verification data */
    user_public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /**
     * Ed25519 public key for signature verification, used to verify the user's
     * signature on the public output
     */
    signer_public_key: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the network encryption key for securing network shares */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Elliptic curve for the imported key dWallet */
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWalletImportedKeyVerificationRequestEvent">;
export declare const CompletedDWalletImportedKeyVerificationEvent: MoveStruct<{
    /** ID of the successfully verified imported key dWallet */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Public output from the verification process */
    public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the user's encrypted secret key share */
    encrypted_user_secret_key_share_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::CompletedDWalletImportedKeyVerificationEvent">;
export declare const RejectedDWalletImportedKeyVerificationEvent: MoveStruct<{
    /** ID of the imported key dWallet that failed verification */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::RejectedDWalletImportedKeyVerificationEvent">;
export declare const CreatedEncryptionKeyEvent: MoveStruct<{
    /** ID of the newly created encryption key */
    encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Address of the encryption key owner */
    signer_address: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::CreatedEncryptionKeyEvent">;
export declare const EncryptedShareVerificationRequestEvent: MoveStruct<{
    /** User's encrypted secret key share with zero-knowledge proof of correctness */
    encrypted_centralized_secret_share_and_proof: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /**
     * Public output of the dWallet (used for verification), this is the public output
     * of the dWallet that the user's share is being encrypted to. This value is taken
     * from the the dWallet object during event creation, and we cannot get it from the
     * user's side.
     */
    public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the dWallet this encrypted share belongs to */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Serialized encryption key used for the re-encryption */
    encryption_key: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the encryption key object */
    encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the new encrypted user secret key share being created */
    encrypted_user_secret_key_share_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the source encrypted share (if this is a re-encryption) */
    source_encrypted_user_secret_key_share_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the network encryption key securing network shares */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Elliptic curve for the dWallet */
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
}, "@local-pkg/2pc-mpc::coordinator_inner::EncryptedShareVerificationRequestEvent">;
export declare const CompletedEncryptedShareVerificationEvent: MoveStruct<{
    /** ID of the successfully verified encrypted user secret key share */
    encrypted_user_secret_key_share_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the dWallet associated with this encrypted share */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::CompletedEncryptedShareVerificationEvent">;
export declare const RejectedEncryptedShareVerificationEvent: MoveStruct<{
    /** ID of the encrypted user secret key share that failed verification */
    encrypted_user_secret_key_share_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the dWallet associated with the failed share */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::RejectedEncryptedShareVerificationEvent">;
export declare const AcceptEncryptedUserShareEvent: MoveStruct<{
    /** ID of the accepted encrypted user secret key share */
    encrypted_user_secret_key_share_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the dWallet associated with this share */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** User's signature on the public output proving acceptance */
    user_output_signature: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the encryption key used for this share */
    encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Address of the user who accepted the share */
    encryption_key_address: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::AcceptEncryptedUserShareEvent">;
export declare const MakeDWalletUserSecretKeySharePublicRequestEvent: MoveStruct<{
    /** The user's secret key share to be made public */
    public_user_secret_key_share: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** dWallet's public output for verification */
    public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Elliptic curve for the dWallet */
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** ID of the dWallet being transitioned to trust-minimized mode */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the network encryption key */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::MakeDWalletUserSecretKeySharePublicRequestEvent">;
export declare const CompletedMakeDWalletUserSecretKeySharePublicEvent: MoveStruct<{
    /** ID of the dWallet that successfully transitioned to trust-minimized mode */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** The user's secret key share that was made public */
    public_user_secret_key_share: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
}, "@local-pkg/2pc-mpc::coordinator_inner::CompletedMakeDWalletUserSecretKeySharePublicEvent">;
export declare const RejectedMakeDWalletUserSecretKeySharePublicEvent: MoveStruct<{
    /** ID of the dWallet that failed to transition to trust-minimized mode */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::RejectedMakeDWalletUserSecretKeySharePublicEvent">;
export declare const PresignRequestEvent: MoveStruct<{
    /**
       * Target dWallet ID for dWallet-specific presigns
       *
       * - `Some(id)`: dWallet-specific presign (required for ECDSA)
       * - `None`: Global presign (available for Schnorr, EdDSA)
       */
    dwallet_id: import("@mysten/bcs").BcsType<string | null, string | Uint8Array<ArrayBufferLike> | null | undefined, "Option<bytes[32]>">;
    /** Unique identifier for this presign session */
    presign_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** dWallet's public output for verification (None for global presigns) */
    dwallet_public_output: import("@mysten/bcs").BcsType<number[] | null, (Iterable<number> & {
        length: number;
    }) | null | undefined, "Option<vector<u8>>">;
    /** ID of the network encryption key securing the presign */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Elliptic curve for the presign computation */
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Signature algorithm for the presign (determines presign type) */
    signature_algorithm: import("@mysten/bcs").BcsType<number, number, "u32">;
}, "@local-pkg/2pc-mpc::coordinator_inner::PresignRequestEvent">;
export declare const CompletedPresignEvent: MoveStruct<{
    /** Target dWallet ID (None for global presigns) */
    dwallet_id: import("@mysten/bcs").BcsType<string | null, string | Uint8Array<ArrayBufferLike> | null | undefined, "Option<bytes[32]>">;
    /** Unique identifier for the completed presign */
    presign_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Precomputed cryptographic material for signature acceleration */
    presign: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
}, "@local-pkg/2pc-mpc::coordinator_inner::CompletedPresignEvent">;
export declare const RejectedPresignEvent: MoveStruct<{
    /** Target dWallet ID (None for global presigns) */
    dwallet_id: import("@mysten/bcs").BcsType<string | null, string | Uint8Array<ArrayBufferLike> | null | undefined, "Option<bytes[32]>">;
    /** ID of the presign that failed generation */
    presign_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::RejectedPresignEvent">;
export declare const SignRequestEvent: MoveStruct<{
    /** Unique identifier for this signing session */
    sign_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the dWallet performing the signature */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** dWallet's public output for signature verification */
    dwallet_public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Elliptic curve for the signature */
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Cryptographic signature algorithm */
    signature_algorithm: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Hash scheme applied to the message */
    hash_scheme: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Raw message bytes to be signed */
    message: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the network encryption key securing network shares */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the presign used for acceleration */
    presign_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Precomputed cryptographic material for fast signing */
    presign: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** User's partial signature on the message */
    message_centralized_signature: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Whether this uses future sign capabilities */
    is_future_sign: import("@mysten/bcs").BcsType<boolean, boolean, "bool">;
}, "@local-pkg/2pc-mpc::coordinator_inner::SignRequestEvent">;
export declare const CompletedSignEvent: MoveStruct<{
    /** Unique identifier for the completed signing session */
    sign_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Complete cryptographic signature ready for use */
    signature: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Whether this signature used future sign capabilities */
    is_future_sign: import("@mysten/bcs").BcsType<boolean, boolean, "bool">;
}, "@local-pkg/2pc-mpc::coordinator_inner::CompletedSignEvent">;
export declare const RejectedSignEvent: MoveStruct<{
    /** ID of the signing session that failed */
    sign_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Whether this rejection involved future sign capabilities */
    is_future_sign: import("@mysten/bcs").BcsType<boolean, boolean, "bool">;
}, "@local-pkg/2pc-mpc::coordinator_inner::RejectedSignEvent">;
export declare const FutureSignRequestEvent: MoveStruct<{
    /** ID of the dWallet that will complete the future signature */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the partial user signature being validated */
    partial_centralized_signed_message_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** Message that will be signed when conditions are met */
    message: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Precomputed cryptographic material for the future signature */
    presign: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** dWallet's public output for verification */
    dwallet_public_output: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** Elliptic curve for the signature */
    curve: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Signature algorithm for the future signature */
    signature_algorithm: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** Hash scheme to be applied to the message */
    hash_scheme: import("@mysten/bcs").BcsType<number, number, "u32">;
    /** User's partial signature proving authorization */
    message_centralized_signature: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    /** ID of the network encryption key */
    dwallet_network_encryption_key_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::FutureSignRequestEvent">;
export declare const CompletedFutureSignEvent: MoveStruct<{
    /** ID of the dWallet associated with the future signature */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the validated partial user signature */
    partial_centralized_signed_message_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::CompletedFutureSignEvent">;
export declare const RejectedFutureSignEvent: MoveStruct<{
    /** ID of the dWallet associated with the failed request */
    dwallet_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    /** ID of the partial user signature that failed validation */
    partial_centralized_signed_message_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/2pc-mpc::coordinator_inner::RejectedFutureSignEvent">;
export declare const DWalletCheckpointInfoEvent: MoveStruct<{
    epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    sequence_number: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
}, "@local-pkg/2pc-mpc::coordinator_inner::DWalletCheckpointInfoEvent">;
export declare const SetMaxActiveSessionsBufferEvent: MoveStruct<{
    max_active_sessions_buffer: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
}, "@local-pkg/2pc-mpc::coordinator_inner::SetMaxActiveSessionsBufferEvent">;
export declare const SetGasFeeReimbursementSuiSystemCallValueEvent: MoveStruct<{
    gas_fee_reimbursement_sui_system_call_value: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
}, "@local-pkg/2pc-mpc::coordinator_inner::SetGasFeeReimbursementSuiSystemCallValueEvent">;
export declare const EndOfEpochEvent: MoveStruct<{
    epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
}, "@local-pkg/2pc-mpc::coordinator_inner::EndOfEpochEvent">;
export interface RequestDwalletDkgImplArguments {
    self: RawTransactionArgument<string>;
    dwalletNetworkEncryptionKeyId: RawTransactionArgument<string>;
    curve: RawTransactionArgument<number>;
    centralizedPublicKeyShareAndProof: RawTransactionArgument<number[]>;
    userPublicOutput: RawTransactionArgument<number[]>;
    userSecretKeyShare: RawTransactionArgument<string>;
    signDuringDkgRequest: RawTransactionArgument<string | null>;
    sessionIdentifier: RawTransactionArgument<string>;
    paymentIka: RawTransactionArgument<string>;
    paymentSui: RawTransactionArgument<string>;
}
export interface RequestDwalletDkgImplOptions {
    package?: string;
    arguments: RequestDwalletDkgImplArguments | [
        self: RawTransactionArgument<string>,
        dwalletNetworkEncryptionKeyId: RawTransactionArgument<string>,
        curve: RawTransactionArgument<number>,
        centralizedPublicKeyShareAndProof: RawTransactionArgument<number[]>,
        userPublicOutput: RawTransactionArgument<number[]>,
        userSecretKeyShare: RawTransactionArgument<string>,
        signDuringDkgRequest: RawTransactionArgument<string | null>,
        sessionIdentifier: RawTransactionArgument<string>,
        paymentIka: RawTransactionArgument<string>,
        paymentSui: RawTransactionArgument<string>
    ];
}
export declare function requestDwalletDkgImpl(options: RequestDwalletDkgImplOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface DwalletIdArguments {
    self: RawTransactionArgument<string>;
}
export interface DwalletIdOptions {
    package?: string;
    arguments: DwalletIdArguments | [
        self: RawTransactionArgument<string>
    ];
}
/**
 * === Public Functions === Returns the ID of the dWallet.
 *
 * ### Parameters
 *
 * - `self`: Reference to the dWallet Cap
 *
 * ### Returns
 *
 * The ID of the dWallet
 */
export declare function dwalletId(options: DwalletIdOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ImportedKeyDwalletIdArguments {
    self: RawTransactionArgument<string>;
}
export interface ImportedKeyDwalletIdOptions {
    package?: string;
    arguments: ImportedKeyDwalletIdArguments | [
        self: RawTransactionArgument<string>
    ];
}
/**
 * Returns the ID of the imported key dWallet.
 *
 * ### Parameters
 *
 * - `self`: Reference to the imported key dWallet Cap
 *
 * ### Returns
 *
 * The ID of the imported key dWallet
 */
export declare function importedKeyDwalletId(options: ImportedKeyDwalletIdOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface IsImportedKeyDwalletArguments {
    self: RawTransactionArgument<string>;
}
export interface IsImportedKeyDwalletOptions {
    package?: string;
    arguments: IsImportedKeyDwalletArguments | [
        self: RawTransactionArgument<string>
    ];
}
/**
 * Returns true if the dWallet is an imported key dWallet.
 *
 * ### Parameters
 *
 * - `self`: Reference to the dWallet
 *
 * ### Returns
 *
 * True if the dWallet is an imported key dWallet, false otherwise
 */
export declare function isImportedKeyDwallet(options: IsImportedKeyDwalletOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface IsDwalletActiveArguments {
    self: RawTransactionArgument<string>;
}
export interface IsDwalletActiveOptions {
    package?: string;
    arguments: IsDwalletActiveArguments | [
        self: RawTransactionArgument<string>
    ];
}
/**
 * Returns true if the dWallet is active.
 *
 * ### Parameters
 *
 * - `self`: Reference to the dWallet
 *
 * ### Returns
 *
 * True if the dWallet is active, false otherwise
 */
export declare function isDwalletActive(options: IsDwalletActiveOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface DwalletNetworkEncryptionKeyIdArguments {
    self: RawTransactionArgument<string>;
}
export interface DwalletNetworkEncryptionKeyIdOptions {
    package?: string;
    arguments: DwalletNetworkEncryptionKeyIdArguments | [
        self: RawTransactionArgument<string>
    ];
}
/**
 * Returns the network encryption key ID of the dWallet.
 *
 * ### Parameters
 *
 * - `self`: Reference to the dWallet
 *
 * ### Returns
 *
 * The network encryption key ID of the dWallet
 */
export declare function dwalletNetworkEncryptionKeyId(options: DwalletNetworkEncryptionKeyIdOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CurveArguments {
    self: RawTransactionArgument<string>;
}
export interface CurveOptions {
    package?: string;
    arguments: CurveArguments | [
        self: RawTransactionArgument<string>
    ];
}
/**
 * Returns the curve of the dWallet.
 *
 * ### Parameters
 *
 * - `self`: Reference to the dWallet
 *
 * ### Returns
 *
 * The curve of the dWallet
 */
export declare function curve(options: CurveOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ValidateActiveAndGetPublicOutputArguments {
    self: RawTransactionArgument<string>;
}
export interface ValidateActiveAndGetPublicOutputOptions {
    package?: string;
    arguments: ValidateActiveAndGetPublicOutputArguments | [
        self: RawTransactionArgument<string>
    ];
}
/**
 * Validates that a dWallet is in active state and returns its public output.
 *
 * This function ensures that a dWallet has completed its creation process (either
 * DKG or imported key verification) and is ready for cryptographic operations like
 * signing.
 *
 * ### Parameters
 *
 * - `self`: Reference to the dWallet to validate
 *
 * ### Returns
 *
 * Reference to the dWallet's public output
 *
 * ### Aborts
 *
 * - `EDWalletInactive`: If the dWallet is not in the `Active` state
 *
 * ### Active State Requirements
 *
 * A dWallet is considered active when:
 *
 * - DKG process has completed successfully, OR
 * - Imported key verification has completed successfully
 * - User has accepted their encrypted key share
 * - Public output is available for cryptographic operations
 */
export declare function validateActiveAndGetPublicOutput(options: ValidateActiveAndGetPublicOutputOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface HasSignSessionArguments {
    self: RawTransactionArgument<string>;
    signId: RawTransactionArgument<string>;
}
export interface HasSignSessionOptions {
    package?: string;
    arguments: HasSignSessionArguments | [
        self: RawTransactionArgument<string>,
        signId: RawTransactionArgument<string>
    ];
}
/**
 * Returns true if the `SignSession` object exists for the given `sign_id`.
 *
 * ### Parameters
 *
 * - `self`: Reference to the dWallet
 * - `sign_id`: ID of the sign session
 *
 * ### Returns
 *
 * True if the `SignSession` object exists, false otherwise
 */
export declare function hasSignSession(options: HasSignSessionOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetSignSessionArguments {
    self: RawTransactionArgument<string>;
    signId: RawTransactionArgument<string>;
}
export interface GetSignSessionOptions {
    package?: string;
    arguments: GetSignSessionArguments | [
        self: RawTransactionArgument<string>,
        signId: RawTransactionArgument<string>
    ];
}
/**
 * Returns a reference to the `SignSession` object for the given `sign_id`.
 *
 * ### Parameters
 *
 * - `self`: Reference to the dWallet
 * - `sign_id`: ID of the sign session
 *
 * ### Returns
 *
 * Reference to the `SignSession` object
 */
export declare function getSignSession(options: GetSignSessionOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetSignSignatureArguments {
    self: RawTransactionArgument<string>;
}
export interface GetSignSignatureOptions {
    package?: string;
    arguments: GetSignSignatureArguments | [
        self: RawTransactionArgument<string>
    ];
}
/**
 * Returns the signature of the `SignSession` object for the given `sign_id`.
 *
 * ### Parameters
 *
 * - `self`: Reference to the sign session
 *
 * ### Returns
 *
 * Option of the signature of the `SignSession` object
 */
export declare function getSignSignature(options: GetSignSignatureOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
