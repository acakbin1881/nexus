/**************************************************************
 * THIS FILE IS GENERATED AND SHOULD NOT BE MANUALLY MODIFIED *
 **************************************************************/
import { MoveStruct, type RawTransactionArgument } from '../utils/index.js';
import { type Transaction } from '@mysten/sui/transactions';
export declare const ValidatorSet: MoveStruct<{
    /** Total amount of stake from all active validators at the beginning of the epoch. */
    total_stake: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    /** How many reward are slashed to punish a validator, in bps. */
    reward_slashing_rate: import("@mysten/bcs").BcsType<number, number, "u16">;
    /** A table that contains all validators */
    validators: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "0x2::object_table::ObjectTable">;
    /** The current list of active committee of validators. */
    active_committee: MoveStruct<{
        members: import("@mysten/bcs").BcsType<{
            validator_id: string;
            protocol_pubkey: {
                bytes: number[];
            };
        }[], Iterable<{
            validator_id: string | Uint8Array<ArrayBufferLike>;
            protocol_pubkey: {
                bytes: Iterable<number> & {
                    length: number;
                };
            };
        }> & {
            length: number;
        }, string>;
        aggregated_protocol_pubkey: MoveStruct<{
            bytes: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
                length: number;
            }, string>;
        }, "0x2::group_ops::Element">;
        quorum_threshold: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
        validity_threshold: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "ika_common::bls_committee::BlsCommittee">;
    /**
     * The next list of active committee of validators. It will become the
     * active_committee at the end of the epoch.
     */
    next_epoch_active_committee: import("@mysten/bcs").BcsType<{
        members: {
            validator_id: string;
            protocol_pubkey: {
                bytes: number[];
            };
        }[];
        aggregated_protocol_pubkey: {
            bytes: number[];
        };
        quorum_threshold: string;
        validity_threshold: string;
    } | null, {
        members: Iterable<{
            validator_id: string | Uint8Array<ArrayBufferLike>;
            protocol_pubkey: {
                bytes: Iterable<number> & {
                    length: number;
                };
            };
        }> & {
            length: number;
        };
        aggregated_protocol_pubkey: {
            bytes: Iterable<number> & {
                length: number;
            };
        };
        quorum_threshold: string | number | bigint;
        validity_threshold: string | number | bigint;
    } | null | undefined, "Option<ika_common::bls_committee::BlsCommittee>">;
    /** The current list of previous committee of validators. */
    previous_committee: MoveStruct<{
        members: import("@mysten/bcs").BcsType<{
            validator_id: string;
            protocol_pubkey: {
                bytes: number[];
            };
        }[], Iterable<{
            validator_id: string | Uint8Array<ArrayBufferLike>;
            protocol_pubkey: {
                bytes: Iterable<number> & {
                    length: number;
                };
            };
        }> & {
            length: number;
        }, string>;
        aggregated_protocol_pubkey: MoveStruct<{
            bytes: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
                length: number;
            }, string>;
        }, "0x2::group_ops::Element">;
        quorum_threshold: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
        validity_threshold: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "ika_common::bls_committee::BlsCommittee">;
    /**
     * The next list of pending active set of validators to be
     * next_epoch_active_committee. It will start from the last
     * next_epoch_active_committee and will be process between middle of the epochs and
     * will be finalize at the middle of the epoch.
     */
    pending_active_set: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
    }, "ika_common::extended_field::ExtendedField">;
    /**
     * A map storing the records of validator reporting each other. There is an entry
     * in the map for each validator that has been reported at least once. The entry
     * VecSet contains all the validators that reported them. If a validator has never
     * been reported they don't have an entry in this map. This map persists across
     * epoch: a peer continues being in a reported state until the reporter doesn't
     * explicitly remove their report. Note that in case we want to support validator
     * address change in future, the reports should be based on validator ids
     */
    validator_report_records: MoveStruct<{
        contents: import("@mysten/bcs").BcsType<{
            key: string;
            value: {
                contents: string[];
            };
        }[], Iterable<{
            key: string | Uint8Array<ArrayBufferLike>;
            value: {
                contents: Iterable<string | Uint8Array<ArrayBufferLike>> & {
                    length: number;
                };
            };
        }> & {
            length: number;
        }, string>;
    }, "0x2::vec_map::VecMap<bytes[32], 0x2::vec_set::VecSet<bytes[32]>>">;
    /** Any extra fields that's not defined statically. */
    extra_fields: MoveStruct<{
        id: MoveStruct<{
            id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
        }, "0x2::object::UID">;
        size: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, "0x2::bag::Bag">;
}, "@local-pkg/system::validator_set::ValidatorSet">;
export declare const ValidatorEpochInfoEventV1: MoveStruct<{
    epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    validator_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    stake: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    commission_rate: import("@mysten/bcs").BcsType<number, number, "u16">;
    staking_rewards: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    token_exchange_rate: import("../utils/index.js").MoveEnum<{
        Flat: null;
        Variable: MoveStruct<{
            ika_amount: import("@mysten/bcs").BcsType<string, string | number | bigint, "u128">;
            share_amount: import("@mysten/bcs").BcsType<string, string | number | bigint, "u128">;
        }, "TokenExchangeRate.Variable">;
    }, "@local-pkg/system::token_exchange_rate::TokenExchangeRate">;
    tallying_rule_reporters: import("@mysten/bcs").BcsType<string[], Iterable<string | Uint8Array<ArrayBufferLike>> & {
        length: number;
    }, string>;
    tallying_rule_global_score: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
}, "@local-pkg/system::validator_set::ValidatorEpochInfoEventV1">;
export declare const ValidatorJoinEvent: MoveStruct<{
    epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    validator_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
}, "@local-pkg/system::validator_set::ValidatorJoinEvent">;
export declare const ValidatorLeaveEvent: MoveStruct<{
    withdrawing_epoch: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    validator_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    is_voluntary: import("@mysten/bcs").BcsType<boolean, boolean, "bool">;
}, "@local-pkg/system::validator_set::ValidatorLeaveEvent">;
export interface TotalStakeArguments {
    self: RawTransactionArgument<string>;
}
export interface TotalStakeOptions {
    package?: string;
    arguments: TotalStakeArguments | [
        self: RawTransactionArgument<string>
    ];
}
export declare function totalStake(options: TotalStakeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ValidatorTotalStakeAmountArguments {
    self: RawTransactionArgument<string>;
    validatorId: RawTransactionArgument<string>;
}
export interface ValidatorTotalStakeAmountOptions {
    package?: string;
    arguments: ValidatorTotalStakeAmountArguments | [
        self: RawTransactionArgument<string>,
        validatorId: RawTransactionArgument<string>
    ];
}
export declare function validatorTotalStakeAmount(options: ValidatorTotalStakeAmountOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface GetValidatorArguments {
    self: RawTransactionArgument<string>;
    validatorId: RawTransactionArgument<string>;
}
export interface GetValidatorOptions {
    package?: string;
    arguments: GetValidatorArguments | [
        self: RawTransactionArgument<string>,
        validatorId: RawTransactionArgument<string>
    ];
}
/** Get reference to a validator by id. */
export declare function getValidator(options: GetValidatorOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ActiveCommitteeArguments {
    self: RawTransactionArgument<string>;
}
export interface ActiveCommitteeOptions {
    package?: string;
    arguments: ActiveCommitteeArguments | [
        self: RawTransactionArgument<string>
    ];
}
/** Return the active validators in `self` */
export declare function activeCommittee(options: ActiveCommitteeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface NextEpochActiveCommitteeArguments {
    self: RawTransactionArgument<string>;
}
export interface NextEpochActiveCommitteeOptions {
    package?: string;
    arguments: NextEpochActiveCommitteeArguments | [
        self: RawTransactionArgument<string>
    ];
}
/** Return the next epoch active committee in `self` */
export declare function nextEpochActiveCommittee(options: NextEpochActiveCommitteeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface PendingActiveSetArguments {
    self: RawTransactionArgument<string>;
}
export interface PendingActiveSetOptions {
    package?: string;
    arguments: PendingActiveSetArguments | [
        self: RawTransactionArgument<string>
    ];
}
/** Return the pending active set in `self` */
export declare function pendingActiveSet(options: PendingActiveSetOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface IsValidatorCandidateArguments {
    self: RawTransactionArgument<string>;
    validatorId: RawTransactionArgument<string>;
}
export interface IsValidatorCandidateOptions {
    package?: string;
    arguments: IsValidatorCandidateArguments | [
        self: RawTransactionArgument<string>,
        validatorId: RawTransactionArgument<string>
    ];
}
/** Returns true if the `validator_id` is a validator candidate. */
export declare function isValidatorCandidate(options: IsValidatorCandidateOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface IsInactiveValidatorArguments {
    self: RawTransactionArgument<string>;
    validatorId: RawTransactionArgument<string>;
}
export interface IsInactiveValidatorOptions {
    package?: string;
    arguments: IsInactiveValidatorArguments | [
        self: RawTransactionArgument<string>,
        validatorId: RawTransactionArgument<string>
    ];
}
/**
 * Returns true if the validator identified by `validator_id` is of an inactive
 * validator.
 */
export declare function isInactiveValidator(options: IsInactiveValidatorOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
