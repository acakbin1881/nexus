import type { ValidSignatureAlgorithmForCurve } from './hash-signature-validation.js';
import type { CoordinatorInner, Curve, DWallet, DWalletCap, DWalletState, DWalletWithState, EncryptedUserSecretKeyShare, EncryptedUserSecretKeyShareState, EncryptedUserSecretKeyShareWithState, EncryptionKey, EncryptionKeyOptions, IkaClientOptions, IkaConfig, NetworkEncryptionKey, PartialUserSignature, PartialUserSignatureState, PartialUserSignatureWithState, Presign, PresignState, PresignWithState, Sign, SignatureAlgorithm, SignState, SignWithState, SystemInner } from './types.js';
/**
 * IkaClient provides a high-level interface for interacting with the Ika network.
 * It handles network configuration, object fetching, caching, and provides methods
 * for retrieving DWallets, presigns, and other network objects.
 */
export declare class IkaClient {
    #private;
    /** The Ika network configuration including package IDs and object references */
    ikaConfig: IkaConfig;
    /** Default encryption key options for the client */
    encryptionKeyOptions: EncryptionKeyOptions;
    /** The underlying Sui client for blockchain interactions */
    private client;
    /** Whether to enable caching of network objects and parameters */
    private cache;
    /** Cached network public parameters by encryption key ID and curve to avoid repeated fetching */
    private cachedProtocolPublicParameters;
    /** Cached network objects (coordinator and system inner objects) - separate from encryption keys */
    private cachedObjects?;
    /** Cached encryption keys by ID for efficient access */
    private cachedEncryptionKeys;
    /** Promise for ongoing object fetching to prevent duplicate requests */
    private objectsPromise?;
    /** Promise for ongoing encryption key fetching to prevent duplicate requests */
    private encryptionKeysPromise?;
    /**
     * Creates a new IkaClient instance
     *
     * @param options - Configuration options for the client
     * @param options.suiClient - The Sui client instance to use for blockchain interactions
     * @param options.config - The Ika network configuration
     * @param options.cache - Whether to enable caching (default: true)
     */
    constructor({ suiClient, config, cache, encryptionKeyOptions }: IkaClientOptions);
    /**
     * Invalidate all cached data including objects and public parameters.
     * This forces the client to refetch data on the next request.
     */
    invalidateCache(): void;
    /**
     * Invalidate only the cached objects (coordinator and system inner objects).
     * Public parameters and encryption key caches are preserved.
     */
    invalidateObjectCache(): void;
    /**
     * Invalidate only the cached encryption keys.
     * Network objects and public parameters caches are preserved.
     */
    invalidateEncryptionKeyCache(): void;
    /**
     * Invalidate cached protocol public parameters for a specific encryption key and/or curve.
     * If no parameters are provided, clears all cached protocol parameters.
     * If only encryptionKeyID is provided, clears all curves for that key.
     * If both are provided, clears only that specific combination.
     *
     * @param encryptionKeyID - Optional specific encryption key ID to invalidate
     * @param curve - Optional specific curve to invalidate
     */
    invalidateProtocolPublicParametersCache(encryptionKeyID?: string, curve?: Curve): void;
    /**
     * Initialize the client by fetching and caching network objects.
     * This method should be called before using other client methods.
     *
     * @returns Promise that resolves when initialization is complete
     */
    initialize(): Promise<void>;
    /**
     * Ensure the client is initialized with core network objects.
     * This method handles caching and prevents duplicate initialization requests.
     *
     * @returns Promise resolving to the core network objects
     * @throws {NetworkError} If initialization fails
     * @private
     */
    ensureInitialized(): Promise<{
        coordinatorInner: CoordinatorInner;
        systemInner: SystemInner;
    }>;
    /**
     * Get all available network encryption keys.
     * This method fetches and caches all encryption keys for efficient access.
     *
     * @returns Promise resolving to an array of all network encryption keys
     * @throws {NetworkError} If the encryption keys cannot be fetched
     */
    getAllNetworkEncryptionKeys(): Promise<NetworkEncryptionKey[]>;
    /**
     * Get the latest network encryption key.
     * This is the most recent encryption key created for the network.
     *
     * @returns Promise resolving to the latest network encryption key
     * @throws {NetworkError} If the encryption keys cannot be fetched
     */
    getLatestNetworkEncryptionKey(): Promise<NetworkEncryptionKey>;
    /**
     * Get a specific network encryption key by ID.
     *
     * @param encryptionKeyID - The ID of the encryption key to retrieve
     * @returns Promise resolving to the specified network encryption key
     * @throws {ObjectNotFoundError} If the encryption key is not found
     * @throws {NetworkError} If the encryption keys cannot be fetched
     */
    getNetworkEncryptionKey(encryptionKeyID: string): Promise<NetworkEncryptionKey>;
    /**
     * Get the network encryption key used by a specific dWallet.
     * This method automatically detects which encryption key the dWallet uses.
     *
     * @param dwalletID - The ID of the dWallet to check
     * @returns Promise resolving to the network encryption key used by the dWallet
     * @throws {InvalidObjectError} If the dWallet cannot be parsed
     * @throws {NetworkError} If the network request fails
     */
    getDWalletNetworkEncryptionKey(dwalletID: string): Promise<NetworkEncryptionKey>;
    /**
     * Get the network encryption key based on client configuration.
     * This method respects the client's encryption key options.
     *
     * @returns Promise resolving to the appropriate network encryption key
     * @throws {NetworkError} If the encryption keys cannot be fetched
     */
    getConfiguredNetworkEncryptionKey(): Promise<NetworkEncryptionKey>;
    /**
     * Retrieve a DWallet object by its ID.
     *
     * @param dwalletID - The unique identifier of the DWallet to retrieve
     * @returns Promise resolving to the DWallet object
     * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
     * @throws {NetworkError} If the network request fails
     */
    getDWallet(dwalletID: string): Promise<DWallet>;
    /**
     * Retrieve a DWallet in a particular state, waiting until it reaches that state.
     * This method polls the DWallet until it matches the specified state.
     *
     * @param dwalletID - The unique identifier of the DWallet to retrieve
     * @param state - The target state to wait for
     * @param options - Optional configuration for polling behavior
     * @param options.timeout - Maximum time to wait in milliseconds (default: 30000)
     * @param options.interval - Initial polling interval in milliseconds (default: 1000)
     * @param options.maxInterval - Maximum polling interval with exponential backoff (default: 5000)
     * @param options.backoffMultiplier - Multiplier for exponential backoff (default: 1.5)
     * @param options.signal - AbortSignal to cancel the polling
     * @returns Promise resolving to the DWallet object when it reaches the target state
     * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
     * @throws {NetworkError} If the network request fails
     * @throws {Error} If timeout is reached before the target state is achieved or operation is aborted
     */
    getDWalletInParticularState<S extends DWalletState>(dwalletID: string, state: S, options?: {
        timeout?: number;
        interval?: number;
        maxInterval?: number;
        backoffMultiplier?: number;
        signal?: AbortSignal;
    }): Promise<DWalletWithState<S>>;
    /**
     * Retrieve a presign session object by its ID.
     *
     * @param presignID - The unique identifier of the presign session to retrieve
     * @returns Promise resolving to the Presign object
     * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
     * @throws {NetworkError} If the network request fails
     */
    getPresign(presignID: string): Promise<Presign>;
    /**
     * Retrieve a presign session object in a particular state, waiting until it reaches that state.
     * This method polls the presign until it matches the specified state.
     *
     * @param presignID - The unique identifier of the presign session to retrieve
     * @param state - The target state to wait for
     * @param options - Optional configuration for polling behavior
     * @param options.timeout - Maximum time to wait in milliseconds (default: 30000)
     * @param options.interval - Initial polling interval in milliseconds (default: 1000)
     * @param options.maxInterval - Maximum polling interval with exponential backoff (default: 5000)
     * @param options.backoffMultiplier - Multiplier for exponential backoff (default: 1.5)
     * @param options.signal - AbortSignal to cancel the polling
     * @returns Promise resolving to the Presign object when it reaches the target state
     * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
     * @throws {NetworkError} If the network request fails
     * @throws {Error} If timeout is reached before the target state is achieved or operation is aborted
     */
    getPresignInParticularState<S extends PresignState>(presignID: string, state: S, options?: {
        timeout?: number;
        interval?: number;
        maxInterval?: number;
        backoffMultiplier?: number;
        signal?: AbortSignal;
    }): Promise<PresignWithState<S>>;
    /**
     * Retrieve an encrypted user secret key share object by its ID.
     *
     * @param encryptedUserSecretKeyShareID - The unique identifier of the encrypted share to retrieve
     * @returns Promise resolving to the EncryptedUserSecretKeyShare object
     * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
     * @throws {NetworkError} If the network request fails
     */
    getEncryptedUserSecretKeyShare(encryptedUserSecretKeyShareID: string): Promise<EncryptedUserSecretKeyShare>;
    /**
     * Retrieve an encrypted user secret key share object by its ID.
     *
     * @param encryptedUserSecretKeyShareID - The unique identifier of the encrypted share to retrieve
     * @param state - The target state to wait for
     * @param options - Optional configuration for polling behavior
     * @param options.timeout - Maximum time to wait in milliseconds (default: 30000)
     * @param options.interval - Initial polling interval in milliseconds (default: 1000)
     * @param options.maxInterval - Maximum polling interval with exponential backoff (default: 5000)
     * @param options.backoffMultiplier - Multiplier for exponential backoff (default: 1.5)
     * @param options.signal - AbortSignal to cancel the polling
     * @returns Promise resolving to the EncryptedUserSecretKeyShare object
     * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
     * @throws {NetworkError} If the network request fails
     * @throws {Error} If timeout is reached before the target state is achieved or operation is aborted
     */
    getEncryptedUserSecretKeyShareInParticularState<S extends EncryptedUserSecretKeyShareState>(encryptedUserSecretKeyShareID: string, state: S, options?: {
        timeout?: number;
        interval?: number;
        maxInterval?: number;
        backoffMultiplier?: number;
        signal?: AbortSignal;
    }): Promise<EncryptedUserSecretKeyShareWithState<S>>;
    /**
     * Retrieve a partial user signature object by its ID.
     *
     * @param partialCentralizedSignedMessageID - The unique identifier of the partial signature to retrieve
     * @returns Promise resolving to the PartialUserSignature object
     * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
     * @throws {NetworkError} If the network request fails
     */
    getPartialUserSignature(partialCentralizedSignedMessageID: string): Promise<PartialUserSignature>;
    getPartialUserSignatureInParticularState<S extends PartialUserSignatureState>(partialCentralizedSignedMessageID: string, state: S, options?: {
        timeout?: number;
        interval?: number;
        maxInterval?: number;
        backoffMultiplier?: number;
        signal?: AbortSignal;
    }): Promise<PartialUserSignatureWithState<S>>;
    /**
     * Retrieve a sign session object by its ID.
     *
     * @param signID - The unique identifier of the sign session to retrieve
     * @param curve - The curve to use for parsing
     * @param signatureAlgorithm - The signature algorithm to use for parsing (must be valid for the curve)
     *
     * @returns Promise resolving to the Sign object
     * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
     * @throws {NetworkError} If the network request fails
     */
    getSign<C extends Curve>(signID: string, curve: C, signatureAlgorithm: ValidSignatureAlgorithmForCurve<C>): Promise<Sign>;
    /**
     * Retrieve a sign session object in a particular state, waiting until it reaches that state.
     * This method polls the sign until it matches the specified state.
     *
     * @param signID - The unique identifier of the sign session to retrieve
     * @param curve - The curve to use for parsing
     * @param signatureAlgorithm - The signature algorithm to use for parsing (must be valid for the curve)
     * @param state - The target state to wait for
     * @param options - Optional configuration for polling behavior
     * @param options.timeout - Maximum time to wait in milliseconds (default: 30000)
     * @param options.interval - Initial polling interval in milliseconds (default: 1000)
     * @param options.maxInterval - Maximum polling interval with exponential backoff (default: 5000)
     * @param options.backoffMultiplier - Multiplier for exponential backoff (default: 1.5)
     * @param options.signal - AbortSignal to cancel the polling
     * @returns Promise resolving to the Sign object when it reaches the target state
     * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
     * @throws {NetworkError} If the network request fails
     * @throws {Error} If timeout is reached before the target state is achieved or operation is aborted
     */
    getSignInParticularState<S extends SignState>(signID: string, curve: Curve, signatureAlgorithm: SignatureAlgorithm, state: S, options?: {
        timeout?: number;
        interval?: number;
        maxInterval?: number;
        backoffMultiplier?: number;
        signal?: AbortSignal;
    }): Promise<SignWithState<S>>;
    /**
     * Retrieve multiple DWallet objects by their IDs in a single batch request.
     * This is more efficient than making individual requests for multiple DWallets.
     *
     * @param dwalletIDs - Array of unique identifiers for the DWallets to retrieve
     * @returns Promise resolving to an array of DWallet objects
     * @throws {InvalidObjectError} If any object cannot be parsed or is invalid
     * @throws {NetworkError} If the network request fails
     */
    getMultipleDWallets(dwalletIDs: string[]): Promise<DWallet[]>;
    /**
     * Retrieve DWallet capabilities owned by a specific address.
     * DWallet capabilities grant the holder permission to use the associated DWallet.
     *
     * @param address - The Sui address to query for owned DWallet capabilities
     * @param cursor - Optional cursor for pagination (from previous request)
     * @param limit - Optional limit on the number of results to return
     * @returns Promise resolving to paginated results containing DWallet capabilities
     * @throws {InvalidObjectError} If any object cannot be parsed or is invalid
     * @throws {NetworkError} If the network request fails
     */
    getOwnedDWalletCaps(address: string, cursor?: string, limit?: number): Promise<{
        dWalletCaps: DWalletCap[];
        cursor: string | null | undefined;
        hasNextPage: boolean;
    }>;
    /**
     * Get cached protocol public parameters for a specific encryption key and curve.
     * Returns undefined if not cached or if the cache is invalid.
     *
     * @param encryptionKeyID - The ID of the encryption key to get cached parameters for
     * @param curve - The curve to get cached parameters for
     * @returns Cached protocol public parameters or undefined if not cached
     */
    getCachedProtocolPublicParameters(encryptionKeyID: string, curve: Curve): Uint8Array | undefined;
    /**
     * Check if protocol public parameters are cached for a specific encryption key and curve.
     *
     * @param encryptionKeyID - The ID of the encryption key to check
     * @param curve - The curve to check
     * @returns True if valid cached parameters exist, false otherwise
     */
    isProtocolPublicParametersCached(encryptionKeyID: string, curve: Curve): boolean;
    /**
     * Get the current encryption key options for the client.
     *
     * @returns The current encryption key options
     */
    getEncryptionKeyOptions(): EncryptionKeyOptions;
    /**
     * Set the encryption key options for the client.
     * This affects all subsequent calls to methods that use encryption keys.
     *
     * @param options - The new encryption key options
     */
    setEncryptionKeyOptions(options: EncryptionKeyOptions): void;
    /**
     * Set a specific encryption key ID to use for all operations.
     * This is a convenience method for setting just the encryption key ID.
     *
     * @param encryptionKeyID - The encryption key ID to use
     */
    setEncryptionKeyID(encryptionKeyID: string): void;
    /**
     * Retrieve the protocol public parameters used for cryptographic operations.
     * These parameters are cached by encryption key ID and only refetched when the epoch or decryption key changes.
     *
     * @param dWallet - The DWallet to get the protocol public parameters for
     * @param curve - The curve to use for key generation
     * @returns Promise resolving to the protocol public parameters as bytes
     * @throws {ObjectNotFoundError} If the public parameters cannot be found
     * @throws {NetworkError} If the network request fails
     */
    getProtocolPublicParameters(dWallet?: DWallet, curve?: Curve): Promise<Uint8Array>;
    /**
     * Get the active encryption key for a specific address.
     * This key is used for encrypting user shares and other cryptographic operations.
     *
     * @param address - The Sui address to get the encryption key for
     * @returns Promise resolving to the EncryptionKey object
     * @throws {InvalidObjectError} If the encryption key object cannot be parsed
     * @throws {NetworkError} If the network request fails
     */
    getActiveEncryptionKey(address: string): Promise<EncryptionKey>;
    /**
     * Get the current network epoch number.
     * The epoch is used for versioning and determining when to refresh cached parameters.
     *
     * @returns Promise resolving to the current epoch number
     * @throws {NetworkError} If the network objects cannot be fetched
     */
    getEpoch(): Promise<number>;
    /**
     * Read a table vector as raw bytes from the blockchain.
     * This method handles paginated dynamic field retrieval and assembles the data in order.
     *
     * @param tableID - The ID of the table object to read
     * @returns Promise resolving to the concatenated raw bytes from the table
     * @throws {ObjectNotFoundError} If the table or its dynamic fields are not found
     * @throws {InvalidObjectError} If table indices are invalid
     * @throws {NetworkError} If network requests fail
     * @private
     */
    readTableVecAsRawBytes(tableID: string): Promise<Uint8Array>;
}
