import { MoveStruct, normalizeMoveArguments } from "../utils/index.js";
import { bcs } from "@mysten/sui/bcs";
import * as group_ops from "./deps/sui/group_ops.js";
import * as table_vec from "./deps/sui/table_vec.js";
import * as extended_field from "./deps/ika_common/extended_field.js";
const $moduleName = "@local-pkg/system::validator_info";
const ValidatorInfo = new MoveStruct({ name: `${$moduleName}::ValidatorInfo`, fields: {
  /** Human-readable name of the validator */
  name: bcs.string(),
  /** Unique identifier for this validator */
  validator_id: bcs.Address,
  /**
   * The network address of the validator (could also contain extra info such as
   * port, DNS and etc.)
   */
  network_address: bcs.string(),
  /**
   * The address of the validator used for p2p activities such as state sync (could
   * also contain extra info such as port, DNS and etc.)
   */
  p2p_address: bcs.string(),
  /** The address of the consensus */
  consensus_address: bcs.string(),
  /**
   * Current epoch public keys The public key bytes corresponding to the private key
   * that the validator holds to sign checkpoint messages
   */
  protocol_pubkey_bytes: bcs.vector(bcs.u8()),
  /** The protocol public key element for cryptographic operations */
  protocol_pubkey: group_ops.Element,
  /**
   * The public key bytes corresponding to the private key that the validator uses to
   * establish TLS connections
   */
  network_pubkey_bytes: bcs.vector(bcs.u8()),
  /** The public key bytes corresponding to the consensus */
  consensus_pubkey_bytes: bcs.vector(bcs.u8()),
  /**
   * The validator's MPC public data. This key is used for the network DKG process
   * and for resharing the network MPC key Must always contain value
   */
  mpc_data_bytes: bcs.option(table_vec.TableVec),
  /**
   * Next epoch configurations - only take effect in the next epoch If none, current
   * value will stay unchanged.
   */
  next_epoch_protocol_pubkey_bytes: bcs.option(bcs.vector(bcs.u8())),
  next_epoch_network_pubkey_bytes: bcs.option(bcs.vector(bcs.u8())),
  next_epoch_consensus_pubkey_bytes: bcs.option(bcs.vector(bcs.u8())),
  next_epoch_mpc_data_bytes: bcs.option(table_vec.TableVec),
  next_epoch_network_address: bcs.option(bcs.string()),
  next_epoch_p2p_address: bcs.option(bcs.string()),
  next_epoch_consensus_address: bcs.option(bcs.string()),
  previous_mpc_data_bytes: bcs.option(table_vec.TableVec),
  /** Extended metadata field for additional validator information */
  metadata: extended_field.ExtendedField
} });
function validatorId(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "validator_id",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function networkAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "network_address",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function p2pAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "p2p_address",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function consensusAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "consensus_address",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function protocolPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "protocol_pubkey_bytes",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function protocolPubkey(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "protocol_pubkey",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function networkPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "network_pubkey_bytes",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function consensusPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "consensus_pubkey_bytes",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function mpcDataBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "mpc_data_bytes",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochNetworkAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_network_address",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochP2pAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_p2p_address",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochConsensusAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_consensus_address",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochProtocolPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_protocol_pubkey_bytes",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochNetworkPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_network_pubkey_bytes",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochConsensusPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_consensus_pubkey_bytes",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochMpcDataBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_mpc_data_bytes",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function previousMpcDataBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "previous_mpc_data_bytes",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
export {
  ValidatorInfo,
  consensusAddress,
  consensusPubkeyBytes,
  mpcDataBytes,
  networkAddress,
  networkPubkeyBytes,
  nextEpochConsensusAddress,
  nextEpochConsensusPubkeyBytes,
  nextEpochMpcDataBytes,
  nextEpochNetworkAddress,
  nextEpochNetworkPubkeyBytes,
  nextEpochP2pAddress,
  nextEpochProtocolPubkeyBytes,
  p2pAddress,
  previousMpcDataBytes,
  protocolPubkey,
  protocolPubkeyBytes,
  validatorId
};
//# sourceMappingURL=validator_info.js.map
