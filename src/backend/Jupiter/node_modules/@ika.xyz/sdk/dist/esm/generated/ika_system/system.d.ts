/**************************************************************
 * THIS FILE IS GENERATED AND SHOULD NOT BE MANUALLY MODIFIED *
 **************************************************************/
/**
 * # Ika System Module
 *
 * The `ika_system::system` module provides the core system state management for
 * the Ika network. It acts as the central coordinator for validators, staking,
 * epochs, and network governance.
 *
 * ## Overview
 *
 * The module implements a versioned wrapper pattern around the core system state:
 *
 * - `System`: A shared object that serves as the public interface and version
 *   manager
 * - `SystemInner`: The actual system state implementation containing all business
 *   logic
 * - `ProtocolCap`: Capability object for privileged system operations
 *
 * ## Architecture
 *
 * The system uses a two-layer architecture:
 *
 * ### System Wrapper Layer
 *
 * The `System` struct is a thin wrapper that:
 *
 * - Maintains version information for upgrades
 * - Stores the package ID for authorization
 * - Holds the inner system state as a dynamic field
 * - Provides a stable public interface across versions
 *
 * ### SystemInner Layer
 *
 * The `SystemInner` struct contains all the core functionality:
 *
 * - Validator set management and operations
 * - Epoch progression and timing
 * - Staking and delegation logic
 * - Protocol treasury and rewards distribution
 * - dWallet network coordination
 * - System parameter management
 *
 * ## Key Responsibilities
 *
 * ### Validator Management
 *
 * - Adding/removing validator candidates
 * - Managing validator metadata and configuration
 * - Handling validator state transitions (PreActive → Active → Withdrawing)
 * - Processing validator reports and governance actions
 *
 * ### Staking Operations
 *
 * - Processing stake additions and withdrawals
 * - Managing staked IKA tokens and rewards
 * - Calculating token exchange rates across epochs
 * - Handling delegation to validators
 *
 * ### Epoch Management
 *
 * - Coordinating epoch transitions
 * - Processing mid-epoch reconfigurations
 * - Managing epoch timing and duration
 * - Distributing stake subsidies and rewards
 *
 * ### dWallet Integration
 *
 * - Coordinating with dWallet 2PC MPC system
 * - Managing encryption keys and DKG processes
 * - Handling pricing and curve configurations
 * - Processing dWallet network operations
 *
 * ### System Governance
 *
 * - Managing protocol upgrades via UpgradeCap
 * - Processing system parameter changes
 * - Handling protocol version transitions
 * - Coordinating checkpoint message processing
 *
 * ## State Management
 *
 * The system maintains state across multiple components:
 *
 * - **ValidatorSet**: Current and pending validator configurations
 * - **ProtocolTreasury**: Rewards, subsidies, and fee management
 * - **BLS Committee**: Cryptographic committee for consensus
 * - **Token Exchange Rates**: Historical staking reward calculations
 * - **Pending Values**: Future epoch configuration changes
 *
 * ## Ika System Upgrade Guide
 *
 * `System` is a versioned wrapper around `SystemInner` that provides upgrade
 * capabilities. The `SystemInner` object is stored as a dynamic field with the
 * version as the key. There are multiple approaches to upgrade the system state:
 *
 * The simplest approach is to add dynamic fields to the `extra_fields` field of
 * `SystemInner` or any of its subtypes. This is useful for rapid changes, small
 * modifications, or experimental features.
 *
 * To perform a proper type upgrade of `SystemInner`, follow these steps:
 *
 * 1.  Define a new `SystemInnerV2` type in system_inner.move.
 * 2.  Create a data migration function that transforms `SystemInner` to
 *     `SystemInnerV2`.
 * 3.  Update the `VERSION` constant to 2 and replace all references to
 *     `SystemInner` with `SystemInnerV2` in both system.move and
 *     system_inner.move.
 * 4.  Modify the `migrate` function to handle the version upgrade by:
 *     - Removing the old inner object from the dynamic field
 *     - Applying the data migration transformation
 *     - Adding the new inner object with the updated version
 * 5.  Update the `inner()` and `inner_mut()` functions to work with the new
 *     version.
 *
 * Along with the Move changes, update the Rust code:
 *
 * 1.  Define a new `SystemInnerV2` struct that matches the Move type.
 * 2.  Update the `System` enum to include the new version variant.
 * 3.  Update relevant system state getter functions to handle the new version.
 *
 * To upgrade Validator types:
 *
 * 1.  Define a new Validator version (e.g. ValidatorV2) in validator.move.
 * 2.  Create migration functions to convert between validator versions.
 * 3.  Update validator creation and access functions to use the new version.
 * 4.  Update the validator set and related components to handle the new validator
 *     type.
 *
 * In Rust, add new cases to handle the upgraded validator types in the appropriate
 * getter functions. Validator upgrades can be done independently of SystemInner
 * upgrades, but ensure version consistency across related components.
 */
import { MoveStruct, type RawTransactionArgument } from '../utils/index.js';
import { type Transaction } from '@mysten/sui/transactions';
export declare const System: MoveStruct<{
    id: MoveStruct<{
        id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    }, "0x2::object::UID">;
    version: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    package_id: import("@mysten/bcs").BcsType<string, string | Uint8Array<ArrayBufferLike>, "bytes[32]">;
    new_package_id: import("@mysten/bcs").BcsType<string | null, string | Uint8Array<ArrayBufferLike> | null | undefined, "Option<bytes[32]>">;
    migration_epoch: import("@mysten/bcs").BcsType<string | null, string | number | bigint | null | undefined, "Option<u64>">;
}, "@local-pkg/system::system::System">;
export interface InitializeArguments {
    self: RawTransactionArgument<string>;
    maxValidatorChangeCount: RawTransactionArgument<number | bigint>;
    cap: RawTransactionArgument<string>;
}
export interface InitializeOptions {
    package?: string;
    arguments: InitializeArguments | [
        self: RawTransactionArgument<string>,
        maxValidatorChangeCount: RawTransactionArgument<number | bigint>,
        cap: RawTransactionArgument<string>
    ];
}
export declare function initialize(options: InitializeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RequestAddValidatorCandidateArguments {
    self: RawTransactionArgument<string>;
    name: RawTransactionArgument<string>;
    protocolPubkeyBytes: RawTransactionArgument<number[]>;
    networkPubkeyBytes: RawTransactionArgument<number[]>;
    consensusPubkeyBytes: RawTransactionArgument<number[]>;
    mpcDataBytes: RawTransactionArgument<string>;
    proofOfPossessionBytes: RawTransactionArgument<number[]>;
    networkAddress: RawTransactionArgument<string>;
    p2pAddress: RawTransactionArgument<string>;
    consensusAddress: RawTransactionArgument<string>;
    commissionRate: RawTransactionArgument<number>;
    metadata: RawTransactionArgument<string>;
}
export interface RequestAddValidatorCandidateOptions {
    package?: string;
    arguments: RequestAddValidatorCandidateArguments | [
        self: RawTransactionArgument<string>,
        name: RawTransactionArgument<string>,
        protocolPubkeyBytes: RawTransactionArgument<number[]>,
        networkPubkeyBytes: RawTransactionArgument<number[]>,
        consensusPubkeyBytes: RawTransactionArgument<number[]>,
        mpcDataBytes: RawTransactionArgument<string>,
        proofOfPossessionBytes: RawTransactionArgument<number[]>,
        networkAddress: RawTransactionArgument<string>,
        p2pAddress: RawTransactionArgument<string>,
        consensusAddress: RawTransactionArgument<string>,
        commissionRate: RawTransactionArgument<number>,
        metadata: RawTransactionArgument<string>
    ];
}
/**
 * Can be called by anyone who wishes to become a validator candidate and starts
 * accruing delegated stakes in their staking pool. Once they have at least
 * `MIN_VALIDATOR_JOINING_STAKE` amount of stake they can call
 * `request_add_validator` to officially become an active validator at the next
 * epoch. Aborts if the caller is already a pending or active validator, or a
 * validator candidate. Note: `proof_of_possession_bytes` MUST be a valid signature
 * using sui_address and protocol_pubkey_bytes. To produce a valid PoP, run [fn
 * test_proof_of_possession_bytes].
 */
export declare function requestAddValidatorCandidate(options: RequestAddValidatorCandidateOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RequestRemoveValidatorCandidateArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface RequestRemoveValidatorCandidateOptions {
    package?: string;
    arguments: RequestRemoveValidatorCandidateArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * Called by a validator candidate to remove themselves from the candidacy. After
 * this call their staking pool becomes deactivate.
 */
export declare function requestRemoveValidatorCandidate(options: RequestRemoveValidatorCandidateOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RequestAddValidatorArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface RequestAddValidatorOptions {
    package?: string;
    arguments: RequestAddValidatorArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * Called by a validator candidate to add themselves to the active validator set
 * beginning next epoch. Aborts if the validator is a duplicate with one of the
 * pending or active validators, or if the amount of stake the validator has
 * doesn't meet the min threshold, or if the number of new validators for the next
 * epoch has already reached the maximum.
 */
export declare function requestAddValidator(options: RequestAddValidatorOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RequestRemoveValidatorArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface RequestRemoveValidatorOptions {
    package?: string;
    arguments: RequestRemoveValidatorArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * A validator can call this function to request a removal in the next epoch. We
 * use the sender of `ctx` to look up the validator (i.e. sender must match the
 * sui_address in the validator). At the end of the epoch, the `validator` object
 * will be returned to the sui_address of the validator.
 */
export declare function requestRemoveValidator(options: RequestRemoveValidatorOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNextCommissionArguments {
    self: RawTransactionArgument<string>;
    newCommissionRate: RawTransactionArgument<number>;
    cap: RawTransactionArgument<string>;
}
export interface SetNextCommissionOptions {
    package?: string;
    arguments: SetNextCommissionArguments | [
        self: RawTransactionArgument<string>,
        newCommissionRate: RawTransactionArgument<number>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * A validator can call this function to set a new commission rate, updated at the
 * end of the epoch.
 */
export declare function setNextCommission(options: SetNextCommissionOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RequestAddStakeArguments {
    self: RawTransactionArgument<string>;
    stake: RawTransactionArgument<string>;
    validatorId: RawTransactionArgument<string>;
}
export interface RequestAddStakeOptions {
    package?: string;
    arguments: RequestAddStakeArguments | [
        self: RawTransactionArgument<string>,
        stake: RawTransactionArgument<string>,
        validatorId: RawTransactionArgument<string>
    ];
}
/** Add stake to a validator's staking pool. */
export declare function requestAddStake(options: RequestAddStakeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RequestWithdrawStakeArguments {
    self: RawTransactionArgument<string>;
    stakedIka: RawTransactionArgument<string>;
}
export interface RequestWithdrawStakeOptions {
    package?: string;
    arguments: RequestWithdrawStakeArguments | [
        self: RawTransactionArgument<string>,
        stakedIka: RawTransactionArgument<string>
    ];
}
/**
 * Marks the amount as a withdrawal to be processed and removes it from the stake
 * weight of the node. Allows the user to call withdraw_stake after the epoch
 * change to the next epoch and shard transfer is done.
 */
export declare function requestWithdrawStake(options: RequestWithdrawStakeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface WithdrawStakeArguments {
    self: RawTransactionArgument<string>;
    stakedIka: RawTransactionArgument<string>;
}
export interface WithdrawStakeOptions {
    package?: string;
    arguments: WithdrawStakeArguments | [
        self: RawTransactionArgument<string>,
        stakedIka: RawTransactionArgument<string>
    ];
}
/** Withdraws the staked amount from the staking pool. */
export declare function withdrawStake(options: WithdrawStakeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ReportValidatorArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    reporteeId: RawTransactionArgument<string>;
}
export interface ReportValidatorOptions {
    package?: string;
    arguments: ReportValidatorArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        reporteeId: RawTransactionArgument<string>
    ];
}
/**
 * Report a validator as a bad or non-performant actor in the system. Succeeds if
 * all the following are satisfied:
 *
 * 1.  both the reporter in `cap` and the input `reportee_id` are active
 *     validators.
 * 2.  reporter and reportee not the same address.
 * 3.  the cap object is still valid. This function is idempotent.
 */
export declare function reportValidator(options: ReportValidatorOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface UndoReportValidatorArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    reporteeId: RawTransactionArgument<string>;
}
export interface UndoReportValidatorOptions {
    package?: string;
    arguments: UndoReportValidatorArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        reporteeId: RawTransactionArgument<string>
    ];
}
/**
 * Undo a `report_validator` action. Aborts if
 *
 * 1.  the reportee is not a currently active validator or
 * 2.  the sender has not previously reported the `reportee_id`, or
 * 3.  the cap is not valid
 */
export declare function undoReportValidator(options: UndoReportValidatorOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RotateOperationCapArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface RotateOperationCapOptions {
    package?: string;
    arguments: RotateOperationCapArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * Create a new `ValidatorOperationCap` and registers it. The original object is
 * thus revoked.
 */
export declare function rotateOperationCap(options: RotateOperationCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface RotateCommissionCapArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface RotateCommissionCapOptions {
    package?: string;
    arguments: RotateCommissionCapArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * Create a new `ValidatorCommissionCap` and registers it. The original object is
 * thus revoked.
 */
export declare function rotateCommissionCap(options: RotateCommissionCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CollectCommissionArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
    amount: RawTransactionArgument<number | bigint | null>;
}
export interface CollectCommissionOptions {
    package?: string;
    arguments: CollectCommissionArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>,
        amount: RawTransactionArgument<number | bigint | null>
    ];
}
/**
 * Withdraws the commission from the validator. Amount is optional, if not
 * provided, the full commission is withdrawn.
 */
export declare function collectCommission(options: CollectCommissionOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetValidatorNameArguments {
    self: RawTransactionArgument<string>;
    name: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface SetValidatorNameOptions {
    package?: string;
    arguments: SetValidatorNameArguments | [
        self: RawTransactionArgument<string>,
        name: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
/** Set a validator's name. */
export declare function setValidatorName(options: SetValidatorNameOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ValidatorMetadataArguments {
    self: RawTransactionArgument<string>;
    validatorId: RawTransactionArgument<string>;
}
export interface ValidatorMetadataOptions {
    package?: string;
    arguments: ValidatorMetadataArguments | [
        self: RawTransactionArgument<string>,
        validatorId: RawTransactionArgument<string>
    ];
}
/** Get a validator's metadata. */
export declare function validatorMetadata(options: ValidatorMetadataOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetValidatorMetadataArguments {
    self: RawTransactionArgument<string>;
    metadata: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface SetValidatorMetadataOptions {
    package?: string;
    arguments: SetValidatorMetadataArguments | [
        self: RawTransactionArgument<string>,
        metadata: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
export declare function setValidatorMetadata(options: SetValidatorMetadataOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNextEpochNetworkAddressArguments {
    self: RawTransactionArgument<string>;
    networkAddress: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface SetNextEpochNetworkAddressOptions {
    package?: string;
    arguments: SetNextEpochNetworkAddressArguments | [
        self: RawTransactionArgument<string>,
        networkAddress: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * Sets a validator's network address. The change will only take effects starting
 * from the next epoch.
 */
export declare function setNextEpochNetworkAddress(options: SetNextEpochNetworkAddressOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNextEpochP2pAddressArguments {
    self: RawTransactionArgument<string>;
    p2pAddress: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface SetNextEpochP2pAddressOptions {
    package?: string;
    arguments: SetNextEpochP2pAddressArguments | [
        self: RawTransactionArgument<string>,
        p2pAddress: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * Sets a validator's p2p address. The change will only take effects starting from
 * the next epoch.
 */
export declare function setNextEpochP2pAddress(options: SetNextEpochP2pAddressOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNextEpochConsensusAddressArguments {
    self: RawTransactionArgument<string>;
    consensusAddress: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface SetNextEpochConsensusAddressOptions {
    package?: string;
    arguments: SetNextEpochConsensusAddressArguments | [
        self: RawTransactionArgument<string>,
        consensusAddress: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * Sets a validator's consensus address. The change will only take effects starting
 * from the next epoch.
 */
export declare function setNextEpochConsensusAddress(options: SetNextEpochConsensusAddressOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNextEpochProtocolPubkeyBytesArguments {
    self: RawTransactionArgument<string>;
    protocolPubkey: RawTransactionArgument<number[]>;
    proofOfPossessionBytes: RawTransactionArgument<number[]>;
    cap: RawTransactionArgument<string>;
}
export interface SetNextEpochProtocolPubkeyBytesOptions {
    package?: string;
    arguments: SetNextEpochProtocolPubkeyBytesArguments | [
        self: RawTransactionArgument<string>,
        protocolPubkey: RawTransactionArgument<number[]>,
        proofOfPossessionBytes: RawTransactionArgument<number[]>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * Sets a validator's public key of protocol key and proof of possession. The
 * change will only take effects starting from the next epoch.
 */
export declare function setNextEpochProtocolPubkeyBytes(options: SetNextEpochProtocolPubkeyBytesOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNextEpochNetworkPubkeyBytesArguments {
    self: RawTransactionArgument<string>;
    networkPubkey: RawTransactionArgument<number[]>;
    cap: RawTransactionArgument<string>;
}
export interface SetNextEpochNetworkPubkeyBytesOptions {
    package?: string;
    arguments: SetNextEpochNetworkPubkeyBytesArguments | [
        self: RawTransactionArgument<string>,
        networkPubkey: RawTransactionArgument<number[]>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * Sets a validator's public key of network key. The change will only take effects
 * starting from the next epoch.
 */
export declare function setNextEpochNetworkPubkeyBytes(options: SetNextEpochNetworkPubkeyBytesOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNextEpochConsensusPubkeyBytesArguments {
    self: RawTransactionArgument<string>;
    consensusPubkeyBytes: RawTransactionArgument<number[]>;
    cap: RawTransactionArgument<string>;
}
export interface SetNextEpochConsensusPubkeyBytesOptions {
    package?: string;
    arguments: SetNextEpochConsensusPubkeyBytesArguments | [
        self: RawTransactionArgument<string>,
        consensusPubkeyBytes: RawTransactionArgument<number[]>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * Sets a validator's public key of worker key. The change will only take effects
 * starting from the next epoch.
 */
export declare function setNextEpochConsensusPubkeyBytes(options: SetNextEpochConsensusPubkeyBytesOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetNextEpochMpcDataBytesArguments {
    self: RawTransactionArgument<string>;
    mpcData: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface SetNextEpochMpcDataBytesOptions {
    package?: string;
    arguments: SetNextEpochMpcDataBytesArguments | [
        self: RawTransactionArgument<string>,
        mpcData: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * Sets a validator's MPC public data. The change will only take effects starting
 * from the next epoch.
 */
export declare function setNextEpochMpcDataBytes(options: SetNextEpochMpcDataBytesOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface TokenExchangeRatesArguments {
    self: RawTransactionArgument<string>;
    validatorId: RawTransactionArgument<string>;
}
export interface TokenExchangeRatesOptions {
    package?: string;
    arguments: TokenExchangeRatesArguments | [
        self: RawTransactionArgument<string>,
        validatorId: RawTransactionArgument<string>
    ];
}
/**
 * Get the pool token exchange rate of a validator. Works for both active and
 * inactive pools.
 */
export declare function tokenExchangeRates(options: TokenExchangeRatesOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ActiveCommitteeArguments {
    self: RawTransactionArgument<string>;
}
export interface ActiveCommitteeOptions {
    package?: string;
    arguments: ActiveCommitteeArguments | [
        self: RawTransactionArgument<string>
    ];
}
/** Get the active committee of the current epoch. */
export declare function activeCommittee(options: ActiveCommitteeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface NextEpochActiveCommitteeArguments {
    self: RawTransactionArgument<string>;
}
export interface NextEpochActiveCommitteeOptions {
    package?: string;
    arguments: NextEpochActiveCommitteeArguments | [
        self: RawTransactionArgument<string>
    ];
}
/** Get the active committee of the next epoch. */
export declare function nextEpochActiveCommittee(options: NextEpochActiveCommitteeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface InitiateMidEpochReconfigurationArguments {
    self: RawTransactionArgument<string>;
}
export interface InitiateMidEpochReconfigurationOptions {
    package?: string;
    arguments: InitiateMidEpochReconfigurationArguments | [
        self: RawTransactionArgument<string>
    ];
}
/**
 * Locks the committee of the next epoch to allow starting the reconfiguration
 * process.
 */
export declare function initiateMidEpochReconfiguration(options: InitiateMidEpochReconfigurationOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CreateSystemCurrentStatusInfoArguments {
    self: RawTransactionArgument<string>;
}
export interface CreateSystemCurrentStatusInfoOptions {
    package?: string;
    arguments: CreateSystemCurrentStatusInfoArguments | [
        self: RawTransactionArgument<string>
    ];
}
/** Create the system current status info. */
export declare function createSystemCurrentStatusInfo(options: CreateSystemCurrentStatusInfoOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface InitiateAdvanceEpochArguments {
    self: RawTransactionArgument<string>;
}
export interface InitiateAdvanceEpochOptions {
    package?: string;
    arguments: InitiateAdvanceEpochArguments | [
        self: RawTransactionArgument<string>
    ];
}
/** Initiates the advance epoch process. */
export declare function initiateAdvanceEpoch(options: InitiateAdvanceEpochOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AdvanceEpochArguments {
    self: RawTransactionArgument<string>;
    advanceEpochApprover: RawTransactionArgument<string>;
}
export interface AdvanceEpochOptions {
    package?: string;
    arguments: AdvanceEpochArguments | [
        self: RawTransactionArgument<string>,
        advanceEpochApprover: RawTransactionArgument<string>
    ];
}
/**
 * Advances the epoch to the next epoch. Can only be called after all the witnesses
 * have approved the advance epoch.
 */
export declare function advanceEpoch(options: AdvanceEpochOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface VerifyValidatorCapArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface VerifyValidatorCapOptions {
    package?: string;
    arguments: VerifyValidatorCapArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
export declare function verifyValidatorCap(options: VerifyValidatorCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface VerifyOperationCapArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface VerifyOperationCapOptions {
    package?: string;
    arguments: VerifyOperationCapArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
export declare function verifyOperationCap(options: VerifyOperationCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface VerifyCommissionCapArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface VerifyCommissionCapOptions {
    package?: string;
    arguments: VerifyCommissionCapArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
export declare function verifyCommissionCap(options: VerifyCommissionCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AuthorizeUpgradeArguments {
    self: RawTransactionArgument<string>;
    packageId: RawTransactionArgument<string>;
}
export interface AuthorizeUpgradeOptions {
    package?: string;
    arguments: AuthorizeUpgradeArguments | [
        self: RawTransactionArgument<string>,
        packageId: RawTransactionArgument<string>
    ];
}
export declare function authorizeUpgrade(options: AuthorizeUpgradeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CommitUpgradeArguments {
    self: RawTransactionArgument<string>;
    receipt: RawTransactionArgument<string>;
    upgradePackageApprover: RawTransactionArgument<string>;
}
export interface CommitUpgradeOptions {
    package?: string;
    arguments: CommitUpgradeArguments | [
        self: RawTransactionArgument<string>,
        receipt: RawTransactionArgument<string>,
        upgradePackageApprover: RawTransactionArgument<string>
    ];
}
export declare function commitUpgrade(options: CommitUpgradeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface FinalizeUpgradeArguments {
    self: RawTransactionArgument<string>;
    upgradePackageApprover: RawTransactionArgument<string>;
}
export interface FinalizeUpgradeOptions {
    package?: string;
    arguments: FinalizeUpgradeArguments | [
        self: RawTransactionArgument<string>,
        upgradePackageApprover: RawTransactionArgument<string>
    ];
}
export declare function finalizeUpgrade(options: FinalizeUpgradeOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ProcessCheckpointMessageByQuorumArguments {
    self: RawTransactionArgument<string>;
    signature: RawTransactionArgument<number[]>;
    signersBitmap: RawTransactionArgument<number[]>;
    message: RawTransactionArgument<number[]>;
}
export interface ProcessCheckpointMessageByQuorumOptions {
    package?: string;
    arguments: ProcessCheckpointMessageByQuorumArguments | [
        self: RawTransactionArgument<string>,
        signature: RawTransactionArgument<number[]>,
        signersBitmap: RawTransactionArgument<number[]>,
        message: RawTransactionArgument<number[]>
    ];
}
export declare function processCheckpointMessageByQuorum(options: ProcessCheckpointMessageByQuorumOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface AddUpgradeCapByCapArguments {
    self: RawTransactionArgument<string>;
    upgradeCap: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface AddUpgradeCapByCapOptions {
    package?: string;
    arguments: AddUpgradeCapByCapArguments | [
        self: RawTransactionArgument<string>,
        upgradeCap: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
export declare function addUpgradeCapByCap(options: AddUpgradeCapByCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface VerifyProtocolCapArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface VerifyProtocolCapOptions {
    package?: string;
    arguments: VerifyProtocolCapArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
export declare function verifyProtocolCap(options: VerifyProtocolCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ProcessCheckpointMessageByCapArguments {
    self: RawTransactionArgument<string>;
    message: RawTransactionArgument<number[]>;
    cap: RawTransactionArgument<string>;
}
export interface ProcessCheckpointMessageByCapOptions {
    package?: string;
    arguments: ProcessCheckpointMessageByCapArguments | [
        self: RawTransactionArgument<string>,
        message: RawTransactionArgument<number[]>,
        cap: RawTransactionArgument<string>
    ];
}
export declare function processCheckpointMessageByCap(options: ProcessCheckpointMessageByCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetApprovedUpgradeByCapArguments {
    self: RawTransactionArgument<string>;
    packageId: RawTransactionArgument<string>;
    digest: RawTransactionArgument<number[] | null>;
    cap: RawTransactionArgument<string>;
}
export interface SetApprovedUpgradeByCapOptions {
    package?: string;
    arguments: SetApprovedUpgradeByCapArguments | [
        self: RawTransactionArgument<string>,
        packageId: RawTransactionArgument<string>,
        digest: RawTransactionArgument<number[] | null>,
        cap: RawTransactionArgument<string>
    ];
}
export declare function setApprovedUpgradeByCap(options: SetApprovedUpgradeByCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface SetOrRemoveWitnessApprovingAdvanceEpochByCapArguments {
    self: RawTransactionArgument<string>;
    witnessType: RawTransactionArgument<string>;
    remove: RawTransactionArgument<boolean>;
    cap: RawTransactionArgument<string>;
}
export interface SetOrRemoveWitnessApprovingAdvanceEpochByCapOptions {
    package?: string;
    arguments: SetOrRemoveWitnessApprovingAdvanceEpochByCapArguments | [
        self: RawTransactionArgument<string>,
        witnessType: RawTransactionArgument<string>,
        remove: RawTransactionArgument<boolean>,
        cap: RawTransactionArgument<string>
    ];
}
export declare function setOrRemoveWitnessApprovingAdvanceEpochByCap(options: SetOrRemoveWitnessApprovingAdvanceEpochByCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface TryMigrateByCapArguments {
    self: RawTransactionArgument<string>;
    cap: RawTransactionArgument<string>;
}
export interface TryMigrateByCapOptions {
    package?: string;
    arguments: TryMigrateByCapArguments | [
        self: RawTransactionArgument<string>,
        cap: RawTransactionArgument<string>
    ];
}
/**
 * Try to migrate the system object to the new package id using a cap.
 *
 * This function sets the new package id and version and can be modified in future
 * versions to migrate changes in the `system_inner` object if needed. This
 * function can be called immediately after the upgrade is committed.
 */
export declare function tryMigrateByCap(options: TryMigrateByCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface TryMigrateArguments {
    self: RawTransactionArgument<string>;
}
export interface TryMigrateOptions {
    package?: string;
    arguments: TryMigrateArguments | [
        self: RawTransactionArgument<string>
    ];
}
/**
 * Try to migrate the system object to the new package id.
 *
 * This function sets the new package id and version and can be modified in future
 * versions to migrate changes in the `system_inner` object if needed. Call this
 * function after the migration epoch is reached.
 */
export declare function tryMigrate(options: TryMigrateOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface VersionArguments {
    self: RawTransactionArgument<string>;
}
export interface VersionOptions {
    package?: string;
    arguments: VersionArguments | [
        self: RawTransactionArgument<string>
    ];
}
export declare function version(options: VersionOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CalculateRewardsArguments {
    self: RawTransactionArgument<string>;
    validatorId: RawTransactionArgument<string>;
    stakedPrincipal: RawTransactionArgument<number | bigint>;
    activationEpoch: RawTransactionArgument<number | bigint>;
    withdrawEpoch: RawTransactionArgument<number | bigint>;
}
export interface CalculateRewardsOptions {
    package?: string;
    arguments: CalculateRewardsArguments | [
        self: RawTransactionArgument<string>,
        validatorId: RawTransactionArgument<string>,
        stakedPrincipal: RawTransactionArgument<number | bigint>,
        activationEpoch: RawTransactionArgument<number | bigint>,
        withdrawEpoch: RawTransactionArgument<number | bigint>
    ];
}
/**
 * Calculates the rewards for an amount with value `staked_principal`, staked in
 * the validator with the given `validator_id` between `activation_epoch` and
 * `withdraw_epoch`.
 *
 * This function can be used with `dev_inspect` to calculate the expected rewards
 * for a `StakedIka` object or, more generally, the returns provided by a given
 * validator over a given period.
 */
export declare function calculateRewards(options: CalculateRewardsOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface CanWithdrawStakedIkaEarlyArguments {
    self: RawTransactionArgument<string>;
    stakedIka: RawTransactionArgument<string>;
}
export interface CanWithdrawStakedIkaEarlyOptions {
    package?: string;
    arguments: CanWithdrawStakedIkaEarlyArguments | [
        self: RawTransactionArgument<string>,
        stakedIka: RawTransactionArgument<string>
    ];
}
/**
 * Call `staked_ika::can_withdraw_early` to allow calling this method in
 * applications.
 */
export declare function canWithdrawStakedIkaEarly(options: CanWithdrawStakedIkaEarlyOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface EpochArguments {
    self: RawTransactionArgument<string>;
}
export interface EpochOptions {
    package?: string;
    arguments: EpochArguments | [
        self: RawTransactionArgument<string>
    ];
}
/**
 * Return the current epoch number. Useful for applications that need a
 * coarse-grained concept of time, since epochs are ever-increasing and epoch
 * changes are intended to happen every 24 hours.
 */
export declare function epoch(options: EpochOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ValidatorStakeAmountArguments {
    self: RawTransactionArgument<string>;
    validatorId: RawTransactionArgument<string>;
}
export interface ValidatorStakeAmountOptions {
    package?: string;
    arguments: ValidatorStakeAmountArguments | [
        self: RawTransactionArgument<string>,
        validatorId: RawTransactionArgument<string>
    ];
}
/**
 * Returns the total amount staked with `validator_id`. Aborts if `validator_id` is
 * not an active validator.
 */
export declare function validatorStakeAmount(options: ValidatorStakeAmountOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
export interface ClaimMetadataCapArguments {
    self: RawTransactionArgument<string>;
    currency: RawTransactionArgument<string>;
}
export interface ClaimMetadataCapOptions {
    package?: string;
    arguments: ClaimMetadataCapArguments | [
        self: RawTransactionArgument<string>,
        currency: RawTransactionArgument<string>
    ];
}
export declare function claimMetadataCap(options: ClaimMetadataCapOptions): (tx: Transaction) => import("@mysten/sui/transactions").TransactionResult;
