import { Curve, Hash, SignatureAlgorithm } from './types.js';
/** Returns human-readable name for a hash algorithm */
export declare function getHashName(hash: Hash): string;
/** Returns human-readable name for a signature algorithm */
export declare function getSignatureAlgorithmName(signatureAlgorithm: SignatureAlgorithm): string;
/** Returns human-readable name for a curve */
export declare function getCurveName(curve: Curve): string;
/**
 * Validates hash and signature algorithm combination.
 * @throws {Error} with supported hashes if invalid
 */
export declare function validateHashSignatureCombination(hash: Hash, signatureAlgorithm: SignatureAlgorithm): void;
/**
 * Validates curve matches the signature algorithm.
 * @throws {Error} with expected curve if mismatch
 */
export declare function validateCurveSignatureAlgorithm(curve: Curve, signatureAlgorithm: SignatureAlgorithm): void;
/** Compile-time type for valid signature algorithms per curve */
export type ValidSignatureAlgorithmForCurve<C extends Curve> = C extends typeof Curve.SECP256K1 ? typeof SignatureAlgorithm.ECDSASecp256k1 | typeof SignatureAlgorithm.Taproot : C extends typeof Curve.SECP256R1 ? typeof SignatureAlgorithm.ECDSASecp256r1 : C extends typeof Curve.ED25519 ? typeof SignatureAlgorithm.EdDSA : C extends typeof Curve.RISTRETTO ? typeof SignatureAlgorithm.SchnorrkelSubstrate : never;
/** Compile-time type for valid hash/signature combinations */
export type ValidHashForSignature<S extends SignatureAlgorithm> = S extends typeof SignatureAlgorithm.ECDSASecp256k1 ? typeof Hash.KECCAK256 | typeof Hash.SHA256 | typeof Hash.DoubleSHA256 : S extends typeof SignatureAlgorithm.Taproot ? typeof Hash.SHA256 : S extends typeof SignatureAlgorithm.ECDSASecp256r1 ? typeof Hash.SHA256 : S extends typeof SignatureAlgorithm.EdDSA ? typeof Hash.SHA512 : S extends typeof SignatureAlgorithm.SchnorrkelSubstrate ? typeof Hash.Merlin : never;
/** Type guard: checks if hash is valid for signature algorithm */
export declare function isValidHashForSignature<S extends SignatureAlgorithm>(hash: Hash, signatureAlgorithm: S): hash is ValidHashForSignature<S>;
/** Compile-time validated signing parameters */
export type ValidatedSigningParams<S extends SignatureAlgorithm> = {
    hashScheme: ValidHashForSignature<S>;
    signatureAlgorithm: S;
};
/**
 * Creates validated signing params with compile-time checking.
 * @example
 * createValidatedSigningParams(Hash.SHA256, SignatureAlgorithm.ECDSASecp256k1); // OK
 * createValidatedSigningParams(Hash.SHA512, SignatureAlgorithm.ECDSASecp256k1); // Compile error
 */
export declare function createValidatedSigningParams<S extends SignatureAlgorithm>(hashScheme: ValidHashForSignature<S>, signatureAlgorithm: S): ValidatedSigningParams<S>;
/**
 * Returns array of valid hash names for signature algorithm.
 * @example getValidHashesForSignatureAlgorithm(SignatureAlgorithm.ECDSASecp256k1)
 * // => ['KECCAK256 (SHA3)', 'SHA256', 'DoubleSHA256']
 */
export declare function getValidHashesForSignatureAlgorithm(signatureAlgorithm: SignatureAlgorithm): string[];
/** Converts curve to its numeric representation */
export declare function fromCurveToNumber(curve: Curve): number;
/**
 * Converts signature algorithm to its numeric representation.
 * Number is relative to the curve (e.g., Secp256k1: ECDSA=0, Taproot=1).
 * @throws {Error} with valid algorithms if invalid combination
 */
export declare function fromSignatureAlgorithmToNumber(curve: Curve, signatureAlgorithm: SignatureAlgorithm): number;
/**
 * Converts hash to its numeric representation.
 * Number is relative to curve+signature (e.g., Secp256k1+ECDSA: KECCAK256=0, SHA256=1).
 * @throws {Error} with valid hashes if invalid combination
 */
export declare function fromHashToNumber(curve: Curve, signatureAlgorithm: SignatureAlgorithm, hash: Hash): number;
/** Converts curve and signature algorithm to their numeric representations */
export declare function fromCurveAndSignatureAlgorithmToNumbers(curve: Curve, signatureAlgorithm: SignatureAlgorithm): {
    curveNumber: number;
    signatureAlgorithmNumber: number;
};
/** Converts curve, signature algorithm, and hash to their numeric representations */
export declare function fromCurveAndSignatureAlgorithmAndHashToNumbers(curve: Curve, signatureAlgorithm: SignatureAlgorithm, hash: Hash): {
    curveNumber: number;
    signatureAlgorithmNumber: number;
    hashNumber: number;
};
/** Type guard: is signature algorithm valid for curve? */
export declare function isValidSignatureAlgorithmForCurve(curve: Curve, signatureAlgorithm: SignatureAlgorithm): boolean;
/** Type guard: is hash valid for curve+signature algorithm? */
export declare function isValidHashForCurveAndSignature(curve: Curve, signatureAlgorithm: SignatureAlgorithm, hash: Hash): boolean;
/** Returns all valid signature algorithms for a curve */
export declare function getValidSignatureAlgorithmsForCurve(curve: Curve): SignatureAlgorithm[];
/** Returns all valid hashes for a curve and signature algorithm */
export declare function getValidHashesForCurveAndSignature(curve: Curve, signatureAlgorithm: SignatureAlgorithm): Hash[];
/**
 * Converts curve number to its Curve enum (direct conversion).
 * @throws {Error} if curve number is unknown
 */
export declare function fromNumberToCurve(curveNumber: number): Curve;
/**
 * Converts absolute signature algorithm number to its SignatureAlgorithm enum (direct conversion).
 * Uses global numbering: ECDSASecp256k1=0, Taproot=1, ECDSASecp256r1=2, EdDSA=3, SchnorrkelSubstrate=4
 * @throws {Error} if number is unknown
 */
export declare function fromAbsoluteNumberToSignatureAlgorithm(absoluteNumber: number): SignatureAlgorithm;
/**
 * Converts SignatureAlgorithm enum to its absolute number (direct conversion).
 * Uses global numbering: ECDSASecp256k1=0, Taproot=1, ECDSASecp256r1=2, EdDSA=3, SchnorrkelSubstrate=4
 */
export declare function fromSignatureAlgorithmToAbsoluteNumber(signatureAlgorithm: SignatureAlgorithm): number;
/**
 * Converts absolute hash number to its Hash enum (direct conversion).
 * Uses global numbering: KECCAK256=0, SHA256=1, DoubleSHA256=2, SHA512=3, Merlin=4
 * @throws {Error} if number is unknown
 */
export declare function fromAbsoluteNumberToHash(absoluteNumber: number): Hash;
/**
 * Converts Hash enum to its absolute number (direct conversion).
 * Uses global numbering: KECCAK256=0, SHA256=1, DoubleSHA256=2, SHA512=3, Merlin=4
 */
export declare function fromHashToAbsoluteNumber(hash: Hash): number;
/**
 * Converts signature algorithm number to its SignatureAlgorithm enum.
 * Number is relative to the curve (e.g., Secp256k1: 0=ECDSA, 1=Taproot).
 * @throws {Error} if signature algorithm number is unknown for the curve
 */
export declare function fromNumberToSignatureAlgorithm(curve: Curve, signatureAlgorithmNumber: number): SignatureAlgorithm;
/**
 * Converts hash number to its Hash enum.
 * Number is relative to curve+signature (e.g., Secp256k1+ECDSA: 0=KECCAK256, 1=SHA256).
 * @throws {Error} if hash number is unknown for the curve+signature algorithm combination
 */
export declare function fromNumberToHash(curve: Curve, signatureAlgorithm: SignatureAlgorithm, hashNumber: number): Hash;
/**
 * Converts curve and signature algorithm numbers to their enum representations.
 * @throws {Error} if numbers are unknown
 */
export declare function fromNumbersToCurveAndSignatureAlgorithm(curveNumber: number, signatureAlgorithmNumber: number): {
    curve: Curve;
    signatureAlgorithm: SignatureAlgorithm;
};
/**
 * Converts curve, signature algorithm, and hash numbers to their enum representations.
 * @throws {Error} if numbers are unknown
 */
export declare function fromNumbersToCurveAndSignatureAlgorithmAndHash(curveNumber: number, signatureAlgorithmNumber: number, hashNumber: number): {
    curve: Curve;
    signatureAlgorithm: SignatureAlgorithm;
    hash: Hash;
};
