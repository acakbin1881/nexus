{
  "version": 3,
  "sources": ["../../../src/client/ika-transaction.ts"],
  "sourcesContent": ["// Copyright (c) dWallet Labs, Ltd.\n// SPDX-License-Identifier: BSD-3-Clause-Clear\n\nimport { Ed25519PublicKey } from '@mysten/sui/keypairs/ed25519';\nimport type {\n\tTransaction,\n\tTransactionObjectArgument,\n\tTransactionResult,\n} from '@mysten/sui/transactions';\n\nimport * as coordinatorTx from '../tx/coordinator.js';\nimport type { DKGRequestInput, ImportDWalletVerificationRequestInput } from './cryptography.js';\nimport {\n\tcreateRandomSessionIdentifier,\n\tencryptSecretShare,\n\tverifyUserShare,\n} from './cryptography.js';\nimport {\n\tfromCurveAndSignatureAlgorithmAndHashToNumbers,\n\tfromCurveAndSignatureAlgorithmToNumbers,\n\tfromCurveToNumber,\n\tfromHashToNumber,\n\tfromNumberToCurve,\n\tvalidateCurveSignatureAlgorithm,\n\tvalidateHashSignatureCombination,\n} from './hash-signature-validation.js';\nimport type {\n\tValidHashForSignature,\n\tValidSignatureAlgorithmForCurve,\n} from './hash-signature-validation.js';\nimport type { IkaClient } from './ika-client.js';\nimport type {\n\tCurve,\n\tDWallet,\n\tEncryptedUserSecretKeyShare,\n\tEncryptionKey,\n\tHash,\n\tImportedKeyDWallet,\n\tImportedSharedDWallet,\n\tPresign,\n\tSharedDWallet,\n\tUserSignatureInputs,\n\tZeroTrustDWallet,\n} from './types.js';\nimport { SignatureAlgorithm } from './types.js';\nimport type { UserShareEncryptionKeys } from './user-share-encryption-keys.js';\nimport {\n\tcreate_sign_centralized_party_message as create_sign,\n\tcreate_sign_centralized_party_message_with_centralized_party_dkg_output as create_sign_with_centralized_output,\n} from './wasm-loader.js';\n\n/**\n * Parameters for creating an IkaTransaction instance\n */\nexport interface IkaTransactionParams {\n\t/** The IkaClient instance to use for blockchain interactions */\n\tikaClient: IkaClient;\n\t/** The Sui transaction to wrap */\n\ttransaction: Transaction;\n\t/** Optional user share encryption keys for cryptographic operations */\n\tuserShareEncryptionKeys?: UserShareEncryptionKeys;\n}\n\n/**\n * IkaTransaction class provides a high-level interface for interacting with the Ika network.\n * It wraps Sui transactions and provides methods for DWallet operations including DKG,\n * presigning, signing, and key management.\n */\nexport class IkaTransaction {\n\t/** The IkaClient instance for blockchain interactions */\n\t#ikaClient: IkaClient;\n\t/** The underlying Sui transaction */\n\t#transaction: Transaction;\n\t/** Optional user share encryption keys for cryptographic operations */\n\t#userShareEncryptionKeys?: UserShareEncryptionKeys;\n\t/** The shared object ref for the coordinator */\n\t#coordinatorObjectRef?: TransactionObjectArgument;\n\t/** The shared object ref for the system */\n\t#systemObjectRef?: TransactionObjectArgument;\n\n\t/**\n\t * Creates a new IkaTransaction instance\n\t * @param params.ikaClient - The IkaClient instance for network operations\n\t * @param params.transaction - The Sui transaction builder to wrap\n\t * @param params.userShareEncryptionKeys - Optional encryption keys for user share operations\n\t */\n\tconstructor({ ikaClient, transaction, userShareEncryptionKeys }: IkaTransactionParams) {\n\t\tthis.#ikaClient = ikaClient;\n\t\tthis.#transaction = transaction;\n\t\tthis.#userShareEncryptionKeys = userShareEncryptionKeys;\n\t}\n\n\t/**\n\t * @deprecated This method is deprecated. Use `requestDWalletDKG` or `requestDWalletDKGWithPublicUserShare` instead.\n\t *\n\t * Request the DKG (Distributed Key Generation) first round with automatic decryption key ID fetching.\n\t * This initiates the creation of a new DWallet through a distributed key generation process.\n\t *\n\t * @param params.curve - The elliptic curve identifier to use for key generation\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to a DWallet capability\n\t * @throws {Error} If the decryption key ID cannot be fetched\n\t */\n\tasync requestDWalletDKGFirstRoundAsync(_params: {\n\t\tcurve: Curve;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument> {\n\t\tthrow new Error(\n\t\t\t'requestDWalletDKGFirstRoundAsync is deprecated. Use requestDWalletDKGFirstRound instead',\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated This method is deprecated. Use `requestDWalletDKG` or `requestDWalletDKGWithPublicUserShare` instead.\n\t *\n\t * Request the DKG (Distributed Key Generation) first round with explicit decryption key ID.\n\t * This initiates the creation of a new DWallet through a distributed key generation process.\n\t *\n\t * @param params.curve - The elliptic curve identifier to use for key generation\n\t * @param params.networkEncryptionKeyID - The specific network encryption key ID to use\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns DWallet capability\n\t */\n\trequestDWalletDKGFirstRound(_params: {\n\t\tcurve: Curve;\n\t\tnetworkEncryptionKeyID: string;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): TransactionObjectArgument {\n\t\tthrow new Error('requestDWalletDKGFirstRound is deprecated. Use requestDWalletDKG instead');\n\t}\n\n\t/**\n\t * @deprecated This method is deprecated. Use `requestDWalletDKG` or `requestDWalletDKGWithPublicUserShare` instead.\n\t *\n\t * Request the DKG (Distributed Key Generation) second round to complete DWallet creation.\n\t * This finalizes the distributed key generation process started in the first round.\n\t *\n\t * @param params.dWalletCap - The dWalletCap object from the first round, created for dWallet\n\t * @param params.dkgSecondRoundRequestInput - Cryptographic data prepared for the second round\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns The updated IkaTransaction instance\n\t * @throws {Error} If user share encryption keys are not set\n\t */\n\trequestDWalletDKGSecondRound(_params: {\n\t\tdWalletCap: TransactionObjectArgument | string;\n\t\tdkgSecondRoundRequestInput: DKGRequestInput;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}) {\n\t\tthrow new Error('requestDWalletDKGSecondRound is deprecated. Use requestDWalletDKG instead');\n\t}\n\n\t/**\n\t * Request the DKG (Distributed Key Generation) to create a dWallet.\n\t *\n\t * @param params.dkgRequestInput - Cryptographic data prepared for the DKG\n\t * @param params.sessionIdentifier - The session identifier object\n\t * @param params.dwalletNetworkEncryptionKeyId - The dWallet network encryption key ID\n\t * @param params.signDuringDKGRequest - The sign during DKG request (hash must be valid for signature algorithm)\n\t * @param params.curve - The curve\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t *\n\t * @returns The DWallet capability and sign id if signDuringDKGRequest is provided\n\t * @throws {Error} If user share encryption keys are not set\n\t */\n\tasync requestDWalletDKG<S extends SignatureAlgorithm = never>({\n\t\tdkgRequestInput,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t\tsessionIdentifier,\n\t\tdwalletNetworkEncryptionKeyId,\n\t\tsignDuringDKGRequest,\n\t\tcurve,\n\t}: {\n\t\tdkgRequestInput: DKGRequestInput;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t\tsessionIdentifier: TransactionObjectArgument;\n\t\tdwalletNetworkEncryptionKeyId: string;\n\t\tsignDuringDKGRequest?: S extends never\n\t\t\t? never\n\t\t\t: {\n\t\t\t\t\tmessage: Uint8Array;\n\t\t\t\t\tpresign: Presign;\n\t\t\t\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\t\t\t\thashScheme: ValidHashForSignature<S>;\n\t\t\t\t\tsignatureAlgorithm: S;\n\t\t\t\t};\n\t\tcurve: Curve;\n\t}): Promise<TransactionResult> {\n\t\tif (!this.#userShareEncryptionKeys) {\n\t\t\tthrow new Error('User share encryption keys are not set');\n\t\t}\n\n\t\t// Validate hash and signature algorithm combination if signing during DKG\n\t\tif (signDuringDKGRequest) {\n\t\t\tvalidateHashSignatureCombination(\n\t\t\t\tsignDuringDKGRequest.hashScheme,\n\t\t\t\tsignDuringDKGRequest.signatureAlgorithm,\n\t\t\t);\n\t\t\tvalidateCurveSignatureAlgorithm(curve, signDuringDKGRequest.signatureAlgorithm);\n\t\t}\n\n\t\treturn coordinatorTx.requestDWalletDKG(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tdwalletNetworkEncryptionKeyId,\n\t\t\tfromCurveToNumber(curve),\n\t\t\tdkgRequestInput.userDKGMessage,\n\t\t\tdkgRequestInput.encryptedUserShareAndProof,\n\t\t\tthis.#userShareEncryptionKeys.getSuiAddress(),\n\t\t\tdkgRequestInput.userPublicOutput,\n\t\t\tthis.#userShareEncryptionKeys.getSigningPublicKeyBytes(),\n\t\t\tsessionIdentifier,\n\t\t\tsignDuringDKGRequest\n\t\t\t\t? coordinatorTx.signDuringDKGRequest(\n\t\t\t\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\t\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\t\t\t\tsignDuringDKGRequest.verifiedPresignCap,\n\t\t\t\t\t\tfromHashToNumber(\n\t\t\t\t\t\t\tcurve,\n\t\t\t\t\t\t\tsignDuringDKGRequest.signatureAlgorithm,\n\t\t\t\t\t\t\tsignDuringDKGRequest.hashScheme,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tsignDuringDKGRequest.message,\n\t\t\t\t\t\tawait this.#getUserSignMessage({\n\t\t\t\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\t\t\t\tsecretShare: dkgRequestInput.userSecretKeyShare,\n\t\t\t\t\t\t\t\tpublicOutput: dkgRequestInput.userPublicOutput,\n\t\t\t\t\t\t\t\thash: signDuringDKGRequest.hashScheme,\n\t\t\t\t\t\t\t\tmessage: signDuringDKGRequest.message,\n\t\t\t\t\t\t\t\tsignatureScheme: signDuringDKGRequest.signatureAlgorithm,\n\t\t\t\t\t\t\t\tpresign: signDuringDKGRequest.presign,\n\t\t\t\t\t\t\t\tcurve,\n\t\t\t\t\t\t\t\tcreateWithCentralizedOutput: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsignDuringDKG: signDuringDKGRequest ? true : false,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tthis.#transaction,\n\t\t\t\t\t)\n\t\t\t\t: null,\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\t/**\n\t * Request the DKG (Distributed Key Generation) with public user share to create a dWallet.\n\t *\n\t * @param params.sessionIdentifier - The session identifier object ID\n\t * @param params.dwalletNetworkEncryptionKeyId - The dWallet network encryption key ID\n\t * @param params.curve - The curve\n\t * @param params.publicKeyShareAndProof - The public key share and proof\n\t * @param params.publicUserSecretKeyShare - The public user secret key share\n\t * @param params.signDuringDKGRequest - The sign during DKG request (hash must be valid for signature algorithm)\n\t * @param params.userPublicOutput - The user's public output from the DKG process\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t *\n\t * @returns The DWallet capability and sign id if signDuringDKGRequest is provided\n\t * @throws {Error} If user share encryption keys are not set\n\t */\n\tasync requestDWalletDKGWithPublicUserShare<S extends SignatureAlgorithm = never>({\n\t\tsessionIdentifier,\n\t\tdwalletNetworkEncryptionKeyId,\n\t\tcurve,\n\t\tpublicKeyShareAndProof,\n\t\tpublicUserSecretKeyShare,\n\t\tsignDuringDKGRequest,\n\t\tuserPublicOutput,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t\tsessionIdentifier: TransactionObjectArgument;\n\t\tdwalletNetworkEncryptionKeyId: string;\n\t\tcurve: Curve;\n\t\tpublicKeyShareAndProof: Uint8Array;\n\t\tpublicUserSecretKeyShare: Uint8Array;\n\t\tuserPublicOutput: Uint8Array;\n\t\tsignDuringDKGRequest?: S extends never\n\t\t\t? never\n\t\t\t: {\n\t\t\t\t\tmessage: Uint8Array;\n\t\t\t\t\tpresign: Presign;\n\t\t\t\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\t\t\t\thashScheme: ValidHashForSignature<S>;\n\t\t\t\t\tsignatureAlgorithm: S;\n\t\t\t\t};\n\t}): Promise<TransactionResult> {\n\t\tif (!this.#userShareEncryptionKeys) {\n\t\t\tthrow new Error('User share encryption keys are not set');\n\t\t}\n\n\t\t// Validate hash and signature algorithm combination if signing during DKG\n\t\tif (signDuringDKGRequest) {\n\t\t\tvalidateHashSignatureCombination(\n\t\t\t\tsignDuringDKGRequest.hashScheme,\n\t\t\t\tsignDuringDKGRequest.signatureAlgorithm,\n\t\t\t);\n\t\t\tvalidateCurveSignatureAlgorithm(curve, signDuringDKGRequest.signatureAlgorithm);\n\t\t}\n\n\t\treturn coordinatorTx.requestDWalletDKGWithPublicUserSecretKeyShare(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tdwalletNetworkEncryptionKeyId,\n\t\t\tfromCurveToNumber(curve),\n\t\t\tpublicKeyShareAndProof,\n\t\t\tpublicUserSecretKeyShare,\n\t\t\tuserPublicOutput,\n\t\t\tsessionIdentifier,\n\t\t\tsignDuringDKGRequest\n\t\t\t\t? coordinatorTx.signDuringDKGRequest(\n\t\t\t\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\t\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\t\t\t\tsignDuringDKGRequest.verifiedPresignCap,\n\t\t\t\t\t\tfromHashToNumber(\n\t\t\t\t\t\t\tcurve,\n\t\t\t\t\t\t\tsignDuringDKGRequest.signatureAlgorithm,\n\t\t\t\t\t\t\tsignDuringDKGRequest.hashScheme,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tsignDuringDKGRequest.message,\n\t\t\t\t\t\tawait this.#getUserSignMessage({\n\t\t\t\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\t\t\t\thash: signDuringDKGRequest.hashScheme,\n\t\t\t\t\t\t\t\tmessage: signDuringDKGRequest.message,\n\t\t\t\t\t\t\t\tsignatureScheme: signDuringDKGRequest.signatureAlgorithm,\n\t\t\t\t\t\t\t\tpresign: signDuringDKGRequest.presign,\n\t\t\t\t\t\t\t\tcurve,\n\t\t\t\t\t\t\t\tpublicOutput: userPublicOutput,\n\t\t\t\t\t\t\t\tsecretShare: publicUserSecretKeyShare,\n\t\t\t\t\t\t\t\tcreateWithCentralizedOutput: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsignDuringDKG: signDuringDKGRequest ? true : false,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tthis.#transaction,\n\t\t\t\t\t)\n\t\t\t\t: null,\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\t/**\n\t * This completes the user's participation in the DKG process by accepting their encrypted share.\n\t *\n\t * @param params.dWallet - The DWallet object to accept the share for\n\t * @param params.userPublicOutput - The user's public output from the DKG process, this is used to verify the user's public output signature.\n\t * @param params.encryptedUserSecretKeyShareId - The ID of the encrypted user secret key share\n\t * @returns Promise resolving to the updated IkaTransaction instance\n\t * @throws {Error} If user share encryption keys are not set\n\t */\n\tasync acceptEncryptedUserShare({\n\t\tdWallet,\n\t\tuserPublicOutput,\n\t\tencryptedUserSecretKeyShareId,\n\t}: {\n\t\tdWallet: ZeroTrustDWallet | ImportedKeyDWallet;\n\t\tuserPublicOutput: Uint8Array;\n\t\tencryptedUserSecretKeyShareId: string;\n\t}): Promise<IkaTransaction>;\n\n\t/**\n\t * Accept an encrypted user share for a transferred DWallet.\n\t * This completes the user's participation in the DKG process by accepting their encrypted share.\n\t *\n\t * SECURITY WARNING: `sourceEncryptionKey` shouldn't be fetched from the network;\n\t * the public key of the sender (or its address) should be known to the receiver,\n\t * so that the verification here would be impactful.\n\t *\n\t * @param params.dWallet - The DWallet object to accept the share for\n\t * @param params.sourceEncryptionKey - The encryption key used to encrypt the user's secret share.\n\t * @param params.sourceEncryptedUserSecretKeyShare - The encrypted user secret key share.\n\t * @param params.destinationEncryptedUserSecretKeyShare - The encrypted user secret key share.\n\t * @returns Promise resolving to the updated IkaTransaction instance\n\t * @throws {Error} If user share encryption keys are not set\n\t */\n\tasync acceptEncryptedUserShare({\n\t\tdWallet,\n\t\tsourceEncryptionKey,\n\t\tsourceEncryptedUserSecretKeyShare,\n\t\tdestinationEncryptedUserSecretKeyShare,\n\t}: {\n\t\tdWallet: ZeroTrustDWallet | ImportedKeyDWallet;\n\t\tsourceEncryptionKey: EncryptionKey;\n\t\tsourceEncryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;\n\t\tdestinationEncryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;\n\t}): Promise<IkaTransaction>;\n\n\tasync acceptEncryptedUserShare({\n\t\tdWallet,\n\t\tuserPublicOutput,\n\t\tencryptedUserSecretKeyShareId,\n\t\tsourceEncryptionKey,\n\t\tsourceEncryptedUserSecretKeyShare,\n\t\tdestinationEncryptedUserSecretKeyShare,\n\t}: {\n\t\tdWallet: ZeroTrustDWallet | ImportedKeyDWallet;\n\t\tuserPublicOutput?: Uint8Array;\n\t\tencryptedUserSecretKeyShareId?: string;\n\t\tsourceEncryptionKey?: EncryptionKey;\n\t\tsourceEncryptedUserSecretKeyShare?: EncryptedUserSecretKeyShare;\n\t\tdestinationEncryptedUserSecretKeyShare?: EncryptedUserSecretKeyShare;\n\t}) {\n\t\tif (!this.#userShareEncryptionKeys) {\n\t\t\tthrow new Error('User share encryption keys are not set');\n\t\t}\n\n\t\t// Regular DWallet encrypted user share acceptance\n\t\tif (userPublicOutput && encryptedUserSecretKeyShareId) {\n\t\t\tcoordinatorTx.acceptEncryptedUserShare(\n\t\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\t\tdWallet.id.id,\n\t\t\t\tencryptedUserSecretKeyShareId,\n\t\t\t\tawait this.#userShareEncryptionKeys.getUserOutputSignature(dWallet, userPublicOutput),\n\t\t\t\tthis.#transaction,\n\t\t\t);\n\n\t\t\treturn this;\n\t\t}\n\n\t\t// Transferred DWallet encrypted user share acceptance\n\t\tif (\n\t\t\tsourceEncryptionKey &&\n\t\t\tsourceEncryptedUserSecretKeyShare &&\n\t\t\tdestinationEncryptedUserSecretKeyShare\n\t\t) {\n\t\t\tcoordinatorTx.acceptEncryptedUserShare(\n\t\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\t\tdWallet.id.id,\n\t\t\t\tdestinationEncryptedUserSecretKeyShare.id.id,\n\t\t\t\tawait this.#userShareEncryptionKeys.getUserOutputSignatureForTransferredDWallet(\n\t\t\t\t\tdWallet,\n\t\t\t\t\tsourceEncryptedUserSecretKeyShare,\n\t\t\t\t\tsourceEncryptionKey,\n\t\t\t\t),\n\t\t\t\tthis.#transaction,\n\t\t\t);\n\n\t\t\treturn this;\n\t\t}\n\n\t\tthrow new Error(\n\t\t\t'Invalid parameters: must provide either (userPublicOutput, encryptedUserSecretKeyShareId) for regular DWallet or (sourceEncryptionKey, sourceEncryptedUserSecretKeyShare, destinationEncryptedUserSecretKeyShare) for transferred DWallet',\n\t\t);\n\t}\n\n\t/**\n\t * Register an encryption key for the current user on the specified curve.\n\t * This allows the user to participate in encrypted operations on the network.\n\t *\n\t * @param params.curve - The elliptic curve identifier to register the key for\n\t * @returns Promise resolving to the updated IkaTransaction instance\n\t * @throws {Error} If user share encryption keys are not set\n\t */\n\tasync registerEncryptionKey({ curve }: { curve: Curve }) {\n\t\tif (!this.#userShareEncryptionKeys) {\n\t\t\tthrow new Error('User share encryption keys are not set');\n\t\t}\n\n\t\tcoordinatorTx.registerEncryptionKeyTx(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tfromCurveToNumber(curve),\n\t\t\tthis.#userShareEncryptionKeys.encryptionKey,\n\t\t\tawait this.#userShareEncryptionKeys.getEncryptionKeySignature(),\n\t\t\tthis.#userShareEncryptionKeys.getSigningPublicKeyBytes(),\n\t\t\tthis.#transaction,\n\t\t);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Make the DWallet user secret key shares public, allowing them to be used without decryption.\n\t * This is useful for scenarios where the secret share can be publicly accessible.\n\t *\n\t * @param params.dWallet - The DWallet to make the shares public for\n\t * @param params.secretShare - The secret share data to make public\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns The updated IkaTransaction instance\n\t */\n\tmakeDWalletUserSecretKeySharesPublic({\n\t\tdWallet,\n\t\tsecretShare,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: ZeroTrustDWallet | ImportedKeyDWallet;\n\t\tsecretShare: Uint8Array;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}) {\n\t\tcoordinatorTx.requestMakeDwalletUserSecretKeySharesPublic(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tdWallet.id.id,\n\t\t\tsecretShare,\n\t\t\tthis.createSessionIdentifier(),\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t\tthis.#transaction,\n\t\t);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Request a presign operation for a DWallet.\n\t * Presigning allows for faster signature generation by pre-computing part of the signature.\n\t *\n\t * If you are using ecdsa(k1,r1) and imported key dwallet, you must call this function always\n\t * If you are using schnor, schnorrkell, eddsa, taproot, call requestGlobalPresign instead\n\t *\n\t * @param params.dWallet - The DWallet to create the presign for\n\t * @param params.signatureAlgorithm - The signature algorithm identifier to use\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Unverified presign capability\n\t */\n\trequestPresign({\n\t\tdWallet,\n\t\tsignatureAlgorithm,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: DWallet;\n\t\tsignatureAlgorithm: SignatureAlgorithm;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): TransactionObjectArgument {\n\t\tthis.#assertDWalletPublicOutputSet(dWallet);\n\t\tthis.#assertCanRunNormalPresign(dWallet, signatureAlgorithm);\n\t\tvalidateCurveSignatureAlgorithm(fromNumberToCurve(dWallet.curve), signatureAlgorithm);\n\n\t\tconst unverifiedPresignCap = this.#requestPresign({\n\t\t\tdWallet,\n\t\t\tsignatureAlgorithm,\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t});\n\n\t\treturn unverifiedPresignCap;\n\t}\n\n\t/**\n\t * Request a global presign operation.\n\t * If you are using ecdsa(k1,r1) and imported key dwallet, instead call requestPresign\n\t * If you are using schnor, schnorrkell, eddsa, taproot, call this function always\n\t *\n\t * @param params.dwalletNetworkEncryptionKeyId - The network encryption key ID to use for the presign\n\t * @param params.curve - The curve to use for the presign\n\t * @param params.signatureAlgorithm - The signature algorithm to use (must be valid for the curve)\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Unverified presign capability\n\t */\n\trequestGlobalPresign<C extends Curve>({\n\t\tdwalletNetworkEncryptionKeyId,\n\t\tcurve,\n\t\tsignatureAlgorithm,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdwalletNetworkEncryptionKeyId: string;\n\t\tcurve: C;\n\t\tsignatureAlgorithm: ValidSignatureAlgorithmForCurve<C>;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}) {\n\t\tvalidateCurveSignatureAlgorithm(curve, signatureAlgorithm);\n\n\t\tconst unverifiedPresignCap = this.#requestGlobalPresign({\n\t\t\tdwalletNetworkEncryptionKeyId,\n\t\t\tcurve,\n\t\t\tsignatureAlgorithm,\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t});\n\n\t\treturn unverifiedPresignCap;\n\t}\n\n\t/**\n\t * Approve a message for signing with a DWallet.\n\t * This creates an approval object that can be used in subsequent signing operations.\n\t *\n\t * @param params.dWalletCap - The dWalletCap object, that owns the dWallet\n\t * @param params.curve - The curve to use for the approval\n\t * @param params.signatureAlgorithm - The signature algorithm to use (must be valid for the curve)\n\t * @param params.hashScheme - The hash scheme to apply to the message (must be valid for the signature algorithm)\n\t * @param params.message - The message bytes to approve for signing\n\t * @returns Message approval\n\t */\n\tapproveMessage<C extends Curve, S extends ValidSignatureAlgorithmForCurve<C>>({\n\t\tdWalletCap,\n\t\tcurve,\n\t\tsignatureAlgorithm,\n\t\thashScheme,\n\t\tmessage,\n\t}: {\n\t\tdWalletCap: TransactionObjectArgument | string;\n\t\tcurve: C;\n\t\tsignatureAlgorithm: S;\n\t\thashScheme: ValidHashForSignature<S>;\n\t\tmessage: Uint8Array;\n\t}): TransactionObjectArgument {\n\t\tvalidateCurveSignatureAlgorithm(curve, signatureAlgorithm);\n\t\tvalidateHashSignatureCombination(hashScheme, signatureAlgorithm);\n\n\t\tconst { signatureAlgorithmNumber, hashNumber } = fromCurveAndSignatureAlgorithmAndHashToNumbers(\n\t\t\tcurve,\n\t\t\tsignatureAlgorithm,\n\t\t\thashScheme,\n\t\t);\n\n\t\tconst messageApproval = coordinatorTx.approveMessage(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tthis.#transaction.object(dWalletCap),\n\t\t\tsignatureAlgorithmNumber,\n\t\t\thashNumber,\n\t\t\tmessage,\n\t\t\tthis.#transaction,\n\t\t);\n\n\t\treturn messageApproval;\n\t}\n\n\t/**\n\t * Verify a presign capability to ensure it can be used for signing.\n\t * This converts an unverified presign capability into a verified one.\n\t *\n\t * @param params.presign - The presign object to verify\n\t * @returns Verified presign capability\n\t */\n\tverifyPresignCap({ presign }: { presign: Presign }): TransactionObjectArgument;\n\n\t/**\n\t * Verify a presign capability to ensure it can be used for signing.\n\t * This converts an unverified presign capability into a verified one.\n\t *\n\t * @param params.unverifiedPresignCap - The unverified presign capability object or ID\n\t * @returns Verified presign capability\n\t */\n\tverifyPresignCap({\n\t\tunverifiedPresignCap,\n\t}: {\n\t\tunverifiedPresignCap: TransactionObjectArgument | string;\n\t}): TransactionObjectArgument;\n\n\tverifyPresignCap({\n\t\tpresign,\n\t\tunverifiedPresignCap,\n\t}: {\n\t\tpresign?: Presign;\n\t\tunverifiedPresignCap?: TransactionObjectArgument | string;\n\t}): TransactionObjectArgument {\n\t\tlet capId: TransactionObjectArgument | string;\n\n\t\tif (unverifiedPresignCap) {\n\t\t\tcapId = unverifiedPresignCap;\n\t\t} else if (presign?.cap_id) {\n\t\t\tcapId = presign.cap_id;\n\t\t} else {\n\t\t\tthrow new Error('Either presign or unverifiedPresignCap must be provided');\n\t\t}\n\n\t\tconst verifiedPresignCap = coordinatorTx.verifyPresignCap(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tthis.#transaction.object(capId),\n\t\t\tthis.#transaction,\n\t\t);\n\n\t\treturn verifiedPresignCap;\n\t}\n\n\t/**\n\t * Approve a message for signing with an imported key DWallet.\n\t * This is similar to approveMessage but specifically for DWallets created with imported keys.\n\t *\n\t * @param params.dWalletCap - The dWalletCap object, that owns the dWallet\n\t * @param params.curve - The curve to use for the approval\n\t * @param params.signatureAlgorithm - The signature algorithm to use (must be valid for the curve)\n\t * @param params.hashScheme - The hash scheme to apply to the message (must be valid for the signature algorithm)\n\t * @param params.message - The message bytes to approve for signing\n\t * @returns Imported key message approval\n\t */\n\tapproveImportedKeyMessage<C extends Curve, S extends ValidSignatureAlgorithmForCurve<C>>({\n\t\tdWalletCap,\n\t\tcurve,\n\t\tsignatureAlgorithm,\n\t\thashScheme,\n\t\tmessage,\n\t}: {\n\t\tdWalletCap: TransactionObjectArgument | string;\n\t\tcurve: C;\n\t\tsignatureAlgorithm: S;\n\t\thashScheme: ValidHashForSignature<S>;\n\t\tmessage: Uint8Array;\n\t}): TransactionObjectArgument {\n\t\tvalidateCurveSignatureAlgorithm(curve, signatureAlgorithm);\n\t\tvalidateHashSignatureCombination(hashScheme, signatureAlgorithm);\n\n\t\tconst { signatureAlgorithmNumber, hashNumber } = fromCurveAndSignatureAlgorithmAndHashToNumbers(\n\t\t\tcurve,\n\t\t\tsignatureAlgorithm,\n\t\t\thashScheme,\n\t\t);\n\n\t\tconst importedKeyMessageApproval = coordinatorTx.approveImportedKeyMessage(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tthis.#transaction.object(dWalletCap),\n\t\t\tsignatureAlgorithmNumber,\n\t\t\thashNumber,\n\t\t\tmessage,\n\t\t\tthis.#transaction,\n\t\t);\n\n\t\treturn importedKeyMessageApproval;\n\t}\n\n\t/**\n\t * Sign a message using a DWallet.\n\t * This performs the actual signing operation using the presign and user's share (encrypted, secret, or public).\n\t * Only supports ZeroTrust and Shared DWallets. For Imported Key DWallets, use requestSignWithImportedKey instead.\n\t *\n\t * SECURITY WARNING: When using unencrypted shares, this method does not verify `secretShare` and `publicOutput`,\n\t * which must be verified by the caller in order to guarantee zero-trust security.\n\t *\n\t * @param params.dWallet - The DWallet to sign with (ZeroTrust or Shared DWallet)\n\t * @param params.messageApproval - Message approval\n\t * @param params.hashScheme - The hash scheme used for the message (must be valid for the signature algorithm)\n\t * @param params.verifiedPresignCap - The verified presign capability\n\t * @param params.presign - The completed presign object\n\t * @param params.encryptedUserSecretKeyShare - Optional: encrypted user secret key share (for ZeroTrust DWallets)\n\t * @param params.secretShare - Optional: unencrypted secret share (requires publicOutput, for ZeroTrust DWallets)\n\t * @param params.publicOutput - Optional: public output (required when using secretShare, for ZeroTrust DWallets)\n\t * @param params.message - The message bytes to sign\n\t * @param params.signatureScheme - The signature algorithm to use\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to the signature ID\n\t *\n\t * @example\n\t * // ZeroTrust DWallet - Zero-trust signing (encrypted shares)\n\t * const signatureId = await tx.requestSign({\n\t *   dWallet, // ZeroTrustDWallet\n\t *   messageApproval,\n\t *   encryptedUserSecretKeyShare,\n\t *   // ... other params\n\t * });\n\t *\n\t * @example\n\t * // ZeroTrust DWallet - Secret share signing\n\t * const signatureId = await tx.requestSign({\n\t *   dWallet, // ZeroTrustDWallet\n\t *   messageApproval,\n\t *   secretShare,\n\t *   publicOutput,\n\t *   // ... other params\n\t * });\n\t *\n\t * @example\n\t * // Shared DWallet - Public share signing (no secret params needed)\n\t * const signatureId = await tx.requestSign({\n\t *   dWallet, // SharedDWallet\n\t *   messageApproval,\n\t *   // ... other params (no secretShare/publicOutput needed)\n\t * });\n\t */\n\tasync requestSign<S extends SignatureAlgorithm>({\n\t\tdWallet,\n\t\tmessageApproval,\n\t\thashScheme,\n\t\tverifiedPresignCap,\n\t\tpresign,\n\t\tencryptedUserSecretKeyShare,\n\t\tsecretShare,\n\t\tpublicOutput,\n\t\tmessage,\n\t\tsignatureScheme,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: ZeroTrustDWallet | SharedDWallet;\n\t\tmessageApproval: TransactionObjectArgument;\n\t\thashScheme: ValidHashForSignature<S>;\n\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\tpresign: Presign;\n\t\tencryptedUserSecretKeyShare?: EncryptedUserSecretKeyShare;\n\t\tsecretShare?: Uint8Array;\n\t\tpublicOutput?: Uint8Array;\n\t\tmessage: Uint8Array;\n\t\tsignatureScheme: S;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument> {\n\t\t// Validate hash and signature algorithm combination\n\t\tvalidateHashSignatureCombination(hashScheme, signatureScheme);\n\t\tvalidateCurveSignatureAlgorithm(fromNumberToCurve(dWallet.curve), signatureScheme);\n\n\t\t// Auto-detect share availability\n\t\tconst hasPublicShares = !!dWallet.public_user_secret_key_share;\n\n\t\t// Regular DWallet signing (ZeroTrust and Shared only)\n\t\tif (encryptedUserSecretKeyShare) {\n\t\t\t// Encrypted shares\n\t\t\treturn this.#requestSign({\n\t\t\t\tverifiedPresignCap,\n\t\t\t\tmessageApproval,\n\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\tactiveDWallet: dWallet,\n\t\t\t\t\tpresign,\n\t\t\t\t\tencryptedUserSecretKeyShare,\n\t\t\t\t\tmessage,\n\t\t\t\t\thash: hashScheme,\n\t\t\t\t\tsignatureScheme: signatureScheme,\n\t\t\t\t\tcurve: fromNumberToCurve(dWallet.curve),\n\t\t\t\t},\n\t\t\t\tikaCoin,\n\t\t\t\tsuiCoin,\n\t\t\t});\n\t\t} else if (secretShare && publicOutput) {\n\t\t\t// Secret share provided\n\t\t\treturn this.#requestSign({\n\t\t\t\tverifiedPresignCap,\n\t\t\t\tmessageApproval,\n\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\tactiveDWallet: dWallet,\n\t\t\t\t\tpresign,\n\t\t\t\t\tsecretShare,\n\t\t\t\t\tpublicOutput,\n\t\t\t\t\tmessage,\n\t\t\t\t\thash: hashScheme,\n\t\t\t\t\tsignatureScheme: signatureScheme,\n\t\t\t\t\tcurve: fromNumberToCurve(dWallet.curve),\n\t\t\t\t},\n\t\t\t\tikaCoin,\n\t\t\t\tsuiCoin,\n\t\t\t});\n\t\t} else if (hasPublicShares) {\n\t\t\t// Public shares available on DWallet\n\t\t\tthis.#assertDWalletPublicUserSecretKeyShareSet(dWallet);\n\t\t\tthis.#assertDWalletPublicOutputSet(dWallet);\n\n\t\t\treturn this.#requestSign({\n\t\t\t\tverifiedPresignCap,\n\t\t\t\tmessageApproval,\n\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\tactiveDWallet: dWallet,\n\t\t\t\t\tpresign,\n\t\t\t\t\t// No need to verify public output in public user-share flows, as there is no zero-trust security in this model.\n\t\t\t\t\tpublicOutput: Uint8Array.from(dWallet.state.Active?.public_output),\n\t\t\t\t\tsecretShare: Uint8Array.from(dWallet.public_user_secret_key_share),\n\t\t\t\t\tmessage,\n\t\t\t\t\thash: hashScheme,\n\t\t\t\t\tsignatureScheme: signatureScheme,\n\t\t\t\t\tcurve: fromNumberToCurve(dWallet.curve),\n\t\t\t\t},\n\t\t\t\tikaCoin,\n\t\t\t\tsuiCoin,\n\t\t\t});\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t'DWallet signing requires either encryptedUserSecretKeyShare, (secretShare + publicOutput), or public_user_secret_key_share on the DWallet',\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Sign a message using an Imported Key DWallet.\n\t * This performs the actual signing operation using the presign and user's share (encrypted, secret, or public).\n\t *\n\t * SECURITY WARNING: When using unencrypted shares, this method does not verify `secretShare` and `publicOutput`,\n\t * which must be verified by the caller in order to guarantee zero-trust security.\n\t *\n\t * @param params.dWallet - The Imported Key DWallet to sign with (type and share availability auto-detected)\n\t * @param params.importedKeyMessageApproval - Imported key message approval\n\t * @param params.hashScheme - The hash scheme used for the message (must be valid for the signature algorithm)\n\t * @param params.verifiedPresignCap - The verified presign capability\n\t * @param params.presign - The completed presign object\n\t * @param params.encryptedUserSecretKeyShare - Optional: encrypted user secret key share (for ImportedKeyDWallet)\n\t * @param params.secretShare - Optional: unencrypted secret share (requires publicOutput, for ImportedKeyDWallet)\n\t * @param params.publicOutput - Optional: public output (required when using secretShare, for ImportedKeyDWallet)\n\t * @param params.message - The message bytes to sign\n\t * @param params.signatureScheme - Optional: signature algorithm (defaults to ECDSASecp256k1)\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to the signature ID\n\t *\n\t * @example\n\t * // ImportedKeyDWallet - Zero-trust signing (encrypted shares)\n\t * const signatureId = await tx.requestSignWithImportedKey({\n\t *   dWallet, // ImportedKeyDWallet\n\t *   importedKeyMessageApproval,\n\t *   encryptedUserSecretKeyShare,\n\t *   // ... other params\n\t * });\n\t *\n\t * @example\n\t * // ImportedKeyDWallet - Secret share signing\n\t * const signatureId = await tx.requestSignWithImportedKey({\n\t *   dWallet, // ImportedKeyDWallet\n\t *   importedKeyMessageApproval,\n\t *   secretShare,\n\t *   publicOutput,\n\t *   // ... other params\n\t * });\n\t *\n\t * @example\n\t * // ImportedSharedDWallet - Public share signing (no secret params needed)\n\t * const signatureId = await tx.requestSignWithImportedKey({\n\t *   dWallet, // ImportedSharedDWallet\n\t *   importedKeyMessageApproval,\n\t *   // ... other params (no secretShare/publicOutput needed)\n\t * });\n\t */\n\tasync requestSignWithImportedKey<\n\t\tS extends SignatureAlgorithm = typeof SignatureAlgorithm.ECDSASecp256k1,\n\t>({\n\t\tdWallet,\n\t\timportedKeyMessageApproval,\n\t\thashScheme,\n\t\tverifiedPresignCap,\n\t\tpresign,\n\t\tencryptedUserSecretKeyShare,\n\t\tsecretShare,\n\t\tpublicOutput,\n\t\tmessage,\n\t\tsignatureScheme,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: ImportedKeyDWallet | ImportedSharedDWallet;\n\t\timportedKeyMessageApproval: TransactionObjectArgument;\n\t\thashScheme: ValidHashForSignature<S>;\n\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\tpresign: Presign;\n\t\tencryptedUserSecretKeyShare?: EncryptedUserSecretKeyShare;\n\t\tsecretShare?: Uint8Array;\n\t\tpublicOutput?: Uint8Array;\n\t\tmessage: Uint8Array;\n\t\tsignatureScheme?: S;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument> {\n\t\tif (!dWallet.is_imported_key_dwallet) {\n\t\t\tthrow new Error('dWallet must be an ImportedKeyDWallet');\n\t\t}\n\n\t\t// Default to ECDSASecp256k1 if not provided\n\t\tconst actualSignatureScheme = signatureScheme || SignatureAlgorithm.ECDSASecp256k1;\n\n\t\t// Validate hash and signature algorithm combination\n\t\tvalidateHashSignatureCombination(hashScheme, actualSignatureScheme);\n\t\tvalidateCurveSignatureAlgorithm(fromNumberToCurve(dWallet.curve), actualSignatureScheme);\n\n\t\t// Auto-detect share availability\n\t\tconst hasPublicShares = !!dWallet.public_user_secret_key_share;\n\n\t\t// Auto-detect signing method based on available shares and parameters\n\t\tif (encryptedUserSecretKeyShare) {\n\t\t\t// Encrypted shares\n\t\t\treturn this.#requestImportedKeySign({\n\t\t\t\tverifiedPresignCap,\n\t\t\t\timportedKeyMessageApproval,\n\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\tactiveDWallet: dWallet,\n\t\t\t\t\tencryptedUserSecretKeyShare,\n\t\t\t\t\tpresign,\n\t\t\t\t\tmessage,\n\t\t\t\t\thash: hashScheme,\n\t\t\t\t\tsignatureScheme: actualSignatureScheme,\n\t\t\t\t\tcurve: fromNumberToCurve(dWallet.curve),\n\t\t\t\t},\n\t\t\t\tikaCoin,\n\t\t\t\tsuiCoin,\n\t\t\t});\n\t\t} else if (secretShare && publicOutput) {\n\t\t\t// Secret share provided\n\t\t\treturn this.#requestImportedKeySign({\n\t\t\t\tverifiedPresignCap,\n\t\t\t\timportedKeyMessageApproval,\n\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\tactiveDWallet: dWallet,\n\t\t\t\t\tsecretShare,\n\t\t\t\t\tpublicOutput,\n\t\t\t\t\tpresign,\n\t\t\t\t\tmessage,\n\t\t\t\t\thash: hashScheme,\n\t\t\t\t\tsignatureScheme: actualSignatureScheme,\n\t\t\t\t\tcurve: fromNumberToCurve(dWallet.curve),\n\t\t\t\t},\n\t\t\t\tikaCoin,\n\t\t\t\tsuiCoin,\n\t\t\t});\n\t\t} else if (hasPublicShares) {\n\t\t\t// Public shares available on DWallet\n\t\t\tthis.#assertDWalletPublicUserSecretKeyShareSet(dWallet);\n\t\t\treturn this.#requestImportedKeySign({\n\t\t\t\tverifiedPresignCap,\n\t\t\t\timportedKeyMessageApproval,\n\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\tactiveDWallet: dWallet,\n\t\t\t\t\tpresign,\n\t\t\t\t\tmessage,\n\t\t\t\t\thash: hashScheme,\n\t\t\t\t\tsignatureScheme: actualSignatureScheme,\n\t\t\t\t\tcurve: fromNumberToCurve(dWallet.curve),\n\t\t\t\t},\n\t\t\t\tikaCoin,\n\t\t\t\tsuiCoin,\n\t\t\t});\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t'Imported Key DWallet signing requires either encryptedUserSecretKeyShare, (secretShare + publicOutput), or public_user_secret_key_share on the DWallet',\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Request a future sign operation with encrypted shares for ZeroTrust DWallets and keep capability.\n\t * This creates a partial user signature capability that is returned with the transaction.\n\t *\n\t * @param params.dWallet - The ZeroTrust DWallet to create the future sign for\n\t * @param params.verifiedPresignCap - The verified presign capability\n\t * @param params.presign - The completed presign object\n\t * @param params.encryptedUserSecretKeyShare - The user's encrypted secret key share\n\t * @param params.message - The message bytes to pre-sign\n\t * @param params.hashScheme - The hash scheme to use for the message\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to the unverified partial user signature capability\n\t */\n\tasync requestFutureSign({\n\t\tdWallet,\n\t\tverifiedPresignCap,\n\t\tpresign,\n\t\tencryptedUserSecretKeyShare,\n\t\tmessage,\n\t\thashScheme,\n\t\tsignatureScheme,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: ZeroTrustDWallet;\n\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\tpresign: Presign;\n\t\tencryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;\n\t\tmessage: Uint8Array;\n\t\thashScheme: Hash;\n\t\tsignatureScheme: SignatureAlgorithm;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument>;\n\n\t/**\n\t * Request a future sign operation with secret shares for ZeroTrust DWallets and keep capability.\n\t * This creates a partial user signature capability that is returned with the transaction.\n\t *\n\t * SECURITY WARNING: This method does not verify `secretShare` and `publicOutput`,\n\t * which must be verified by the caller in order to guarantee zero-trust security.\n\t *\n\t * @param params.dWallet - The ZeroTrust DWallet to create the future sign for\n\t * @param params.verifiedPresignCap - The verified presign capability\n\t * @param params.presign - The completed presign object\n\t * @param params.secretShare - The user's unencrypted secret share\n\t * @param params.publicOutput - The user's public output\n\t * @param params.message - The message bytes to pre-sign\n\t * @param params.hashScheme - The hash scheme to use for the message\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to the unverified partial user signature capability\n\t */\n\tasync requestFutureSign({\n\t\tdWallet,\n\t\tverifiedPresignCap,\n\t\tpresign,\n\t\tsecretShare,\n\t\tpublicOutput,\n\t\tmessage,\n\t\thashScheme,\n\t\tsignatureScheme,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: ZeroTrustDWallet;\n\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\tpresign: Presign;\n\t\tsecretShare: Uint8Array;\n\t\tpublicOutput: Uint8Array;\n\t\tmessage: Uint8Array;\n\t\thashScheme: Hash;\n\t\tsignatureScheme: SignatureAlgorithm;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument>;\n\n\t/**\n\t * Request a future sign operation with public shares for Shared DWallets and keep capability.\n\t * This creates a partial user signature capability that is returned with the transaction.\n\t * No secret share or public output parameters are needed as they are available on the DWallet.\n\t *\n\t * @param params.dWallet - The Shared DWallet to create the future sign for\n\t * @param params.verifiedPresignCap - The verified presign capability\n\t * @param params.presign - The completed presign object\n\t * @param params.message - The message bytes to pre-sign\n\t * @param params.hashScheme - The hash scheme to use for the message\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to the unverified partial user signature capability\n\t */\n\tasync requestFutureSign({\n\t\tdWallet,\n\t\tverifiedPresignCap,\n\t\tpresign,\n\t\tmessage,\n\t\thashScheme,\n\t\tsignatureScheme,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: SharedDWallet;\n\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\tpresign: Presign;\n\t\tmessage: Uint8Array;\n\t\thashScheme: Hash;\n\t\tsignatureScheme: SignatureAlgorithm;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument>;\n\n\t/**\n\t * Universal requestFutureSign method implementation that automatically detects DWallet type and share availability.\n\t * This method intelligently routes to the appropriate future signing implementation.\n\t * Only supports ZeroTrust and Shared DWallets. For Imported Key DWallets, use requestFutureSignWithImportedKey instead.\n\t *\n\t * @param params.dWallet - The DWallet to create the future sign for (ZeroTrust or Shared DWallet)\n\t * @param params.verifiedPresignCap - The verified presign capability\n\t * @param params.presign - The completed presign object\n\t * @param params.encryptedUserSecretKeyShare - Optional: encrypted user secret key share (for ZeroTrust DWallets)\n\t * @param params.secretShare - Optional: unencrypted secret share (requires publicOutput, for ZeroTrust DWallets)\n\t * @param params.publicOutput - Optional: public output (required when using secretShare, for ZeroTrust DWallets)\n\t * @param params.message - The message bytes to pre-sign\n\t * @param params.hashScheme - The hash scheme to use for the message\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to unverified partial user signature capability\n\t *\n\t * @example\n\t * // ZeroTrust DWallet - Keep capability (encrypted shares)\n\t * const unverifiedPartialUserSignatureCap = await tx.requestFutureSign({\n\t *   dWallet, // ZeroTrustDWallet\n\t *   encryptedUserSecretKeyShare,\n\t *   // ... other params\n\t * });\n\t *\n\t * @example\n\t * // ZeroTrust DWallet\n\t * const unverifiedPartialUserSignatureCap = await tx.requestFutureSign({\n\t *   dWallet, // ZeroTrustDWallet\n\t *   secretShare,\n\t *   publicOutput,\n\t *   // ... other params\n\t * });\n\t *\n\t * @example\n\t * // Shared DWallet - Public share signing (no secret params needed)\n\t * const unverifiedPartialUserSignatureCap = await tx.requestFutureSign({\n\t *   dWallet, // SharedDWallet\n\t *   // ... other params (no secretShare/publicOutput needed)\n\t * });\n\t */\n\tasync requestFutureSign<S extends SignatureAlgorithm>({\n\t\tdWallet,\n\t\tverifiedPresignCap,\n\t\tpresign,\n\t\tencryptedUserSecretKeyShare,\n\t\tsecretShare,\n\t\tpublicOutput,\n\t\tmessage,\n\t\thashScheme,\n\t\tsignatureScheme,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: ZeroTrustDWallet | SharedDWallet;\n\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\tpresign: Presign;\n\t\tencryptedUserSecretKeyShare?: EncryptedUserSecretKeyShare;\n\t\tsecretShare?: Uint8Array;\n\t\tpublicOutput?: Uint8Array;\n\t\tmessage: Uint8Array;\n\t\thashScheme: ValidHashForSignature<S>;\n\t\tsignatureScheme: S;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument> {\n\t\t// Validate hash and signature algorithm combination\n\t\tvalidateHashSignatureCombination(hashScheme, signatureScheme);\n\t\tvalidateCurveSignatureAlgorithm(fromNumberToCurve(dWallet.curve), signatureScheme);\n\n\t\t// Auto-detect share availability\n\t\tconst hasPublicShares = !!dWallet.public_user_secret_key_share;\n\n\t\tlet unverifiedPartialUserSignatureCap: TransactionObjectArgument;\n\n\t\t// Auto-detect signing method based on available shares and parameters\n\t\tif (encryptedUserSecretKeyShare) {\n\t\t\t// Encrypted shares\n\t\t\tunverifiedPartialUserSignatureCap = await this.#requestFutureSign({\n\t\t\t\tverifiedPresignCap,\n\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\tactiveDWallet: dWallet,\n\t\t\t\t\tpresign,\n\t\t\t\t\tencryptedUserSecretKeyShare,\n\t\t\t\t\tmessage,\n\t\t\t\t\thash: hashScheme,\n\t\t\t\t\tsignatureScheme,\n\t\t\t\t\tcurve: fromNumberToCurve(dWallet.curve),\n\t\t\t\t},\n\t\t\t\tikaCoin,\n\t\t\t\tsuiCoin,\n\t\t\t});\n\t\t} else if (secretShare && publicOutput) {\n\t\t\t// Secret share provided\n\t\t\tunverifiedPartialUserSignatureCap = await this.#requestFutureSign({\n\t\t\t\tverifiedPresignCap,\n\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\tactiveDWallet: dWallet,\n\t\t\t\t\tpresign,\n\t\t\t\t\tsecretShare,\n\t\t\t\t\tpublicOutput,\n\t\t\t\t\tmessage,\n\t\t\t\t\thash: hashScheme,\n\t\t\t\t\tsignatureScheme,\n\t\t\t\t\tcurve: fromNumberToCurve(dWallet.curve),\n\t\t\t\t},\n\t\t\t\tikaCoin,\n\t\t\t\tsuiCoin,\n\t\t\t});\n\t\t} else if (hasPublicShares) {\n\t\t\t// Public shares available on DWallet\n\t\t\tthis.#assertDWalletPublicUserSecretKeyShareSet(dWallet);\n\t\t\tthis.#assertDWalletPublicOutputSet(dWallet);\n\n\t\t\tunverifiedPartialUserSignatureCap = await this.#requestFutureSign({\n\t\t\t\tverifiedPresignCap,\n\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\tactiveDWallet: dWallet,\n\t\t\t\t\tpresign,\n\t\t\t\t\t// No need to verify public output in public user-share flows, as there is no zero-trust security in this model.\n\t\t\t\t\tpublicOutput: Uint8Array.from(dWallet.state.Active?.public_output),\n\t\t\t\t\tsecretShare: Uint8Array.from(dWallet.public_user_secret_key_share),\n\t\t\t\t\tmessage,\n\t\t\t\t\thash: hashScheme,\n\t\t\t\t\tsignatureScheme,\n\t\t\t\t\tcurve: fromNumberToCurve(dWallet.curve),\n\t\t\t\t},\n\t\t\t\tikaCoin,\n\t\t\t\tsuiCoin,\n\t\t\t});\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t'DWallet future signing requires either encryptedUserSecretKeyShare, (secretShare + publicOutput), or public_user_secret_key_share on the DWallet',\n\t\t\t);\n\t\t}\n\n\t\treturn unverifiedPartialUserSignatureCap;\n\t}\n\n\t/**\n\t * Request a future sign operation with encrypted shares for Imported Key DWallets and keep capability.\n\t * This creates a partial user signature capability that is returned with the transaction.\n\t *\n\t * @param params.dWallet - The Imported Key DWallet to create the future sign for\n\t * @param params.verifiedPresignCap - The verified presign capability\n\t * @param params.presign - The completed presign object\n\t * @param params.encryptedUserSecretKeyShare - The user's encrypted secret key share\n\t * @param params.message - The message bytes to pre-sign\n\t * @param params.hashScheme - The hash scheme to use for the message\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to the unverified partial user signature capability\n\t */\n\tasync requestFutureSignWithImportedKey({\n\t\tdWallet,\n\t\tverifiedPresignCap,\n\t\tpresign,\n\t\tencryptedUserSecretKeyShare,\n\t\tmessage,\n\t\thashScheme,\n\t\tsignatureScheme,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: ImportedKeyDWallet;\n\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\tpresign: Presign;\n\t\tencryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;\n\t\tmessage: Uint8Array;\n\t\thashScheme: Hash;\n\t\tsignatureScheme: SignatureAlgorithm;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument>;\n\n\t/**\n\t * Request a future sign operation with secret shares for Imported Key DWallets and keep capability.\n\t * This creates a partial user signature capability that is returned with the transaction.\n\t *\n\t * SECURITY WARNING: This method does not verify `secretShare` and `publicOutput`,\n\t * which must be verified by the caller in order to guarantee zero-trust security.\n\t *\n\t * @param params.dWallet - The Imported Key DWallet to create the future sign for\n\t * @param params.verifiedPresignCap - The verified presign capability\n\t * @param params.presign - The completed presign object\n\t * @param params.secretShare - The user's unencrypted secret share\n\t * @param params.publicOutput - The user's public output\n\t * @param params.message - The message bytes to pre-sign\n\t * @param params.hashScheme - The hash scheme to use for the message\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to the unverified partial user signature capability\n\t */\n\tasync requestFutureSignWithImportedKey({\n\t\tdWallet,\n\t\tverifiedPresignCap,\n\t\tpresign,\n\t\tsecretShare,\n\t\tpublicOutput,\n\t\tmessage,\n\t\thashScheme,\n\t\tsignatureScheme,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: ImportedKeyDWallet;\n\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\tpresign: Presign;\n\t\tsecretShare: Uint8Array;\n\t\tpublicOutput: Uint8Array;\n\t\tmessage: Uint8Array;\n\t\thashScheme: Hash;\n\t\tsignatureScheme: SignatureAlgorithm;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument>;\n\n\t/**\n\t * Request a future sign operation with public shares for ImportedShared DWallets and keep capability.\n\t * This creates a partial user signature capability that is returned with the transaction.\n\t * No secret share or public output parameters are needed as they are available on the DWallet.\n\t *\n\t * @param params.dWallet - The ImportedShared DWallet to create the future sign for\n\t * @param params.verifiedPresignCap - The verified presign capability\n\t * @param params.presign - The completed presign object\n\t * @param params.message - The message bytes to pre-sign\n\t * @param params.hashScheme - The hash scheme to use for the message\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to the unverified partial user signature capability\n\t */\n\tasync requestFutureSignWithImportedKey({\n\t\tdWallet,\n\t\tverifiedPresignCap,\n\t\tpresign,\n\t\tmessage,\n\t\thashScheme,\n\t\tsignatureScheme,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: ImportedSharedDWallet;\n\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\tpresign: Presign;\n\t\tmessage: Uint8Array;\n\t\thashScheme: Hash;\n\t\tsignatureScheme: SignatureAlgorithm;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument>;\n\n\t/**\n\t * Universal requestFutureSignWithImportedKey method implementation that automatically detects the Imported Key DWallet type and signing method.\n\t * This method intelligently routes to the appropriate future signing implementation for Imported Key DWallets.\n\t *\n\t * @param params.dWallet - The Imported Key DWallet to create the future sign for (type and share availability auto-detected)\n\t * @param params.verifiedPresignCap - The verified presign capability\n\t * @param params.presign - The completed presign object\n\t * @param params.encryptedUserSecretKeyShare - Optional: encrypted user secret key share (for ImportedKeyDWallet)\n\t * @param params.secretShare - Optional: unencrypted secret share (requires publicOutput, for ImportedKeyDWallet)\n\t * @param params.publicOutput - Optional: public output (required when using secretShare, for ImportedKeyDWallet)\n\t * @param params.message - The message bytes to pre-sign\n\t * @param params.hashScheme - The hash scheme to use for the message\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to unverified partial user signature capability\n\t *\n\t * @example\n\t * // ImportedKeyDWallet - Keep capability (encrypted shares)\n\t * const unverifiedPartialUserSignatureCap = await tx.requestFutureSignWithImportedKey({\n\t *   dWallet, // ImportedKeyDWallet\n\t *   encryptedUserSecretKeyShare,\n\t *   // ... other params\n\t * });\n\t *\n\t * @example\n\t * // ImportedKeyDWallet\n\t * const unverifiedPartialUserSignatureCap = await tx.requestFutureSignWithImportedKey({\n\t *   dWallet, // ImportedKeyDWallet\n\t *   secretShare,\n\t *   publicOutput,\n\t *   // ... other params\n\t * });\n\t *\n\t * @example\n\t * // ImportedSharedDWallet - Public share signing (no secret params needed)\n\t * const unverifiedPartialUserSignatureCap = await tx.requestFutureSignWithImportedKey({\n\t *   dWallet, // ImportedSharedDWallet\n\t *   // ... other params (no secretShare/publicOutput needed)\n\t * });\n\t */\n\tasync requestFutureSignWithImportedKey<S extends SignatureAlgorithm>({\n\t\tdWallet,\n\t\tverifiedPresignCap,\n\t\tpresign,\n\t\tencryptedUserSecretKeyShare,\n\t\tsecretShare,\n\t\tpublicOutput,\n\t\tmessage,\n\t\thashScheme,\n\t\tsignatureScheme,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: ImportedKeyDWallet | ImportedSharedDWallet;\n\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\tpresign: Presign;\n\t\tencryptedUserSecretKeyShare?: EncryptedUserSecretKeyShare;\n\t\tsecretShare?: Uint8Array;\n\t\tpublicOutput?: Uint8Array;\n\t\tmessage: Uint8Array;\n\t\thashScheme: ValidHashForSignature<S>;\n\t\tsignatureScheme: S;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument> {\n\t\t// Validate hash and signature algorithm combination\n\t\tvalidateHashSignatureCombination(hashScheme, signatureScheme);\n\t\tvalidateCurveSignatureAlgorithm(fromNumberToCurve(dWallet.curve), signatureScheme);\n\n\t\t// Auto-detect share availability\n\t\tconst hasPublicShares = !!dWallet.public_user_secret_key_share;\n\n\t\tlet unverifiedPartialUserSignatureCap: TransactionObjectArgument;\n\n\t\t// Auto-detect signing method based on available shares and parameters\n\t\tif (encryptedUserSecretKeyShare) {\n\t\t\t// Encrypted shares\n\t\t\tunverifiedPartialUserSignatureCap = await this.#requestFutureSign({\n\t\t\t\tverifiedPresignCap,\n\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\tactiveDWallet: dWallet,\n\t\t\t\t\tpresign,\n\t\t\t\t\tencryptedUserSecretKeyShare,\n\t\t\t\t\tmessage,\n\t\t\t\t\thash: hashScheme,\n\t\t\t\t\tsignatureScheme,\n\t\t\t\t\tcurve: fromNumberToCurve(dWallet.curve),\n\t\t\t\t},\n\t\t\t\tikaCoin,\n\t\t\t\tsuiCoin,\n\t\t\t});\n\t\t} else if (secretShare && publicOutput) {\n\t\t\t// Secret share provided\n\t\t\tunverifiedPartialUserSignatureCap = await this.#requestFutureSign({\n\t\t\t\tverifiedPresignCap,\n\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\tactiveDWallet: dWallet,\n\t\t\t\t\tpresign,\n\t\t\t\t\tsecretShare,\n\t\t\t\t\tpublicOutput,\n\t\t\t\t\tmessage,\n\t\t\t\t\thash: hashScheme,\n\t\t\t\t\tsignatureScheme,\n\t\t\t\t\tcurve: fromNumberToCurve(dWallet.curve),\n\t\t\t\t},\n\t\t\t\tikaCoin,\n\t\t\t\tsuiCoin,\n\t\t\t});\n\t\t} else if (hasPublicShares) {\n\t\t\t// Public shares available on DWallet\n\t\t\tthis.#assertDWalletPublicUserSecretKeyShareSet(dWallet);\n\t\t\tthis.#assertDWalletPublicOutputSet(dWallet);\n\n\t\t\tunverifiedPartialUserSignatureCap = await this.#requestFutureSign({\n\t\t\t\tverifiedPresignCap,\n\t\t\t\tuserSignatureInputs: {\n\t\t\t\t\tactiveDWallet: dWallet,\n\t\t\t\t\tpresign,\n\t\t\t\t\t// No need to verify public output in public user-share flows, as there is no zero-trust security in this model.\n\t\t\t\t\tpublicOutput: Uint8Array.from(dWallet.state.Active?.public_output),\n\t\t\t\t\tsecretShare: Uint8Array.from(dWallet.public_user_secret_key_share),\n\t\t\t\t\tmessage,\n\t\t\t\t\thash: hashScheme,\n\t\t\t\t\tsignatureScheme,\n\t\t\t\t\tcurve: fromNumberToCurve(dWallet.curve),\n\t\t\t\t},\n\t\t\t\tikaCoin,\n\t\t\t\tsuiCoin,\n\t\t\t});\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t'Imported Key DWallet future signing requires either encryptedUserSecretKeyShare, (secretShare + publicOutput), or public_user_secret_key_share on the DWallet',\n\t\t\t);\n\t\t}\n\n\t\treturn unverifiedPartialUserSignatureCap;\n\t}\n\n\t/**\n\t * Complete a future sign operation using a previously created partial user signature.\n\t * This method takes a partial signature created earlier and combines it with message approval to create a full signature.\n\t *\n\t * @param params.partialUserSignatureCap - The partial user signature capability created by requestFutureSign\n\t * @param params.messageApproval - The message approval from approveMessage\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns The signature ID\n\t */\n\tfutureSign({\n\t\tpartialUserSignatureCap,\n\t\tmessageApproval,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tpartialUserSignatureCap: TransactionObjectArgument | string;\n\t\tmessageApproval: TransactionObjectArgument;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}) {\n\t\treturn coordinatorTx.requestSignWithPartialUserSignatureAndReturnId(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tcoordinatorTx.verifyPartialUserSignatureCap(\n\t\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\t\tthis.#transaction.object(partialUserSignatureCap),\n\t\t\t\tthis.#transaction,\n\t\t\t),\n\t\t\tmessageApproval,\n\t\t\tthis.createSessionIdentifier(),\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\t/**\n\t * Complete a future sign operation for imported key using a previously created partial user signature.\n\t * This method takes a partial signature created earlier and combines it with imported key message approval to create a full signature.\n\t *\n\t * @param params.partialUserSignatureCap - The partial user signature capability created by requestFutureSignWithImportedKey\n\t * @param params.importedKeyMessageApproval - The imported key message approval from approveImportedKeyMessage\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns The signature ID\n\t */\n\tfutureSignWithImportedKey({\n\t\tpartialUserSignatureCap,\n\t\timportedKeyMessageApproval,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tpartialUserSignatureCap: TransactionObjectArgument | string;\n\t\timportedKeyMessageApproval: TransactionObjectArgument | string;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}) {\n\t\treturn coordinatorTx.requestImportedKeySignWithPartialUserSignatureAndReturnId(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tcoordinatorTx.verifyPartialUserSignatureCap(\n\t\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\t\tthis.#transaction.object(partialUserSignatureCap),\n\t\t\t\tthis.#transaction,\n\t\t\t),\n\t\t\timportedKeyMessageApproval,\n\t\t\tthis.createSessionIdentifier(),\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\t/**\n\t * Request verification for an Imported Key DWallet key and keep the capability.\n\t * This method creates a DWallet from an existing cryptographic key that was generated outside the network.\n\t *\n\t * @param params.importDWalletVerificationRequestInput - The prepared verification data from prepareImportedKeyDWalletVerification\n\t * @param params.curve - The elliptic curve identifier used for the imported key\n\t * @param params.signerPublicKey - The public key of the transaction signer\n\t * @param params.sessionIdentifier - Unique session identifier for this operation\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to imported key DWallet capability\n\t */\n\tasync requestImportedKeyDWalletVerification({\n\t\timportDWalletVerificationRequestInput,\n\t\tcurve,\n\t\tsignerPublicKey,\n\t\tsessionIdentifier,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\timportDWalletVerificationRequestInput: ImportDWalletVerificationRequestInput;\n\t\tcurve: Curve;\n\t\tsignerPublicKey: Uint8Array;\n\t\tsessionIdentifier: TransactionObjectArgument;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument> {\n\t\tconst importedKeyDWalletVerificationCap = await this.#requestImportedKeyDwalletVerification({\n\t\t\timportDWalletVerificationRequestInput,\n\t\t\tcurve,\n\t\t\tsignerPublicKey,\n\t\t\tsessionIdentifier,\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t});\n\n\t\treturn importedKeyDWalletVerificationCap;\n\t}\n\n\t/**\n\t * Transfer an encrypted user share from the current user to another address using encrypted shares.\n\t * This re-encrypts the user's share with the destination address's encryption key.\n\t * The encrypted share is automatically decrypted internally.\n\t *\n\t * @param params.dWallet - The DWallet whose user share is being transferred\n\t * @param params.destinationEncryptionKeyAddress - The Sui address that will receive the re-encrypted share\n\t * @param params.sourceEncryptedUserSecretKeyShare - The current user's encrypted secret key share\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to the updated IkaTransaction instance\n\t */\n\tasync requestReEncryptUserShareFor({\n\t\tdWallet,\n\t\tdestinationEncryptionKeyAddress,\n\t\tsourceEncryptedUserSecretKeyShare,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: ZeroTrustDWallet | ImportedKeyDWallet;\n\t\tdestinationEncryptionKeyAddress: string;\n\t\tsourceEncryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<IkaTransaction>;\n\n\t/**\n\t * Transfer an encrypted user share from the current user to another address using unencrypted secret shares.\n\t * This re-encrypts the user's share with the destination address's encryption key.\n\t *\n\t * SECURITY WARNING: This method does not verify `sourceSecretShare`,\n\t * which must be verified by the caller in order to guarantee zero-trust security.\n\t *\n\t * @param params.dWallet - The DWallet whose user share is being transferred\n\t * @param params.destinationEncryptionKeyAddress - The Sui address that will receive the re-encrypted share\n\t * @param params.sourceSecretShare - The current user's unencrypted secret share\n\t * @param params.sourceEncryptedUserSecretKeyShare - The current user's encrypted secret key share\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to the updated IkaTransaction instance\n\t */\n\tasync requestReEncryptUserShareFor({\n\t\tdWallet,\n\t\tdestinationEncryptionKeyAddress,\n\t\tsourceSecretShare,\n\t\tsourceEncryptedUserSecretKeyShare,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: ZeroTrustDWallet | ImportedKeyDWallet;\n\t\tdestinationEncryptionKeyAddress: string;\n\t\tsourceSecretShare: Uint8Array;\n\t\tsourceEncryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<IkaTransaction>;\n\n\t/**\n\t * Universal transferUserShare method implementation.\n\t * This re-encrypts the user's share with the destination address's encryption key.\n\t * When sourceSecretShare is provided, it's used directly; otherwise, the encrypted share is decrypted automatically.\n\t *\n\t * @param params.dWallet - The DWallet whose user share is being transferred\n\t * @param params.destinationEncryptionKeyAddress - The Sui address that will receive the re-encrypted share\n\t * @param params.sourceEncryptedUserSecretKeyShare - The current user's encrypted secret key share\n\t * @param params.sourceSecretShare - Optional: The current user's unencrypted secret share\n\t * @param params.ikaCoin - The IKA coin object to use for transaction fees\n\t * @param params.suiCoin - The SUI coin object to use for gas fees\n\t * @returns Promise resolving to the updated IkaTransaction instance\n\t * @throws {Error} If user share encryption keys are not set\n\t */\n\tasync requestReEncryptUserShareFor({\n\t\tdWallet,\n\t\tdestinationEncryptionKeyAddress,\n\t\tsourceEncryptedUserSecretKeyShare,\n\t\tsourceSecretShare,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: ZeroTrustDWallet | ImportedKeyDWallet;\n\t\tdestinationEncryptionKeyAddress: string;\n\t\tsourceEncryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;\n\t\tsourceSecretShare?: Uint8Array;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<IkaTransaction> {\n\t\tlet finalSourceSecretShare: Uint8Array;\n\n\t\tif (sourceSecretShare) {\n\t\t\t// Use provided secret share directly\n\t\t\tfinalSourceSecretShare = sourceSecretShare;\n\t\t} else {\n\t\t\t// Decrypt the encrypted share automatically\n\t\t\tif (!this.#userShareEncryptionKeys) {\n\t\t\t\tthrow new Error('User share encryption keys are not set');\n\t\t\t}\n\n\t\t\tconst { secretShare: decryptedSecretShare } =\n\t\t\t\tawait this.#userShareEncryptionKeys.decryptUserShare(\n\t\t\t\t\tdWallet,\n\t\t\t\t\tsourceEncryptedUserSecretKeyShare,\n\t\t\t\t\tawait this.#ikaClient.getProtocolPublicParameters(dWallet),\n\t\t\t\t);\n\t\t\tfinalSourceSecretShare = decryptedSecretShare;\n\t\t}\n\n\t\tawait this.#requestReEncryptUserShareFor({\n\t\t\tdWallet,\n\t\t\tdestinationEncryptionKeyAddress,\n\t\t\tsourceEncryptedUserSecretKeyShare,\n\t\t\tsourceSecretShare: finalSourceSecretShare,\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Create a unique session identifier for the current transaction and register it with the coordinator.\n\t *\n\t * @returns The session identifier transaction object argument\n\t */\n\tcreateSessionIdentifier() {\n\t\treturn this.registerSessionIdentifier(createRandomSessionIdentifier());\n\t}\n\n\t/**\n\t * Register a unique session identifier for the current transaction.\n\t *\n\t * @returns The session identifier transaction object argument\n\t */\n\tregisterSessionIdentifier(sessionIdentifier: Uint8Array) {\n\t\treturn coordinatorTx.registerSessionIdentifier(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tsessionIdentifier,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\t/**\n\t * Check if a DWallet with the specified ID exists in the coordinator.\n\t * This is useful for validating DWallet existence before performing operations.\n\t *\n\t * @param params.dwalletId - The ID of the DWallet to check\n\t * @returns Transaction result indicating whether the DWallet exists (returns a boolean)\n\t */\n\thasDWallet({ dwalletId }: { dwalletId: string }): TransactionObjectArgument {\n\t\treturn coordinatorTx.hasDWallet(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tdwalletId,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\t/**\n\t * Get a reference to a DWallet object from the coordinator.\n\t * This returns an immutable reference to the DWallet that can be used in the same transaction.\n\t *\n\t * @param params.dwalletId - The ID of the DWallet to retrieve\n\t * @returns Transaction result containing a reference to the DWallet object\n\t */\n\tgetDWallet({ dwalletId }: { dwalletId: string }): TransactionObjectArgument {\n\t\treturn coordinatorTx.getDWallet(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tdwalletId,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\t#getCoordinatorObjectRef() {\n\t\tif (!this.#coordinatorObjectRef) {\n\t\t\tthis.#coordinatorObjectRef = this.#transaction.sharedObjectRef({\n\t\t\t\tobjectId: this.#ikaClient.ikaConfig.objects.ikaDWalletCoordinator.objectID,\n\t\t\t\tinitialSharedVersion:\n\t\t\t\t\tthis.#ikaClient.ikaConfig.objects.ikaDWalletCoordinator.initialSharedVersion,\n\t\t\t\tmutable: true,\n\t\t\t});\n\t\t}\n\n\t\treturn this.#coordinatorObjectRef;\n\t}\n\n\t// @ts-expect-error - TODO: Add system functions\n\t#getSystemObjectRef() {\n\t\tif (!this.#systemObjectRef) {\n\t\t\tthis.#systemObjectRef = this.#transaction.sharedObjectRef({\n\t\t\t\tobjectId: this.#ikaClient.ikaConfig.objects.ikaSystemObject.objectID,\n\t\t\t\tinitialSharedVersion:\n\t\t\t\t\tthis.#ikaClient.ikaConfig.objects.ikaSystemObject.initialSharedVersion,\n\t\t\t\tmutable: true,\n\t\t\t});\n\t\t}\n\n\t\treturn this.#systemObjectRef;\n\t}\n\n\t#assertDWalletPublicOutputSet(\n\t\tdWallet: DWallet,\n\t): asserts dWallet is DWallet & { state: { Active: { public_output: Uint8Array } } } {\n\t\tif (!dWallet.state.Active?.public_output) {\n\t\t\tthrow new Error('DWallet public output is not set');\n\t\t}\n\t}\n\n\t#assertDWalletPublicUserSecretKeyShareSet(\n\t\tdWallet: DWallet,\n\t): asserts dWallet is DWallet & { public_user_secret_key_share: Uint8Array } {\n\t\tif (!dWallet.public_user_secret_key_share) {\n\t\t\tthrow new Error('DWallet public user secret key share is not set');\n\t\t}\n\t}\n\n\t#assertPresignCompleted(\n\t\tpresign: Presign,\n\t): asserts presign is Presign & { state: { Completed: { presign: Uint8Array } } } {\n\t\tif (!presign.state.Completed?.presign) {\n\t\t\tthrow new Error('Presign is not completed');\n\t\t}\n\t}\n\n\tasync #verifySecretShare({\n\t\tcurve,\n\t\tverifiedPublicOutput,\n\t\tsecretShare,\n\t\tpublicParameters,\n\t}: {\n\t\tcurve: Curve;\n\t\tverifiedPublicOutput: Uint8Array;\n\t\tsecretShare: Uint8Array;\n\t\tpublicParameters: Uint8Array;\n\t}) {\n\t\tconst userShareVerified = verifyUserShare(\n\t\t\tcurve,\n\t\t\tsecretShare,\n\t\t\tverifiedPublicOutput,\n\t\t\tpublicParameters,\n\t\t);\n\n\t\tif (!userShareVerified) {\n\t\t\tthrow new Error('User share verification failed');\n\t\t}\n\t}\n\n\tasync #decryptAndVerifySecretShare({\n\t\tdWallet,\n\t\tencryptedUserSecretKeyShare,\n\t\tpublicParameters: publicParametersFromParam,\n\t}: {\n\t\tdWallet: DWallet;\n\t\tencryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;\n\t\tpublicParameters?: Uint8Array;\n\t}): Promise<{\n\t\tpublicParameters: Uint8Array;\n\t\tsecretShare: Uint8Array;\n\t\tverifiedPublicOutput: Uint8Array;\n\t}> {\n\t\t// This needs to be like this because of the way the type system is set up in typescript.\n\t\tif (!this.#userShareEncryptionKeys) {\n\t\t\tthrow new Error('User share encryption keys are not set');\n\t\t}\n\n\t\tconst publicParameters =\n\t\t\tpublicParametersFromParam ?? (await this.#ikaClient.getProtocolPublicParameters(dWallet));\n\n\t\tconst { secretShare, verifiedPublicOutput } =\n\t\t\tawait this.#userShareEncryptionKeys.decryptUserShare(\n\t\t\t\tdWallet,\n\t\t\t\tencryptedUserSecretKeyShare,\n\t\t\t\tpublicParameters,\n\t\t\t);\n\n\t\tawait this.#verifySecretShare({\n\t\t\tcurve: fromNumberToCurve(dWallet.curve),\n\t\t\tverifiedPublicOutput,\n\t\t\tsecretShare,\n\t\t\tpublicParameters,\n\t\t});\n\n\t\treturn { publicParameters, secretShare, verifiedPublicOutput };\n\t}\n\n\t#requestPresign({\n\t\tdWallet,\n\t\tsignatureAlgorithm,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: DWallet;\n\t\tsignatureAlgorithm: SignatureAlgorithm;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}) {\n\t\tconst { signatureAlgorithmNumber } = fromCurveAndSignatureAlgorithmToNumbers(\n\t\t\tfromNumberToCurve(dWallet.curve),\n\t\t\tsignatureAlgorithm,\n\t\t);\n\n\t\treturn coordinatorTx.requestPresign(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tdWallet.id.id,\n\t\t\tsignatureAlgorithmNumber,\n\t\t\tthis.createSessionIdentifier(),\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\t#requestGlobalPresign({\n\t\tdwalletNetworkEncryptionKeyId,\n\t\tcurve,\n\t\tsignatureAlgorithm,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdwalletNetworkEncryptionKeyId: string;\n\t\tcurve: Curve;\n\t\tsignatureAlgorithm: SignatureAlgorithm;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}) {\n\t\tconst { curveNumber, signatureAlgorithmNumber } = fromCurveAndSignatureAlgorithmToNumbers(\n\t\t\tcurve,\n\t\t\tsignatureAlgorithm,\n\t\t);\n\n\t\treturn coordinatorTx.requestGlobalPresign(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tdwalletNetworkEncryptionKeyId,\n\t\t\tcurveNumber,\n\t\t\tsignatureAlgorithmNumber,\n\t\t\tthis.createSessionIdentifier(),\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\tasync #getUserSignMessage({\n\t\tuserSignatureInputs,\n\t\tsignDuringDKG = false,\n\t}: {\n\t\tuserSignatureInputs: UserSignatureInputs;\n\t\tsignDuringDKG?: boolean;\n\t}): Promise<Uint8Array> {\n\t\tthis.#assertPresignCompleted(userSignatureInputs.presign);\n\n\t\tconst publicParameters = await this.#ikaClient.getProtocolPublicParameters(\n\t\t\tuserSignatureInputs.activeDWallet,\n\t\t\tuserSignatureInputs.curve,\n\t\t);\n\n\t\tlet secretShare, publicOutput;\n\n\t\tif (userSignatureInputs.activeDWallet) {\n\t\t\t// If the dWallet is a public user-share dWallet, we use the public user secret key share. It is a different trust assumption in which no zero-trust security is assured.\n\t\t\t// Otherwise, we use the secret share from the user signature inputs.\n\t\t\tif (\n\t\t\t\tuserSignatureInputs.activeDWallet.public_user_secret_key_share &&\n\t\t\t\tuserSignatureInputs.activeDWallet.state.Active?.public_output\n\t\t\t) {\n\t\t\t\tsecretShare = Uint8Array.from(\n\t\t\t\t\tuserSignatureInputs.activeDWallet.public_user_secret_key_share,\n\t\t\t\t);\n\t\t\t\tpublicOutput = Uint8Array.from(\n\t\t\t\t\tuserSignatureInputs.activeDWallet.state.Active?.public_output,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconst userSecretKeyShareResponse = await this.#getUserSecretKeyShare({\n\t\t\t\t\tsecretShare: userSignatureInputs.secretShare,\n\t\t\t\t\tencryptedUserSecretKeyShare: userSignatureInputs.encryptedUserSecretKeyShare,\n\t\t\t\t\tactiveDWallet: userSignatureInputs.activeDWallet,\n\t\t\t\t\tpublicParameters,\n\t\t\t\t\tpublicOutput: userSignatureInputs.publicOutput,\n\t\t\t\t});\n\n\t\t\t\tsecretShare = userSecretKeyShareResponse.secretShare;\n\t\t\t\tpublicOutput = userSecretKeyShareResponse.verifiedPublicOutput;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!userSignatureInputs.secretShare || !userSignatureInputs.publicOutput) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Secret share and public output are required when activeDWallet is not set',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tsecretShare = userSignatureInputs.secretShare;\n\t\t\tpublicOutput = userSignatureInputs.publicOutput;\n\n\t\t\tif (!signDuringDKG) {\n\t\t\t\tif (!userSignatureInputs.curve) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Curve is required when providing explicit secret share and public output without activeDWallet',\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tawait this.#verifySecretShare({\n\t\t\t\t\tcurve: userSignatureInputs.curve,\n\t\t\t\t\tverifiedPublicOutput: publicOutput,\n\t\t\t\t\tsecretShare,\n\t\t\t\t\tpublicParameters: publicParameters,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn this.#createUserSignMessageWithPublicOutput({\n\t\t\tprotocolPublicParameters: publicParameters,\n\t\t\tpublicOutput,\n\t\t\tuserSecretKeyShare: secretShare,\n\t\t\tpresign: userSignatureInputs.presign.state.Completed?.presign,\n\t\t\tmessage: userSignatureInputs.message,\n\t\t\thash: userSignatureInputs.hash,\n\t\t\tsignatureScheme: userSignatureInputs.signatureScheme,\n\t\t\tcurve: userSignatureInputs.curve,\n\t\t\tcreateWithCentralizedOutput: userSignatureInputs.createWithCentralizedOutput,\n\t\t});\n\t}\n\n\tasync #requestSign({\n\t\tverifiedPresignCap,\n\t\tmessageApproval,\n\t\tuserSignatureInputs,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\tmessageApproval: TransactionObjectArgument;\n\t\tuserSignatureInputs: UserSignatureInputs;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument> {\n\t\tconst userSignMessage = await this.#getUserSignMessage({\n\t\t\tuserSignatureInputs,\n\t\t});\n\n\t\treturn coordinatorTx.requestSignAndReturnId(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tverifiedPresignCap,\n\t\t\tmessageApproval,\n\t\t\tuserSignMessage,\n\t\t\tthis.createSessionIdentifier(),\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\tasync #requestFutureSign({\n\t\tverifiedPresignCap,\n\t\tuserSignatureInputs,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\tuserSignatureInputs: UserSignatureInputs;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}) {\n\t\tif (!userSignatureInputs.activeDWallet) {\n\t\t\tthrow new Error('Active DWallet is required');\n\t\t}\n\n\t\tconst userSignMessage = await this.#getUserSignMessage({\n\t\t\tuserSignatureInputs,\n\t\t});\n\n\t\tconst { hashNumber } = fromCurveAndSignatureAlgorithmAndHashToNumbers(\n\t\t\tuserSignatureInputs.curve,\n\t\t\tuserSignatureInputs.signatureScheme,\n\t\t\tuserSignatureInputs.hash,\n\t\t);\n\n\t\treturn coordinatorTx.requestFutureSign(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tuserSignatureInputs.activeDWallet.id.id,\n\t\t\tverifiedPresignCap,\n\t\t\tuserSignatureInputs.message,\n\t\t\thashNumber,\n\t\t\tuserSignMessage,\n\t\t\tthis.createSessionIdentifier(),\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\tasync #requestImportedKeySign({\n\t\tverifiedPresignCap,\n\t\timportedKeyMessageApproval,\n\t\tuserSignatureInputs,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tverifiedPresignCap: TransactionObjectArgument;\n\t\timportedKeyMessageApproval: TransactionObjectArgument;\n\t\tuserSignatureInputs: UserSignatureInputs;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}): Promise<TransactionObjectArgument> {\n\t\tconst userSignMessage = await this.#getUserSignMessage({\n\t\t\tuserSignatureInputs,\n\t\t});\n\n\t\treturn coordinatorTx.requestImportedKeySignAndReturnId(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tverifiedPresignCap,\n\t\t\timportedKeyMessageApproval,\n\t\t\tuserSignMessage,\n\t\t\tthis.createSessionIdentifier(),\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\tasync #getUserSecretKeyShare({\n\t\tsecretShare,\n\t\tencryptedUserSecretKeyShare,\n\t\tactiveDWallet,\n\t\tpublicParameters,\n\t\tpublicOutput,\n\t}: {\n\t\tsecretShare?: Uint8Array;\n\t\tencryptedUserSecretKeyShare?: EncryptedUserSecretKeyShare;\n\t\tactiveDWallet: DWallet;\n\t\tpublicParameters: Uint8Array;\n\t\tpublicOutput?: Uint8Array;\n\t}): Promise<{\n\t\tsecretShare: Uint8Array;\n\t\tverifiedPublicOutput: Uint8Array;\n\t}> {\n\t\tif (secretShare) {\n\t\t\tif (!publicOutput) {\n\t\t\t\tthrow new Error('Public output is required when providing secret share directly');\n\t\t\t}\n\n\t\t\treturn { secretShare, verifiedPublicOutput: publicOutput };\n\t\t}\n\n\t\tif (!encryptedUserSecretKeyShare) {\n\t\t\tthrow new Error('Encrypted user secret key share is not set');\n\t\t}\n\n\t\tif (!this.#userShareEncryptionKeys) {\n\t\t\tthrow new Error('User share encryption keys are not set');\n\t\t}\n\n\t\treturn this.#decryptAndVerifySecretShare({\n\t\t\tdWallet: activeDWallet,\n\t\t\tencryptedUserSecretKeyShare,\n\t\t\tpublicParameters,\n\t\t});\n\t}\n\n\tasync #requestReEncryptUserShareFor({\n\t\tdWallet,\n\t\tdestinationEncryptionKeyAddress,\n\t\tsourceEncryptedUserSecretKeyShare,\n\t\tsourceSecretShare,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\tdWallet: DWallet;\n\t\tdestinationEncryptionKeyAddress: string;\n\t\tsourceEncryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;\n\t\tsourceSecretShare: Uint8Array;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}) {\n\t\tif (!sourceEncryptedUserSecretKeyShare.state.KeyHolderSigned?.user_output_signature) {\n\t\t\tthrow new Error('User output signature is not set');\n\t\t}\n\n\t\tconst publicParameters = await this.#ikaClient.getProtocolPublicParameters(dWallet);\n\n\t\tconst destinationEncryptionKeyObj = await this.#ikaClient.getActiveEncryptionKey(\n\t\t\tdestinationEncryptionKeyAddress,\n\t\t);\n\n\t\tconst publicKey = new Ed25519PublicKey(\n\t\t\tnew Uint8Array(destinationEncryptionKeyObj.signer_public_key),\n\t\t);\n\n\t\tif (\n\t\t\t!(await publicKey.verify(\n\t\t\t\tUint8Array.from(destinationEncryptionKeyObj.encryption_key),\n\t\t\t\tUint8Array.from(destinationEncryptionKeyObj.encryption_key_signature),\n\t\t\t))\n\t\t) {\n\t\t\tthrow new Error('Destination encryption key signature is not valid');\n\t\t}\n\n\t\tif (publicKey.toSuiAddress() !== destinationEncryptionKeyObj.signer_address) {\n\t\t\tthrow new Error('Destination encryption key address does not match the public key');\n\t\t}\n\n\t\treturn coordinatorTx.requestReEncryptUserShareFor(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\tdWallet.id.id,\n\t\t\tdestinationEncryptionKeyAddress,\n\t\t\tawait encryptSecretShare(\n\t\t\t\tfromNumberToCurve(destinationEncryptionKeyObj.curve),\n\t\t\t\tsourceSecretShare,\n\t\t\t\tnew Uint8Array(destinationEncryptionKeyObj.encryption_key),\n\t\t\t\tpublicParameters,\n\t\t\t),\n\t\t\tsourceEncryptedUserSecretKeyShare.id.id,\n\t\t\tthis.createSessionIdentifier(),\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\tasync #requestImportedKeyDwalletVerification({\n\t\timportDWalletVerificationRequestInput,\n\t\tcurve,\n\t\tsignerPublicKey,\n\t\tsessionIdentifier,\n\t\tikaCoin,\n\t\tsuiCoin,\n\t}: {\n\t\timportDWalletVerificationRequestInput: ImportDWalletVerificationRequestInput;\n\t\tcurve: Curve;\n\t\tsignerPublicKey: Uint8Array;\n\t\tsessionIdentifier: TransactionObjectArgument;\n\t\tikaCoin: TransactionObjectArgument;\n\t\tsuiCoin: TransactionObjectArgument;\n\t}) {\n\t\t// This needs to be like this because of the way the type system is set up in typescript.\n\t\tif (!this.#userShareEncryptionKeys) {\n\t\t\tthrow new Error('User share encryption keys are not set');\n\t\t}\n\n\t\treturn coordinatorTx.requestImportedKeyDwalletVerification(\n\t\t\tthis.#ikaClient.ikaConfig,\n\t\t\tthis.#getCoordinatorObjectRef(),\n\t\t\t(await this.#ikaClient.getConfiguredNetworkEncryptionKey()).id,\n\t\t\tfromCurveToNumber(curve),\n\t\t\timportDWalletVerificationRequestInput.userMessage,\n\t\t\timportDWalletVerificationRequestInput.encryptedUserShareAndProof,\n\t\t\tthis.#userShareEncryptionKeys.getSuiAddress(),\n\t\t\timportDWalletVerificationRequestInput.userPublicOutput,\n\t\t\tsignerPublicKey,\n\t\t\tsessionIdentifier,\n\t\t\tikaCoin,\n\t\t\tsuiCoin,\n\t\t\tthis.#transaction,\n\t\t);\n\t}\n\n\tasync #createUserSignMessageWithPublicOutput({\n\t\tprotocolPublicParameters,\n\t\tpublicOutput,\n\t\tuserSecretKeyShare,\n\t\tpresign,\n\t\tmessage,\n\t\thash,\n\t\tsignatureScheme,\n\t\tcurve,\n\t\tcreateWithCentralizedOutput,\n\t}: {\n\t\tprotocolPublicParameters: Uint8Array;\n\t\tpublicOutput: Uint8Array;\n\t\tuserSecretKeyShare: Uint8Array;\n\t\tpresign: Uint8Array;\n\t\tmessage: Uint8Array;\n\t\thash: Hash;\n\t\tsignatureScheme: SignatureAlgorithm;\n\t\tcurve: Curve;\n\t\tcreateWithCentralizedOutput?: boolean;\n\t}): Promise<Uint8Array> {\n\t\tconst { curveNumber, signatureAlgorithmNumber, hashNumber } =\n\t\t\tfromCurveAndSignatureAlgorithmAndHashToNumbers(curve, signatureScheme, hash);\n\n\t\tif (createWithCentralizedOutput) {\n\t\t\treturn new Uint8Array(\n\t\t\t\tawait create_sign_with_centralized_output(\n\t\t\t\t\tprotocolPublicParameters,\n\t\t\t\t\tpublicOutput,\n\t\t\t\t\tuserSecretKeyShare,\n\t\t\t\t\tpresign,\n\t\t\t\t\tmessage,\n\t\t\t\t\thashNumber,\n\t\t\t\t\tsignatureAlgorithmNumber,\n\t\t\t\t\tcurveNumber,\n\t\t\t\t),\n\t\t\t);\n\t\t} else {\n\t\t\treturn new Uint8Array(\n\t\t\t\tawait create_sign(\n\t\t\t\t\tprotocolPublicParameters,\n\t\t\t\t\tpublicOutput,\n\t\t\t\t\tuserSecretKeyShare,\n\t\t\t\t\tpresign,\n\t\t\t\t\tmessage,\n\t\t\t\t\thashNumber,\n\t\t\t\t\tsignatureAlgorithmNumber,\n\t\t\t\t\tcurveNumber,\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\t#assertCanRunNormalPresign(dWallet: DWallet, signatureAlgorithm: SignatureAlgorithm) {\n\t\tif (\n\t\t\tdWallet.is_imported_key_dwallet &&\n\t\t\t(signatureAlgorithm === SignatureAlgorithm.ECDSASecp256k1 ||\n\t\t\t\tsignatureAlgorithm === SignatureAlgorithm.ECDSASecp256r1)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst dWalletVersion = dWallet.state.Active?.public_output?.[0] ?? 0 + 1;\n\n\t\tif (\n\t\t\t!dWallet.is_imported_key_dwallet &&\n\t\t\tdWallet.state.Active?.public_output &&\n\t\t\tdWalletVersion === 1 && // v1 dwallet\n\t\t\tsignatureAlgorithm === SignatureAlgorithm.ECDSASecp256k1\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error(\n\t\t\t'You can call this function for ecdsa signatures only, and if this is imported key dwallet, or the version is 1',\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
