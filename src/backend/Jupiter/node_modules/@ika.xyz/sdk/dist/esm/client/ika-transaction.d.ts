import type { Transaction, TransactionObjectArgument, TransactionResult } from '@mysten/sui/transactions';
import type { DKGRequestInput, ImportDWalletVerificationRequestInput } from './cryptography.js';
import type { ValidHashForSignature, ValidSignatureAlgorithmForCurve } from './hash-signature-validation.js';
import type { IkaClient } from './ika-client.js';
import type { Curve, DWallet, EncryptedUserSecretKeyShare, EncryptionKey, Hash, ImportedKeyDWallet, ImportedSharedDWallet, Presign, SharedDWallet, ZeroTrustDWallet } from './types.js';
import { SignatureAlgorithm } from './types.js';
import type { UserShareEncryptionKeys } from './user-share-encryption-keys.js';
/**
 * Parameters for creating an IkaTransaction instance
 */
export interface IkaTransactionParams {
    /** The IkaClient instance to use for blockchain interactions */
    ikaClient: IkaClient;
    /** The Sui transaction to wrap */
    transaction: Transaction;
    /** Optional user share encryption keys for cryptographic operations */
    userShareEncryptionKeys?: UserShareEncryptionKeys;
}
/**
 * IkaTransaction class provides a high-level interface for interacting with the Ika network.
 * It wraps Sui transactions and provides methods for DWallet operations including DKG,
 * presigning, signing, and key management.
 */
export declare class IkaTransaction {
    #private;
    /**
     * Creates a new IkaTransaction instance
     * @param params.ikaClient - The IkaClient instance for network operations
     * @param params.transaction - The Sui transaction builder to wrap
     * @param params.userShareEncryptionKeys - Optional encryption keys for user share operations
     */
    constructor({ ikaClient, transaction, userShareEncryptionKeys }: IkaTransactionParams);
    /**
     * @deprecated This method is deprecated. Use `requestDWalletDKG` or `requestDWalletDKGWithPublicUserShare` instead.
     *
     * Request the DKG (Distributed Key Generation) first round with automatic decryption key ID fetching.
     * This initiates the creation of a new DWallet through a distributed key generation process.
     *
     * @param params.curve - The elliptic curve identifier to use for key generation
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Promise resolving to a DWallet capability
     * @throws {Error} If the decryption key ID cannot be fetched
     */
    requestDWalletDKGFirstRoundAsync(_params: {
        curve: Curve;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): Promise<TransactionObjectArgument>;
    /**
     * @deprecated This method is deprecated. Use `requestDWalletDKG` or `requestDWalletDKGWithPublicUserShare` instead.
     *
     * Request the DKG (Distributed Key Generation) first round with explicit decryption key ID.
     * This initiates the creation of a new DWallet through a distributed key generation process.
     *
     * @param params.curve - The elliptic curve identifier to use for key generation
     * @param params.networkEncryptionKeyID - The specific network encryption key ID to use
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns DWallet capability
     */
    requestDWalletDKGFirstRound(_params: {
        curve: Curve;
        networkEncryptionKeyID: string;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): TransactionObjectArgument;
    /**
     * @deprecated This method is deprecated. Use `requestDWalletDKG` or `requestDWalletDKGWithPublicUserShare` instead.
     *
     * Request the DKG (Distributed Key Generation) second round to complete DWallet creation.
     * This finalizes the distributed key generation process started in the first round.
     *
     * @param params.dWalletCap - The dWalletCap object from the first round, created for dWallet
     * @param params.dkgSecondRoundRequestInput - Cryptographic data prepared for the second round
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns The updated IkaTransaction instance
     * @throws {Error} If user share encryption keys are not set
     */
    requestDWalletDKGSecondRound(_params: {
        dWalletCap: TransactionObjectArgument | string;
        dkgSecondRoundRequestInput: DKGRequestInput;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): void;
    /**
     * Request the DKG (Distributed Key Generation) to create a dWallet.
     *
     * @param params.dkgRequestInput - Cryptographic data prepared for the DKG
     * @param params.sessionIdentifier - The session identifier object
     * @param params.dwalletNetworkEncryptionKeyId - The dWallet network encryption key ID
     * @param params.signDuringDKGRequest - The sign during DKG request (hash must be valid for signature algorithm)
     * @param params.curve - The curve
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     *
     * @returns The DWallet capability and sign id if signDuringDKGRequest is provided
     * @throws {Error} If user share encryption keys are not set
     */
    requestDWalletDKG<S extends SignatureAlgorithm = never>({ dkgRequestInput, ikaCoin, suiCoin, sessionIdentifier, dwalletNetworkEncryptionKeyId, signDuringDKGRequest, curve, }: {
        dkgRequestInput: DKGRequestInput;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
        sessionIdentifier: TransactionObjectArgument;
        dwalletNetworkEncryptionKeyId: string;
        signDuringDKGRequest?: S extends never ? never : {
            message: Uint8Array;
            presign: Presign;
            verifiedPresignCap: TransactionObjectArgument;
            hashScheme: ValidHashForSignature<S>;
            signatureAlgorithm: S;
        };
        curve: Curve;
    }): Promise<TransactionResult>;
    /**
     * Request the DKG (Distributed Key Generation) with public user share to create a dWallet.
     *
     * @param params.sessionIdentifier - The session identifier object ID
     * @param params.dwalletNetworkEncryptionKeyId - The dWallet network encryption key ID
     * @param params.curve - The curve
     * @param params.publicKeyShareAndProof - The public key share and proof
     * @param params.publicUserSecretKeyShare - The public user secret key share
     * @param params.signDuringDKGRequest - The sign during DKG request (hash must be valid for signature algorithm)
     * @param params.userPublicOutput - The user's public output from the DKG process
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     *
     * @returns The DWallet capability and sign id if signDuringDKGRequest is provided
     * @throws {Error} If user share encryption keys are not set
     */
    requestDWalletDKGWithPublicUserShare<S extends SignatureAlgorithm = never>({ sessionIdentifier, dwalletNetworkEncryptionKeyId, curve, publicKeyShareAndProof, publicUserSecretKeyShare, signDuringDKGRequest, userPublicOutput, ikaCoin, suiCoin, }: {
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
        sessionIdentifier: TransactionObjectArgument;
        dwalletNetworkEncryptionKeyId: string;
        curve: Curve;
        publicKeyShareAndProof: Uint8Array;
        publicUserSecretKeyShare: Uint8Array;
        userPublicOutput: Uint8Array;
        signDuringDKGRequest?: S extends never ? never : {
            message: Uint8Array;
            presign: Presign;
            verifiedPresignCap: TransactionObjectArgument;
            hashScheme: ValidHashForSignature<S>;
            signatureAlgorithm: S;
        };
    }): Promise<TransactionResult>;
    /**
     * This completes the user's participation in the DKG process by accepting their encrypted share.
     *
     * @param params.dWallet - The DWallet object to accept the share for
     * @param params.userPublicOutput - The user's public output from the DKG process, this is used to verify the user's public output signature.
     * @param params.encryptedUserSecretKeyShareId - The ID of the encrypted user secret key share
     * @returns Promise resolving to the updated IkaTransaction instance
     * @throws {Error} If user share encryption keys are not set
     */
    acceptEncryptedUserShare({ dWallet, userPublicOutput, encryptedUserSecretKeyShareId, }: {
        dWallet: ZeroTrustDWallet | ImportedKeyDWallet;
        userPublicOutput: Uint8Array;
        encryptedUserSecretKeyShareId: string;
    }): Promise<IkaTransaction>;
    /**
     * Accept an encrypted user share for a transferred DWallet.
     * This completes the user's participation in the DKG process by accepting their encrypted share.
     *
     * SECURITY WARNING: `sourceEncryptionKey` shouldn't be fetched from the network;
     * the public key of the sender (or its address) should be known to the receiver,
     * so that the verification here would be impactful.
     *
     * @param params.dWallet - The DWallet object to accept the share for
     * @param params.sourceEncryptionKey - The encryption key used to encrypt the user's secret share.
     * @param params.sourceEncryptedUserSecretKeyShare - The encrypted user secret key share.
     * @param params.destinationEncryptedUserSecretKeyShare - The encrypted user secret key share.
     * @returns Promise resolving to the updated IkaTransaction instance
     * @throws {Error} If user share encryption keys are not set
     */
    acceptEncryptedUserShare({ dWallet, sourceEncryptionKey, sourceEncryptedUserSecretKeyShare, destinationEncryptedUserSecretKeyShare, }: {
        dWallet: ZeroTrustDWallet | ImportedKeyDWallet;
        sourceEncryptionKey: EncryptionKey;
        sourceEncryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;
        destinationEncryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;
    }): Promise<IkaTransaction>;
    /**
     * Register an encryption key for the current user on the specified curve.
     * This allows the user to participate in encrypted operations on the network.
     *
     * @param params.curve - The elliptic curve identifier to register the key for
     * @returns Promise resolving to the updated IkaTransaction instance
     * @throws {Error} If user share encryption keys are not set
     */
    registerEncryptionKey({ curve }: {
        curve: Curve;
    }): Promise<this>;
    /**
     * Make the DWallet user secret key shares public, allowing them to be used without decryption.
     * This is useful for scenarios where the secret share can be publicly accessible.
     *
     * @param params.dWallet - The DWallet to make the shares public for
     * @param params.secretShare - The secret share data to make public
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns The updated IkaTransaction instance
     */
    makeDWalletUserSecretKeySharesPublic({ dWallet, secretShare, ikaCoin, suiCoin, }: {
        dWallet: ZeroTrustDWallet | ImportedKeyDWallet;
        secretShare: Uint8Array;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): this;
    /**
     * Request a presign operation for a DWallet.
     * Presigning allows for faster signature generation by pre-computing part of the signature.
     *
     * If you are using ecdsa(k1,r1) and imported key dwallet, you must call this function always
     * If you are using schnor, schnorrkell, eddsa, taproot, call requestGlobalPresign instead
     *
     * @param params.dWallet - The DWallet to create the presign for
     * @param params.signatureAlgorithm - The signature algorithm identifier to use
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Unverified presign capability
     */
    requestPresign({ dWallet, signatureAlgorithm, ikaCoin, suiCoin, }: {
        dWallet: DWallet;
        signatureAlgorithm: SignatureAlgorithm;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): TransactionObjectArgument;
    /**
     * Request a global presign operation.
     * If you are using ecdsa(k1,r1) and imported key dwallet, instead call requestPresign
     * If you are using schnor, schnorrkell, eddsa, taproot, call this function always
     *
     * @param params.dwalletNetworkEncryptionKeyId - The network encryption key ID to use for the presign
     * @param params.curve - The curve to use for the presign
     * @param params.signatureAlgorithm - The signature algorithm to use (must be valid for the curve)
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Unverified presign capability
     */
    requestGlobalPresign<C extends Curve>({ dwalletNetworkEncryptionKeyId, curve, signatureAlgorithm, ikaCoin, suiCoin, }: {
        dwalletNetworkEncryptionKeyId: string;
        curve: C;
        signatureAlgorithm: ValidSignatureAlgorithmForCurve<C>;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): TransactionObjectArgument;
    /**
     * Approve a message for signing with a DWallet.
     * This creates an approval object that can be used in subsequent signing operations.
     *
     * @param params.dWalletCap - The dWalletCap object, that owns the dWallet
     * @param params.curve - The curve to use for the approval
     * @param params.signatureAlgorithm - The signature algorithm to use (must be valid for the curve)
     * @param params.hashScheme - The hash scheme to apply to the message (must be valid for the signature algorithm)
     * @param params.message - The message bytes to approve for signing
     * @returns Message approval
     */
    approveMessage<C extends Curve, S extends ValidSignatureAlgorithmForCurve<C>>({ dWalletCap, curve, signatureAlgorithm, hashScheme, message, }: {
        dWalletCap: TransactionObjectArgument | string;
        curve: C;
        signatureAlgorithm: S;
        hashScheme: ValidHashForSignature<S>;
        message: Uint8Array;
    }): TransactionObjectArgument;
    /**
     * Verify a presign capability to ensure it can be used for signing.
     * This converts an unverified presign capability into a verified one.
     *
     * @param params.presign - The presign object to verify
     * @returns Verified presign capability
     */
    verifyPresignCap({ presign }: {
        presign: Presign;
    }): TransactionObjectArgument;
    /**
     * Verify a presign capability to ensure it can be used for signing.
     * This converts an unverified presign capability into a verified one.
     *
     * @param params.unverifiedPresignCap - The unverified presign capability object or ID
     * @returns Verified presign capability
     */
    verifyPresignCap({ unverifiedPresignCap, }: {
        unverifiedPresignCap: TransactionObjectArgument | string;
    }): TransactionObjectArgument;
    /**
     * Approve a message for signing with an imported key DWallet.
     * This is similar to approveMessage but specifically for DWallets created with imported keys.
     *
     * @param params.dWalletCap - The dWalletCap object, that owns the dWallet
     * @param params.curve - The curve to use for the approval
     * @param params.signatureAlgorithm - The signature algorithm to use (must be valid for the curve)
     * @param params.hashScheme - The hash scheme to apply to the message (must be valid for the signature algorithm)
     * @param params.message - The message bytes to approve for signing
     * @returns Imported key message approval
     */
    approveImportedKeyMessage<C extends Curve, S extends ValidSignatureAlgorithmForCurve<C>>({ dWalletCap, curve, signatureAlgorithm, hashScheme, message, }: {
        dWalletCap: TransactionObjectArgument | string;
        curve: C;
        signatureAlgorithm: S;
        hashScheme: ValidHashForSignature<S>;
        message: Uint8Array;
    }): TransactionObjectArgument;
    /**
     * Sign a message using a DWallet.
     * This performs the actual signing operation using the presign and user's share (encrypted, secret, or public).
     * Only supports ZeroTrust and Shared DWallets. For Imported Key DWallets, use requestSignWithImportedKey instead.
     *
     * SECURITY WARNING: When using unencrypted shares, this method does not verify `secretShare` and `publicOutput`,
     * which must be verified by the caller in order to guarantee zero-trust security.
     *
     * @param params.dWallet - The DWallet to sign with (ZeroTrust or Shared DWallet)
     * @param params.messageApproval - Message approval
     * @param params.hashScheme - The hash scheme used for the message (must be valid for the signature algorithm)
     * @param params.verifiedPresignCap - The verified presign capability
     * @param params.presign - The completed presign object
     * @param params.encryptedUserSecretKeyShare - Optional: encrypted user secret key share (for ZeroTrust DWallets)
     * @param params.secretShare - Optional: unencrypted secret share (requires publicOutput, for ZeroTrust DWallets)
     * @param params.publicOutput - Optional: public output (required when using secretShare, for ZeroTrust DWallets)
     * @param params.message - The message bytes to sign
     * @param params.signatureScheme - The signature algorithm to use
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Promise resolving to the signature ID
     *
     * @example
     * // ZeroTrust DWallet - Zero-trust signing (encrypted shares)
     * const signatureId = await tx.requestSign({
     *   dWallet, // ZeroTrustDWallet
     *   messageApproval,
     *   encryptedUserSecretKeyShare,
     *   // ... other params
     * });
     *
     * @example
     * // ZeroTrust DWallet - Secret share signing
     * const signatureId = await tx.requestSign({
     *   dWallet, // ZeroTrustDWallet
     *   messageApproval,
     *   secretShare,
     *   publicOutput,
     *   // ... other params
     * });
     *
     * @example
     * // Shared DWallet - Public share signing (no secret params needed)
     * const signatureId = await tx.requestSign({
     *   dWallet, // SharedDWallet
     *   messageApproval,
     *   // ... other params (no secretShare/publicOutput needed)
     * });
     */
    requestSign<S extends SignatureAlgorithm>({ dWallet, messageApproval, hashScheme, verifiedPresignCap, presign, encryptedUserSecretKeyShare, secretShare, publicOutput, message, signatureScheme, ikaCoin, suiCoin, }: {
        dWallet: ZeroTrustDWallet | SharedDWallet;
        messageApproval: TransactionObjectArgument;
        hashScheme: ValidHashForSignature<S>;
        verifiedPresignCap: TransactionObjectArgument;
        presign: Presign;
        encryptedUserSecretKeyShare?: EncryptedUserSecretKeyShare;
        secretShare?: Uint8Array;
        publicOutput?: Uint8Array;
        message: Uint8Array;
        signatureScheme: S;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): Promise<TransactionObjectArgument>;
    /**
     * Sign a message using an Imported Key DWallet.
     * This performs the actual signing operation using the presign and user's share (encrypted, secret, or public).
     *
     * SECURITY WARNING: When using unencrypted shares, this method does not verify `secretShare` and `publicOutput`,
     * which must be verified by the caller in order to guarantee zero-trust security.
     *
     * @param params.dWallet - The Imported Key DWallet to sign with (type and share availability auto-detected)
     * @param params.importedKeyMessageApproval - Imported key message approval
     * @param params.hashScheme - The hash scheme used for the message (must be valid for the signature algorithm)
     * @param params.verifiedPresignCap - The verified presign capability
     * @param params.presign - The completed presign object
     * @param params.encryptedUserSecretKeyShare - Optional: encrypted user secret key share (for ImportedKeyDWallet)
     * @param params.secretShare - Optional: unencrypted secret share (requires publicOutput, for ImportedKeyDWallet)
     * @param params.publicOutput - Optional: public output (required when using secretShare, for ImportedKeyDWallet)
     * @param params.message - The message bytes to sign
     * @param params.signatureScheme - Optional: signature algorithm (defaults to ECDSASecp256k1)
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Promise resolving to the signature ID
     *
     * @example
     * // ImportedKeyDWallet - Zero-trust signing (encrypted shares)
     * const signatureId = await tx.requestSignWithImportedKey({
     *   dWallet, // ImportedKeyDWallet
     *   importedKeyMessageApproval,
     *   encryptedUserSecretKeyShare,
     *   // ... other params
     * });
     *
     * @example
     * // ImportedKeyDWallet - Secret share signing
     * const signatureId = await tx.requestSignWithImportedKey({
     *   dWallet, // ImportedKeyDWallet
     *   importedKeyMessageApproval,
     *   secretShare,
     *   publicOutput,
     *   // ... other params
     * });
     *
     * @example
     * // ImportedSharedDWallet - Public share signing (no secret params needed)
     * const signatureId = await tx.requestSignWithImportedKey({
     *   dWallet, // ImportedSharedDWallet
     *   importedKeyMessageApproval,
     *   // ... other params (no secretShare/publicOutput needed)
     * });
     */
    requestSignWithImportedKey<S extends SignatureAlgorithm = typeof SignatureAlgorithm.ECDSASecp256k1>({ dWallet, importedKeyMessageApproval, hashScheme, verifiedPresignCap, presign, encryptedUserSecretKeyShare, secretShare, publicOutput, message, signatureScheme, ikaCoin, suiCoin, }: {
        dWallet: ImportedKeyDWallet | ImportedSharedDWallet;
        importedKeyMessageApproval: TransactionObjectArgument;
        hashScheme: ValidHashForSignature<S>;
        verifiedPresignCap: TransactionObjectArgument;
        presign: Presign;
        encryptedUserSecretKeyShare?: EncryptedUserSecretKeyShare;
        secretShare?: Uint8Array;
        publicOutput?: Uint8Array;
        message: Uint8Array;
        signatureScheme?: S;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): Promise<TransactionObjectArgument>;
    /**
     * Request a future sign operation with encrypted shares for ZeroTrust DWallets and keep capability.
     * This creates a partial user signature capability that is returned with the transaction.
     *
     * @param params.dWallet - The ZeroTrust DWallet to create the future sign for
     * @param params.verifiedPresignCap - The verified presign capability
     * @param params.presign - The completed presign object
     * @param params.encryptedUserSecretKeyShare - The user's encrypted secret key share
     * @param params.message - The message bytes to pre-sign
     * @param params.hashScheme - The hash scheme to use for the message
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Promise resolving to the unverified partial user signature capability
     */
    requestFutureSign({ dWallet, verifiedPresignCap, presign, encryptedUserSecretKeyShare, message, hashScheme, signatureScheme, ikaCoin, suiCoin, }: {
        dWallet: ZeroTrustDWallet;
        verifiedPresignCap: TransactionObjectArgument;
        presign: Presign;
        encryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;
        message: Uint8Array;
        hashScheme: Hash;
        signatureScheme: SignatureAlgorithm;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): Promise<TransactionObjectArgument>;
    /**
     * Request a future sign operation with secret shares for ZeroTrust DWallets and keep capability.
     * This creates a partial user signature capability that is returned with the transaction.
     *
     * SECURITY WARNING: This method does not verify `secretShare` and `publicOutput`,
     * which must be verified by the caller in order to guarantee zero-trust security.
     *
     * @param params.dWallet - The ZeroTrust DWallet to create the future sign for
     * @param params.verifiedPresignCap - The verified presign capability
     * @param params.presign - The completed presign object
     * @param params.secretShare - The user's unencrypted secret share
     * @param params.publicOutput - The user's public output
     * @param params.message - The message bytes to pre-sign
     * @param params.hashScheme - The hash scheme to use for the message
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Promise resolving to the unverified partial user signature capability
     */
    requestFutureSign({ dWallet, verifiedPresignCap, presign, secretShare, publicOutput, message, hashScheme, signatureScheme, ikaCoin, suiCoin, }: {
        dWallet: ZeroTrustDWallet;
        verifiedPresignCap: TransactionObjectArgument;
        presign: Presign;
        secretShare: Uint8Array;
        publicOutput: Uint8Array;
        message: Uint8Array;
        hashScheme: Hash;
        signatureScheme: SignatureAlgorithm;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): Promise<TransactionObjectArgument>;
    /**
     * Request a future sign operation with public shares for Shared DWallets and keep capability.
     * This creates a partial user signature capability that is returned with the transaction.
     * No secret share or public output parameters are needed as they are available on the DWallet.
     *
     * @param params.dWallet - The Shared DWallet to create the future sign for
     * @param params.verifiedPresignCap - The verified presign capability
     * @param params.presign - The completed presign object
     * @param params.message - The message bytes to pre-sign
     * @param params.hashScheme - The hash scheme to use for the message
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Promise resolving to the unverified partial user signature capability
     */
    requestFutureSign({ dWallet, verifiedPresignCap, presign, message, hashScheme, signatureScheme, ikaCoin, suiCoin, }: {
        dWallet: SharedDWallet;
        verifiedPresignCap: TransactionObjectArgument;
        presign: Presign;
        message: Uint8Array;
        hashScheme: Hash;
        signatureScheme: SignatureAlgorithm;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): Promise<TransactionObjectArgument>;
    /**
     * Request a future sign operation with encrypted shares for Imported Key DWallets and keep capability.
     * This creates a partial user signature capability that is returned with the transaction.
     *
     * @param params.dWallet - The Imported Key DWallet to create the future sign for
     * @param params.verifiedPresignCap - The verified presign capability
     * @param params.presign - The completed presign object
     * @param params.encryptedUserSecretKeyShare - The user's encrypted secret key share
     * @param params.message - The message bytes to pre-sign
     * @param params.hashScheme - The hash scheme to use for the message
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Promise resolving to the unverified partial user signature capability
     */
    requestFutureSignWithImportedKey({ dWallet, verifiedPresignCap, presign, encryptedUserSecretKeyShare, message, hashScheme, signatureScheme, ikaCoin, suiCoin, }: {
        dWallet: ImportedKeyDWallet;
        verifiedPresignCap: TransactionObjectArgument;
        presign: Presign;
        encryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;
        message: Uint8Array;
        hashScheme: Hash;
        signatureScheme: SignatureAlgorithm;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): Promise<TransactionObjectArgument>;
    /**
     * Request a future sign operation with secret shares for Imported Key DWallets and keep capability.
     * This creates a partial user signature capability that is returned with the transaction.
     *
     * SECURITY WARNING: This method does not verify `secretShare` and `publicOutput`,
     * which must be verified by the caller in order to guarantee zero-trust security.
     *
     * @param params.dWallet - The Imported Key DWallet to create the future sign for
     * @param params.verifiedPresignCap - The verified presign capability
     * @param params.presign - The completed presign object
     * @param params.secretShare - The user's unencrypted secret share
     * @param params.publicOutput - The user's public output
     * @param params.message - The message bytes to pre-sign
     * @param params.hashScheme - The hash scheme to use for the message
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Promise resolving to the unverified partial user signature capability
     */
    requestFutureSignWithImportedKey({ dWallet, verifiedPresignCap, presign, secretShare, publicOutput, message, hashScheme, signatureScheme, ikaCoin, suiCoin, }: {
        dWallet: ImportedKeyDWallet;
        verifiedPresignCap: TransactionObjectArgument;
        presign: Presign;
        secretShare: Uint8Array;
        publicOutput: Uint8Array;
        message: Uint8Array;
        hashScheme: Hash;
        signatureScheme: SignatureAlgorithm;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): Promise<TransactionObjectArgument>;
    /**
     * Request a future sign operation with public shares for ImportedShared DWallets and keep capability.
     * This creates a partial user signature capability that is returned with the transaction.
     * No secret share or public output parameters are needed as they are available on the DWallet.
     *
     * @param params.dWallet - The ImportedShared DWallet to create the future sign for
     * @param params.verifiedPresignCap - The verified presign capability
     * @param params.presign - The completed presign object
     * @param params.message - The message bytes to pre-sign
     * @param params.hashScheme - The hash scheme to use for the message
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Promise resolving to the unverified partial user signature capability
     */
    requestFutureSignWithImportedKey({ dWallet, verifiedPresignCap, presign, message, hashScheme, signatureScheme, ikaCoin, suiCoin, }: {
        dWallet: ImportedSharedDWallet;
        verifiedPresignCap: TransactionObjectArgument;
        presign: Presign;
        message: Uint8Array;
        hashScheme: Hash;
        signatureScheme: SignatureAlgorithm;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): Promise<TransactionObjectArgument>;
    /**
     * Complete a future sign operation using a previously created partial user signature.
     * This method takes a partial signature created earlier and combines it with message approval to create a full signature.
     *
     * @param params.partialUserSignatureCap - The partial user signature capability created by requestFutureSign
     * @param params.messageApproval - The message approval from approveMessage
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns The signature ID
     */
    futureSign({ partialUserSignatureCap, messageApproval, ikaCoin, suiCoin, }: {
        partialUserSignatureCap: TransactionObjectArgument | string;
        messageApproval: TransactionObjectArgument;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): TransactionObjectArgument;
    /**
     * Complete a future sign operation for imported key using a previously created partial user signature.
     * This method takes a partial signature created earlier and combines it with imported key message approval to create a full signature.
     *
     * @param params.partialUserSignatureCap - The partial user signature capability created by requestFutureSignWithImportedKey
     * @param params.importedKeyMessageApproval - The imported key message approval from approveImportedKeyMessage
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns The signature ID
     */
    futureSignWithImportedKey({ partialUserSignatureCap, importedKeyMessageApproval, ikaCoin, suiCoin, }: {
        partialUserSignatureCap: TransactionObjectArgument | string;
        importedKeyMessageApproval: TransactionObjectArgument | string;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): TransactionObjectArgument;
    /**
     * Request verification for an Imported Key DWallet key and keep the capability.
     * This method creates a DWallet from an existing cryptographic key that was generated outside the network.
     *
     * @param params.importDWalletVerificationRequestInput - The prepared verification data from prepareImportedKeyDWalletVerification
     * @param params.curve - The elliptic curve identifier used for the imported key
     * @param params.signerPublicKey - The public key of the transaction signer
     * @param params.sessionIdentifier - Unique session identifier for this operation
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Promise resolving to imported key DWallet capability
     */
    requestImportedKeyDWalletVerification({ importDWalletVerificationRequestInput, curve, signerPublicKey, sessionIdentifier, ikaCoin, suiCoin, }: {
        importDWalletVerificationRequestInput: ImportDWalletVerificationRequestInput;
        curve: Curve;
        signerPublicKey: Uint8Array;
        sessionIdentifier: TransactionObjectArgument;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): Promise<TransactionObjectArgument>;
    /**
     * Transfer an encrypted user share from the current user to another address using encrypted shares.
     * This re-encrypts the user's share with the destination address's encryption key.
     * The encrypted share is automatically decrypted internally.
     *
     * @param params.dWallet - The DWallet whose user share is being transferred
     * @param params.destinationEncryptionKeyAddress - The Sui address that will receive the re-encrypted share
     * @param params.sourceEncryptedUserSecretKeyShare - The current user's encrypted secret key share
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Promise resolving to the updated IkaTransaction instance
     */
    requestReEncryptUserShareFor({ dWallet, destinationEncryptionKeyAddress, sourceEncryptedUserSecretKeyShare, ikaCoin, suiCoin, }: {
        dWallet: ZeroTrustDWallet | ImportedKeyDWallet;
        destinationEncryptionKeyAddress: string;
        sourceEncryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): Promise<IkaTransaction>;
    /**
     * Transfer an encrypted user share from the current user to another address using unencrypted secret shares.
     * This re-encrypts the user's share with the destination address's encryption key.
     *
     * SECURITY WARNING: This method does not verify `sourceSecretShare`,
     * which must be verified by the caller in order to guarantee zero-trust security.
     *
     * @param params.dWallet - The DWallet whose user share is being transferred
     * @param params.destinationEncryptionKeyAddress - The Sui address that will receive the re-encrypted share
     * @param params.sourceSecretShare - The current user's unencrypted secret share
     * @param params.sourceEncryptedUserSecretKeyShare - The current user's encrypted secret key share
     * @param params.ikaCoin - The IKA coin object to use for transaction fees
     * @param params.suiCoin - The SUI coin object to use for gas fees
     * @returns Promise resolving to the updated IkaTransaction instance
     */
    requestReEncryptUserShareFor({ dWallet, destinationEncryptionKeyAddress, sourceSecretShare, sourceEncryptedUserSecretKeyShare, ikaCoin, suiCoin, }: {
        dWallet: ZeroTrustDWallet | ImportedKeyDWallet;
        destinationEncryptionKeyAddress: string;
        sourceSecretShare: Uint8Array;
        sourceEncryptedUserSecretKeyShare: EncryptedUserSecretKeyShare;
        ikaCoin: TransactionObjectArgument;
        suiCoin: TransactionObjectArgument;
    }): Promise<IkaTransaction>;
    /**
     * Create a unique session identifier for the current transaction and register it with the coordinator.
     *
     * @returns The session identifier transaction object argument
     */
    createSessionIdentifier(): TransactionObjectArgument;
    /**
     * Register a unique session identifier for the current transaction.
     *
     * @returns The session identifier transaction object argument
     */
    registerSessionIdentifier(sessionIdentifier: Uint8Array): TransactionObjectArgument;
    /**
     * Check if a DWallet with the specified ID exists in the coordinator.
     * This is useful for validating DWallet existence before performing operations.
     *
     * @param params.dwalletId - The ID of the DWallet to check
     * @returns Transaction result indicating whether the DWallet exists (returns a boolean)
     */
    hasDWallet({ dwalletId }: {
        dwalletId: string;
    }): TransactionObjectArgument;
    /**
     * Get a reference to a DWallet object from the coordinator.
     * This returns an immutable reference to the DWallet that can be used in the same transaction.
     *
     * @param params.dwalletId - The ID of the DWallet to retrieve
     * @returns Transaction result containing a reference to the DWallet object
     */
    getDWallet({ dwalletId }: {
        dwalletId: string;
    }): TransactionObjectArgument;
}
