import { bcs } from "@mysten/sui/bcs";
import { SIGNATURE_FLAG_TO_SCHEME } from "@mysten/sui/cryptography";
import { keccak_256 } from "@noble/hashes/sha3";
import { randomBytes } from "@noble/hashes/utils.js";
import {
  fromCurveAndSignatureAlgorithmAndHashToNumbers,
  fromCurveToNumber,
  fromSignatureAlgorithmToNumber
} from "./hash-signature-validation.js";
import { Curve } from "./types.js";
import { encodeToASCII, u64ToBytesBigEndian } from "./utils.js";
import {
  centralized_and_decentralized_parties_dkg_output_match,
  create_dkg_centralized_output_v2,
  create_dkg_centralized_output_v1 as create_dkg_user_output,
  create_imported_dwallet_centralized_step as create_imported_dwallet_user_output,
  create_sign_centralized_party_message_with_centralized_party_dkg_output,
  create_sign_centralized_party_message as create_sign_user_message,
  encrypt_secret_share,
  generate_secp_cg_keypair_from_seed,
  network_dkg_public_output_to_protocol_pp,
  parse_signature_from_sign_output,
  public_key_from_centralized_dkg_output,
  public_key_from_dwallet_output,
  reconfiguration_public_output_to_protocol_pp,
  verify_secp_signature,
  verify_user_share
} from "./wasm-loader.js";
async function createClassGroupsKeypair(seed, curve) {
  if (seed.length !== 32) {
    throw new Error("Seed must be 32 bytes");
  }
  let encryptionKey;
  let decryptionKey;
  if (curve === Curve.SECP256K1 || curve === Curve.SECP256R1 || curve === Curve.RISTRETTO || curve === Curve.ED25519) {
    [encryptionKey, decryptionKey] = await generate_secp_cg_keypair_from_seed(
      fromCurveToNumber(curve),
      seed
    );
  } else {
    throw new Error(
      "Only SECP256K1, SECP256R1, RISTRETTO, and ED25519 curves are supported for now"
    );
  }
  return {
    encryptionKey: Uint8Array.from(encryptionKey),
    decryptionKey: Uint8Array.from(decryptionKey)
  };
}
async function createDKGUserOutput(protocolPublicParameters, networkFirstRoundOutput) {
  const [userDKGMessage, userPublicOutput, userSecretKeyShare] = await create_dkg_user_output(
    protocolPublicParameters,
    Uint8Array.from(networkFirstRoundOutput)
  );
  return {
    userDKGMessage: Uint8Array.from(userDKGMessage),
    userPublicOutput: Uint8Array.from(userPublicOutput),
    userSecretKeyShare: Uint8Array.from(userSecretKeyShare)
  };
}
async function encryptSecretShare(curve, userSecretKeyShare, encryptionKey, protocolPublicParameters) {
  const encryptedUserShareAndProof = await encrypt_secret_share(
    fromCurveToNumber(curve),
    userSecretKeyShare,
    encryptionKey,
    protocolPublicParameters
  );
  return Uint8Array.from(encryptedUserShareAndProof);
}
async function prepareDKGSecondRound(_protocolPublicParameters, _dWallet, _encryptionKey) {
  throw new Error("prepareDKGSecondRound is deprecated. Use prepareDKG instead");
}
async function prepareDKG(protocolPublicParameters, curve, encryptionKey, bytesToHash, senderAddress) {
  const senderAddressBytes = bcs.Address.serialize(senderAddress).toBytes();
  const [userDKGMessage, userPublicOutput, userSecretKeyShare] = await create_dkg_centralized_output_v2(
    fromCurveToNumber(curve),
    protocolPublicParameters,
    sessionIdentifierDigest(bytesToHash, senderAddressBytes)
  );
  const encryptedUserShareAndProof = await encryptSecretShare(
    curve,
    userSecretKeyShare,
    encryptionKey,
    protocolPublicParameters
  );
  return {
    userDKGMessage: Uint8Array.from(userDKGMessage),
    userPublicOutput: Uint8Array.from(userPublicOutput),
    encryptedUserShareAndProof: Uint8Array.from(encryptedUserShareAndProof),
    userSecretKeyShare: Uint8Array.from(userSecretKeyShare)
  };
}
async function prepareDKGSecondRoundAsync(_ikaClient, _dWallet, _userShareEncryptionKeys) {
  throw new Error("prepareDKGSecondRoundAsync is deprecated. Use prepareDKGAsync instead");
}
async function prepareDKGAsync(ikaClient, curve, userShareEncryptionKeys, bytesToHash, senderAddress) {
  const protocolPublicParameters = await ikaClient.getProtocolPublicParameters(void 0, curve);
  return prepareDKG(
    protocolPublicParameters,
    curve,
    userShareEncryptionKeys.encryptionKey,
    bytesToHash,
    senderAddress
  );
}
async function prepareImportedKeyDWalletVerification(ikaClient, curve, bytesToHash, senderAddress, userShareEncryptionKeys, privateKey) {
  const senderAddressBytes = bcs.Address.serialize(senderAddress).toBytes();
  const protocolPublicParameters = await ikaClient.getProtocolPublicParameters(void 0, curve);
  const [userSecretShare, userPublicOutput, userMessage] = await create_imported_dwallet_user_output(
    fromCurveToNumber(curve),
    protocolPublicParameters,
    sessionIdentifierDigest(bytesToHash, senderAddressBytes),
    privateKey
  );
  const encryptedUserShareAndProof = await encryptSecretShare(
    curve,
    userSecretShare,
    userShareEncryptionKeys.encryptionKey,
    protocolPublicParameters
  );
  return {
    userPublicOutput: Uint8Array.from(userPublicOutput),
    userMessage: Uint8Array.from(userMessage),
    encryptedUserShareAndProof: Uint8Array.from(encryptedUserShareAndProof)
  };
}
async function createUserSignMessageWithPublicOutput(protocolPublicParameters, publicOutput, userSecretKeyShare, presign, message, hash, signatureAlgorithm, curve) {
  const { signatureAlgorithmNumber, hashNumber, curveNumber } = fromCurveAndSignatureAlgorithmAndHashToNumbers(curve, signatureAlgorithm, hash);
  return Uint8Array.from(
    await create_sign_user_message(
      protocolPublicParameters,
      publicOutput,
      userSecretKeyShare,
      presign,
      message,
      hashNumber,
      signatureAlgorithmNumber,
      curveNumber
    )
  );
}
async function createUserSignMessageWithCentralizedOutput(protocolPublicParameters, centralizedDkgOutput, userSecretKeyShare, presign, message, hash, signatureAlgorithm, curve) {
  const { signatureAlgorithmNumber, hashNumber, curveNumber } = fromCurveAndSignatureAlgorithmAndHashToNumbers(curve, signatureAlgorithm, hash);
  return Uint8Array.from(
    await create_sign_centralized_party_message_with_centralized_party_dkg_output(
      protocolPublicParameters,
      centralizedDkgOutput,
      userSecretKeyShare,
      presign,
      message,
      hashNumber,
      signatureAlgorithmNumber,
      curveNumber
    )
  );
}
async function networkDkgPublicOutputToProtocolPublicParameters(curve, network_dkg_public_output) {
  return Uint8Array.from(
    await network_dkg_public_output_to_protocol_pp(
      fromCurveToNumber(curve),
      network_dkg_public_output
    )
  );
}
async function reconfigurationPublicOutputToProtocolPublicParameters(curve, reconfiguration_public_output, network_dkg_public_output) {
  return Uint8Array.from(
    await reconfiguration_public_output_to_protocol_pp(
      fromCurveToNumber(curve),
      reconfiguration_public_output,
      network_dkg_public_output
    )
  );
}
async function verifyUserShare(curve, userSecretKeyShare, userDKGOutput, networkDkgPublicOutput) {
  return await verify_user_share(
    fromCurveToNumber(curve),
    userSecretKeyShare,
    userDKGOutput,
    networkDkgPublicOutput
  );
}
async function verifySecpSignature(publicKey, signature, message, networkDkgPublicOutput, hash, signatureAlgorithm, curve) {
  const { signatureAlgorithmNumber, hashNumber, curveNumber } = fromCurveAndSignatureAlgorithmAndHashToNumbers(curve, signatureAlgorithm, hash);
  return await verify_secp_signature(
    publicKey,
    signature,
    message,
    networkDkgPublicOutput,
    hashNumber,
    signatureAlgorithmNumber,
    curveNumber
  );
}
async function publicKeyFromDWalletOutput(curve, dWalletOutput) {
  return Uint8Array.from(
    await public_key_from_dwallet_output(fromCurveToNumber(curve), dWalletOutput)
  );
}
async function publicKeyFromCentralizedDKGOutput(curve, centralizedDkgOutput) {
  return Uint8Array.from(
    await public_key_from_centralized_dkg_output(fromCurveToNumber(curve), centralizedDkgOutput)
  );
}
async function verifyAndGetDWalletDKGPublicOutput(dWallet, encryptedUserSecretKeyShare, publicKey) {
  if (SIGNATURE_FLAG_TO_SCHEME[publicKey.flag()] !== "ED25519") {
    throw new Error("Only ED25519 public keys are supported.");
  }
  if (!dWallet.state.Active?.public_output) {
    throw new Error("DWallet is not in active state");
  }
  if (!encryptedUserSecretKeyShare.state.KeyHolderSigned?.user_output_signature) {
    throw new Error("User output signature is undefined");
  }
  const userPublicOutput = Uint8Array.from(dWallet.state.Active.public_output);
  const userOutputSignature = Uint8Array.from(
    encryptedUserSecretKeyShare.state.KeyHolderSigned?.user_output_signature
  );
  if (!await publicKey.verify(userPublicOutput, userOutputSignature)) {
    throw new Error("Invalid signature");
  }
  if (publicKey.toSuiAddress() !== encryptedUserSecretKeyShare.encryption_key_address) {
    throw new Error(
      "Invalid Sui address. The encryption key address does not match the signing keypair address."
    );
  }
  return Uint8Array.from(dWallet.state.Active.public_output);
}
async function userAndNetworkDKGOutputMatch(curve, userPublicOutput, networkDKGOutput) {
  return await centralized_and_decentralized_parties_dkg_output_match(
    fromCurveToNumber(curve),
    userPublicOutput,
    networkDKGOutput
  );
}
async function parseSignatureFromSignOutput(curve, signatureAlgorithm, signatureOutput) {
  return Uint8Array.from(
    await parse_signature_from_sign_output(
      fromCurveToNumber(curve),
      fromSignatureAlgorithmToNumber(curve, signatureAlgorithm),
      signatureOutput
    )
  );
}
function sessionIdentifierDigest(bytesToHash, senderAddressBytes) {
  const preimage = keccak_256(Uint8Array.from([...senderAddressBytes, ...bytesToHash]));
  const version = 0;
  const data = Uint8Array.from([
    ...u64ToBytesBigEndian(version),
    ...encodeToASCII("USER"),
    ...preimage
  ]);
  const digest = keccak_256(data);
  return Uint8Array.from(digest);
}
function createRandomSessionIdentifier() {
  return Uint8Array.from(randomBytes(32));
}
export {
  createClassGroupsKeypair,
  createDKGUserOutput,
  createRandomSessionIdentifier,
  createUserSignMessageWithCentralizedOutput,
  createUserSignMessageWithPublicOutput,
  encryptSecretShare,
  networkDkgPublicOutputToProtocolPublicParameters,
  parseSignatureFromSignOutput,
  prepareDKG,
  prepareDKGAsync,
  prepareDKGSecondRound,
  prepareDKGSecondRoundAsync,
  prepareImportedKeyDWalletVerification,
  publicKeyFromCentralizedDKGOutput,
  publicKeyFromDWalletOutput,
  reconfigurationPublicOutputToProtocolPublicParameters,
  sessionIdentifierDigest,
  userAndNetworkDKGOutputMatch,
  verifyAndGetDWalletDKGPublicOutput,
  verifySecpSignature,
  verifyUserShare
};
//# sourceMappingURL=cryptography.js.map
