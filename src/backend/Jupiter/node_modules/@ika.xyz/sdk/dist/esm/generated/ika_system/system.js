import { MoveStruct, normalizeMoveArguments } from "../utils/index.js";
import { bcs } from "@mysten/sui/bcs";
import * as object from "./deps/sui/object.js";
const $moduleName = "@local-pkg/system::system";
const System = new MoveStruct({ name: `${$moduleName}::System`, fields: {
  id: object.UID,
  version: bcs.u64(),
  package_id: bcs.Address,
  new_package_id: bcs.option(bcs.Address),
  migration_epoch: bcs.option(bcs.u64())
} });
function initialize(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "u64",
    `${packageAddress}::protocol_cap::ProtocolCap`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "maxValidatorChangeCount", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "initialize",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function requestAddValidatorCandidate(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    "vector<u8>",
    "vector<u8>",
    "vector<u8>",
    "0x0000000000000000000000000000000000000000000000000000000000000002::table_vec::TableVec<vector<u8>>",
    "vector<u8>",
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    "u16",
    `${packageAddress}::validator_metadata::ValidatorMetadata`
  ];
  const parameterNames = ["self", "name", "protocolPubkeyBytes", "networkPubkeyBytes", "consensusPubkeyBytes", "mpcDataBytes", "proofOfPossessionBytes", "networkAddress", "p2pAddress", "consensusAddress", "commissionRate", "metadata"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "request_add_validator_candidate",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function requestRemoveValidatorCandidate(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "request_remove_validator_candidate",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function requestAddValidator(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "request_add_validator",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function requestRemoveValidator(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "request_remove_validator",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextCommission(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "u16",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "newCommissionRate", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_commission",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function requestAddStake(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::ika::IKA>`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "stake", "validatorId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "request_add_stake",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function requestWithdrawStake(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::staked_ika::StakedIka`
  ];
  const parameterNames = ["self", "stakedIka"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "request_withdraw_stake",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function withdrawStake(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::staked_ika::StakedIka`
  ];
  const parameterNames = ["self", "stakedIka"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "withdraw_stake",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function reportValidator(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorOperationCap`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "cap", "reporteeId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "report_validator",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function undoReportValidator(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorOperationCap`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "cap", "reporteeId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "undo_report_validator",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function rotateOperationCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "rotate_operation_cap",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function rotateCommissionCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "rotate_commission_cap",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function collectCommission(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCommissionCap`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::option::Option<u64>"
  ];
  const parameterNames = ["self", "cap", "amount"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "collect_commission",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function setValidatorName(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "name", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_validator_name",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function validatorMetadata(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "validatorId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "validator_metadata",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function setValidatorMetadata(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_metadata::ValidatorMetadata`,
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "metadata", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_validator_metadata",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochNetworkAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "networkAddress", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_network_address",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochP2pAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "p2pAddress", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_p2p_address",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochConsensusAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "consensusAddress", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_consensus_address",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochProtocolPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "vector<u8>",
    "vector<u8>",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "protocolPubkey", "proofOfPossessionBytes", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_protocol_pubkey_bytes",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochNetworkPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "vector<u8>",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "networkPubkey", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_network_pubkey_bytes",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochConsensusPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "vector<u8>",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "consensusPubkeyBytes", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_consensus_pubkey_bytes",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochMpcDataBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::table_vec::TableVec<vector<u8>>",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "mpcData", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_mpc_data_bytes",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function tokenExchangeRates(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "validatorId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "token_exchange_rates",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function activeCommittee(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "active_committee",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochActiveCommittee(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "next_epoch_active_committee",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function initiateMidEpochReconfiguration(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "initiate_mid_epoch_reconfiguration",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function createSystemCurrentStatusInfo(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "create_system_current_status_info",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function initiateAdvanceEpoch(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "initiate_advance_epoch",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function advanceEpoch(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::advance_epoch_approver::AdvanceEpochApprover`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "advanceEpochApprover"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "advance_epoch",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function verifyValidatorCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "verify_validator_cap",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function verifyOperationCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "verify_operation_cap",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function verifyCommissionCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCommissionCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "verify_commission_cap",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function authorizeUpgrade(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "packageId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "authorize_upgrade",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function commitUpgrade(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::package::UpgradeReceipt",
    `${packageAddress}::upgrade_package_approver::UpgradePackageApprover`
  ];
  const parameterNames = ["self", "receipt", "upgradePackageApprover"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "commit_upgrade",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function finalizeUpgrade(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::upgrade_package_approver::UpgradePackageApprover`
  ];
  const parameterNames = ["self", "upgradePackageApprover"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "finalize_upgrade",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function processCheckpointMessageByQuorum(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "vector<u8>",
    "vector<u8>",
    "vector<u8>"
  ];
  const parameterNames = ["self", "signature", "signersBitmap", "message"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "process_checkpoint_message_by_quorum",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function addUpgradeCapByCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::package::UpgradeCap",
    `${packageAddress}::protocol_cap::ProtocolCap`
  ];
  const parameterNames = ["self", "upgradeCap", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "add_upgrade_cap_by_cap",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function verifyProtocolCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::protocol_cap::ProtocolCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "verify_protocol_cap",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function processCheckpointMessageByCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "vector<u8>",
    `${packageAddress}::protocol_cap::ProtocolCap`
  ];
  const parameterNames = ["self", "message", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "process_checkpoint_message_by_cap",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function setApprovedUpgradeByCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID",
    "0x0000000000000000000000000000000000000000000000000000000000000001::option::Option<vector<u8>>",
    `${packageAddress}::protocol_cap::ProtocolCap`
  ];
  const parameterNames = ["self", "packageId", "digest", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_approved_upgrade_by_cap",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function setOrRemoveWitnessApprovingAdvanceEpochByCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    "bool",
    `${packageAddress}::protocol_cap::ProtocolCap`
  ];
  const parameterNames = ["self", "witnessType", "remove", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_or_remove_witness_approving_advance_epoch_by_cap",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function tryMigrateByCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::protocol_cap::ProtocolCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "try_migrate_by_cap",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function tryMigrate(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "try_migrate",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function version(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "version",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function calculateRewards(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID",
    "u64",
    "u64",
    "u64"
  ];
  const parameterNames = ["self", "validatorId", "stakedPrincipal", "activationEpoch", "withdrawEpoch"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "calculate_rewards",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function canWithdrawStakedIkaEarly(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::staked_ika::StakedIka`
  ];
  const parameterNames = ["self", "stakedIka"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "can_withdraw_staked_ika_early",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function epoch(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "epoch",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function validatorStakeAmount(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "validatorId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "validator_stake_amount",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function claimMetadataCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin_registry::Currency<${packageAddress}::ika::IKA>`
  ];
  const parameterNames = ["self", "currency"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "claim_metadata_cap",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
export {
  System,
  activeCommittee,
  addUpgradeCapByCap,
  advanceEpoch,
  authorizeUpgrade,
  calculateRewards,
  canWithdrawStakedIkaEarly,
  claimMetadataCap,
  collectCommission,
  commitUpgrade,
  createSystemCurrentStatusInfo,
  epoch,
  finalizeUpgrade,
  initialize,
  initiateAdvanceEpoch,
  initiateMidEpochReconfiguration,
  nextEpochActiveCommittee,
  processCheckpointMessageByCap,
  processCheckpointMessageByQuorum,
  reportValidator,
  requestAddStake,
  requestAddValidator,
  requestAddValidatorCandidate,
  requestRemoveValidator,
  requestRemoveValidatorCandidate,
  requestWithdrawStake,
  rotateCommissionCap,
  rotateOperationCap,
  setApprovedUpgradeByCap,
  setNextCommission,
  setNextEpochConsensusAddress,
  setNextEpochConsensusPubkeyBytes,
  setNextEpochMpcDataBytes,
  setNextEpochNetworkAddress,
  setNextEpochNetworkPubkeyBytes,
  setNextEpochP2pAddress,
  setNextEpochProtocolPubkeyBytes,
  setOrRemoveWitnessApprovingAdvanceEpochByCap,
  setValidatorMetadata,
  setValidatorName,
  tokenExchangeRates,
  tryMigrate,
  tryMigrateByCap,
  undoReportValidator,
  validatorMetadata,
  validatorStakeAmount,
  verifyCommissionCap,
  verifyOperationCap,
  verifyProtocolCap,
  verifyValidatorCap,
  version,
  withdrawStake
};
//# sourceMappingURL=system.js.map
