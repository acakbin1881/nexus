import { MoveStruct, normalizeMoveArguments } from "../utils/index.js";
import { bcs } from "@mysten/sui/bcs";
import * as balance from "./deps/sui/balance.js";
const $moduleName = "@local-pkg/common::advance_epoch_approver";
const AdvanceEpochApprover = new MoveStruct({ name: `${$moduleName}::AdvanceEpochApprover`, fields: {
  new_epoch: bcs.u64(),
  remaining_witnesses_to_approve: bcs.vector(bcs.string()),
  balance_ika: balance.Balance
} });
function create(options) {
  const packageAddress = options.package ?? "@local-pkg/common";
  const argumentsTypes = [
    "u64",
    "vector<0x0000000000000000000000000000000000000000000000000000000000000001::string::String>",
    `0x0000000000000000000000000000000000000000000000000000000000000002::balance::Balance<${packageAddress}::ika::IKA>`,
    `${packageAddress}::system_object_cap::SystemObjectCap`
  ];
  const parameterNames = ["newEpoch", "remainingWitnessesToApprove", "balanceIka", "_"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "advance_epoch_approver",
    function: "create",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function newEpoch(options) {
  const packageAddress = options.package ?? "@local-pkg/common";
  const argumentsTypes = [
    `${packageAddress}::advance_epoch_approver::AdvanceEpochApprover`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "advance_epoch_approver",
    function: "new_epoch",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function assertAllWitnessesApproved(options) {
  const packageAddress = options.package ?? "@local-pkg/common";
  const argumentsTypes = [
    `${packageAddress}::advance_epoch_approver::AdvanceEpochApprover`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "advance_epoch_approver",
    function: "assert_all_witnesses_approved",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function destroy(options) {
  const packageAddress = options.package ?? "@local-pkg/common";
  const argumentsTypes = [
    `${packageAddress}::advance_epoch_approver::AdvanceEpochApprover`,
    `${packageAddress}::system_object_cap::SystemObjectCap`
  ];
  const parameterNames = ["self", "_"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "advance_epoch_approver",
    function: "destroy",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function approveAdvanceEpochByWitness(options) {
  const packageAddress = options.package ?? "@local-pkg/common";
  const argumentsTypes = [
    `${packageAddress}::advance_epoch_approver::AdvanceEpochApprover`,
    `${options.typeArguments[0]}`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::balance::Balance<${packageAddress}::ika::IKA>`
  ];
  const parameterNames = ["advanceEpochApprover", "_", "balanceIka"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "advance_epoch_approver",
    function: "approve_advance_epoch_by_witness",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),
    typeArguments: options.typeArguments
  });
}
export {
  AdvanceEpochApprover,
  approveAdvanceEpochByWitness,
  assertAllWitnessesApproved,
  create,
  destroy,
  newEpoch
};
//# sourceMappingURL=advance_epoch_approver.js.map
