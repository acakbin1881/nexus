import { Ed25519PublicKey } from '@mysten/sui/keypairs/ed25519';
import type { Curve, DWallet, EncryptedUserSecretKeyShare, EncryptionKey } from './types.js';
/**
 * BCS enum for UserShareEncryptionKeys.
 *
 * @see UserShareEncryptionKeys
 */
export declare const VersionedUserShareEncryptionKeysBcs: import("@mysten/bcs").BcsEnum<{
    V1: import("@mysten/bcs").BcsStruct<{
        encryptionKey: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
        decryptionKey: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
            length: number;
        }, string>;
        secretShareSigningSecretKey: import("@mysten/bcs").BcsType<string, string, "string">;
        curve: import("@mysten/bcs").BcsType<string, string | number | bigint, "u64">;
    }, string>;
}, "VersionedUserShareEncryptionKeys">;
/**
 * UserShareEncryptionKeys manages encryption/decryption keys and signing keypairs for user shares.
 * This class handles the creation and management of cryptographic keys needed for secure
 * user share operations in the DWallet network.
 */
export declare class UserShareEncryptionKeys {
    #private;
    /** The public encryption key used to encrypt secret shares */
    encryptionKey: Uint8Array;
    /** The private decryption key used to decrypt secret shares */
    decryptionKey: Uint8Array;
    /** The curve used to generate the encryption/decryption keys */
    curve: Curve;
    static domainSeparators: {
        classGroups: string;
        encryptionSignerKey: string;
    };
    private constructor();
    /**
     * Creates UserShareEncryptionKeys from a root seed key (Uint8Array).
     *
     * @param rootSeedKey - The root seed key to generate keys from
     * @param curve - The curve to use for key generation
     * @returns A new UserShareEncryptionKeys instance
     */
    static fromRootSeedKey(rootSeedKey: Uint8Array, curve: Curve): Promise<UserShareEncryptionKeys>;
    static fromShareEncryptionKeysBytes(shareEncryptionKeysBytes: Uint8Array): UserShareEncryptionKeys;
    toShareEncryptionKeysBytes(): Uint8Array;
    /**
     * Gets the public key of the encrypted secret share signing keypair.
     *
     * @returns The Ed25519 public key used for signature verification
     */
    getPublicKey(): Ed25519PublicKey;
    /**
     * Gets the Sui address derived from the encrypted secret share signing keypair.
     *
     * @returns The Sui address as a string
     */
    getSuiAddress(): string;
    /**
     * Gets the raw bytes of the public key.
     *
     * @returns The raw bytes of the Ed25519 public key
     */
    getSigningPublicKeyBytes(): Uint8Array;
    /**
     * Verifies a signature over a message.
     *
     * @param message - The message to verify
     * @param signature - The signature to verify
     * @returns Promise resolving to the verification result
     */
    verifySignature(message: Uint8Array, signature: Uint8Array): Promise<boolean>;
    /**
     * Creates a signature over the encryption key using the signing keypair.
     * This signature proves ownership of the encryption key.
     *
     * @returns Promise resolving to the signature bytes
     */
    getEncryptionKeySignature(): Promise<Uint8Array>;
    /**
     * Creates a signature over the DWallet's public output.
     * This signature proves authorization to use the DWallet's encrypted share.
     *
     * @param dWallet - The DWallet to create a signature for
     * @param userPublicOutput - The user's public output from the DKG process, this is used to verify the user's public output signature.
     * @returns Promise resolving to the signature bytes
     * @throws {Error} If the DWallet is not in awaiting key holder signature state or public output is missing or the user public output does not match the DWallet public output
     */
    getUserOutputSignature(dWallet: DWallet, userPublicOutput: Uint8Array): Promise<Uint8Array>;
    /**
     * Creates a signature over the DWallet's public output for a transferred or shared DWallet.
     * This signature is later used as a fast verification method over the dWallet data (i.e. public output, against which the secret share is also verified.)
     * We do this at the time of accepting the dWallet, when we know the sender and their public key/address, against which their own signature on the public output is first verified.
     *
     * SECURITY WARNING: `sourceEncryptionKey` shouldn't be fetched from the network;
     * the public key of the sender (or its address) should be known to the receiver,
     * so that the verification here would be impactful.
     *
     * @param dWallet - The DWallet to create a signature for
     * @param sourceEncryptedUserSecretKeyShare - The encrypted user secret key share.
     * @param sourceEncryptionKey - The encryption key used to encrypt the user's secret share.
     * @returns Promise resolving to the signature bytes
     * @throws {Error} If the DWallet is not in awaiting key holder signature state or public output is missing or the user public output does not match the DWallet public output
     */
    getUserOutputSignatureForTransferredDWallet(dWallet: DWallet, sourceEncryptedUserSecretKeyShare: EncryptedUserSecretKeyShare, sourceEncryptionKey: EncryptionKey): Promise<Uint8Array>;
    /**
     * Decrypt an encrypted user secret key share for a specific DWallet.
     * This method uses the user's decryption key to recover the secret share.
     *
     * @param dWallet - The DWallet that the encrypted share belongs to
     * @param encryptedUserSecretKeyShare - The encrypted secret key share to decrypt
     * @param protocolPublicParameters - The protocol public parameters for decryption
     * @returns Promise resolving to the decrypted secret share bytes
     * @throws {Error} If decryption fails, the DWallet is not active, or verification fails
     */
    decryptUserShare(dWallet: DWallet, encryptedUserSecretKeyShare: EncryptedUserSecretKeyShare, protocolPublicParameters: Uint8Array): Promise<{
        verifiedPublicOutput: Uint8Array;
        secretShare: Uint8Array;
    }>;
    /**
     * Hashes a domain separator and root seed to produce a seed for a keypair.
     *
     * @param domainSeparator - The domain separator to use
     * @param rootSeed - The root seed to use
     * @returns The hashed seed as a Uint8Array
     */
    static hash(domainSeparator: string, rootSeed: Uint8Array, curve: Curve): Uint8Array;
}
