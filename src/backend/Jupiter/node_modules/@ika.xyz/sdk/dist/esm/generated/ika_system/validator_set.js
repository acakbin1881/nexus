import { MoveStruct, normalizeMoveArguments } from "../utils/index.js";
import { bcs } from "@mysten/sui/bcs";
import * as object_table from "./deps/sui/object_table.js";
import * as bls_committee from "./deps/ika_common/bls_committee.js";
import * as extended_field from "./deps/ika_common/extended_field.js";
import * as vec_map from "./deps/sui/vec_map.js";
import * as vec_set from "./deps/sui/vec_set.js";
import * as bag from "./deps/sui/bag.js";
import * as token_exchange_rate from "./token_exchange_rate.js";
const $moduleName = "@local-pkg/system::validator_set";
const ValidatorSet = new MoveStruct({ name: `${$moduleName}::ValidatorSet`, fields: {
  /** Total amount of stake from all active validators at the beginning of the epoch. */
  total_stake: bcs.u64(),
  /** How many reward are slashed to punish a validator, in bps. */
  reward_slashing_rate: bcs.u16(),
  /** A table that contains all validators */
  validators: object_table.ObjectTable,
  /** The current list of active committee of validators. */
  active_committee: bls_committee.BlsCommittee,
  /**
   * The next list of active committee of validators. It will become the
   * active_committee at the end of the epoch.
   */
  next_epoch_active_committee: bcs.option(bls_committee.BlsCommittee),
  /** The current list of previous committee of validators. */
  previous_committee: bls_committee.BlsCommittee,
  /**
   * The next list of pending active set of validators to be
   * next_epoch_active_committee. It will start from the last
   * next_epoch_active_committee and will be process between middle of the epochs and
   * will be finalize at the middle of the epoch.
   */
  pending_active_set: extended_field.ExtendedField,
  /**
   * A map storing the records of validator reporting each other. There is an entry
   * in the map for each validator that has been reported at least once. The entry
   * VecSet contains all the validators that reported them. If a validator has never
   * been reported they don't have an entry in this map. This map persists across
   * epoch: a peer continues being in a reported state until the reporter doesn't
   * explicitly remove their report. Note that in case we want to support validator
   * address change in future, the reports should be based on validator ids
   */
  validator_report_records: vec_map.VecMap(bcs.Address, vec_set.VecSet(bcs.Address)),
  /** Any extra fields that's not defined statically. */
  extra_fields: bag.Bag
} });
const ValidatorEpochInfoEventV1 = new MoveStruct({ name: `${$moduleName}::ValidatorEpochInfoEventV1`, fields: {
  epoch: bcs.u64(),
  validator_id: bcs.Address,
  stake: bcs.u64(),
  commission_rate: bcs.u16(),
  staking_rewards: bcs.u64(),
  token_exchange_rate: token_exchange_rate.TokenExchangeRate,
  tallying_rule_reporters: bcs.vector(bcs.Address),
  tallying_rule_global_score: bcs.u64()
} });
const ValidatorJoinEvent = new MoveStruct({ name: `${$moduleName}::ValidatorJoinEvent`, fields: {
  epoch: bcs.u64(),
  validator_id: bcs.Address
} });
const ValidatorLeaveEvent = new MoveStruct({ name: `${$moduleName}::ValidatorLeaveEvent`, fields: {
  withdrawing_epoch: bcs.u64(),
  validator_id: bcs.Address,
  is_voluntary: bcs.bool()
} });
function totalStake(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_set::ValidatorSet`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_set",
    function: "total_stake",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function validatorTotalStakeAmount(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_set::ValidatorSet`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "validatorId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_set",
    function: "validator_total_stake_amount",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function getValidator(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_set::ValidatorSet`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "validatorId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_set",
    function: "get_validator",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function activeCommittee(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_set::ValidatorSet`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_set",
    function: "active_committee",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochActiveCommittee(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_set::ValidatorSet`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_set",
    function: "next_epoch_active_committee",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function pendingActiveSet(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_set::ValidatorSet`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_set",
    function: "pending_active_set",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function isValidatorCandidate(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_set::ValidatorSet`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "validatorId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_set",
    function: "is_validator_candidate",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function isInactiveValidator(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_set::ValidatorSet`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "validatorId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_set",
    function: "is_inactive_validator",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
export {
  ValidatorEpochInfoEventV1,
  ValidatorJoinEvent,
  ValidatorLeaveEvent,
  ValidatorSet,
  activeCommittee,
  getValidator,
  isInactiveValidator,
  isValidatorCandidate,
  nextEpochActiveCommittee,
  pendingActiveSet,
  totalStake,
  validatorTotalStakeAmount
};
//# sourceMappingURL=validator_set.js.map
