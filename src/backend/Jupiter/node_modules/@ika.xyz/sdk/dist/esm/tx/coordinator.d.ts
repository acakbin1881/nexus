import type { Transaction, TransactionObjectArgument, TransactionResult } from '@mysten/sui/transactions';
import type { IkaConfig } from '../client/types.js';
export declare function registerEncryptionKeyTx(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, curve: number, encryptionKey: Uint8Array, encryptionKeySignature: Uint8Array, signerPublicKey: Uint8Array, tx: Transaction): void;
export declare function registerSessionIdentifier(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, sessionIdentifier: Uint8Array, tx: Transaction): TransactionObjectArgument;
export declare function getActiveEncryptionKey(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, address: string, tx: Transaction): TransactionObjectArgument;
export declare function approveMessage(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletCap: TransactionObjectArgument, signatureAlgorithm: number, hashScheme: number, message: Uint8Array, tx: Transaction): TransactionObjectArgument;
export declare function approveImportedKeyMessage(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, importedKeyDWalletCap: TransactionObjectArgument, signatureAlgorithm: number, hashScheme: number, message: Uint8Array, tx: Transaction): TransactionObjectArgument;
export declare function requestDWalletDKGFirstRound(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletNetworkEncryptionKeyID: string, curve: number, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): TransactionObjectArgument;
export declare function requestDWalletDKGSecondRound(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletCap: TransactionObjectArgument, userPublicKeyShareAndProof: Uint8Array, encryptedUserShareAndProof: Uint8Array, encryptionKeyAddress: string, userPublicOutput: Uint8Array, signerPublicKey: Uint8Array, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): void;
export declare function requestDWalletDKG(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletNetworkEncryptionKeyId: string, curve: number, userPublicKeyShareAndProof: Uint8Array, encryptedUserShareAndProof: Uint8Array, encryptionKeyAddress: string, userPublicOutput: Uint8Array, signerPublicKey: Uint8Array, sessionIdentifier: TransactionObjectArgument, signDuringDKGRequest: TransactionObjectArgument | null, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): TransactionResult;
export declare function requestDWalletDKGWithPublicUserSecretKeyShare(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletNetworkEncryptionKeyId: string, curve: number, userPublicKeyShareAndProof: Uint8Array, publicUserSecretKeyShare: Uint8Array, userPublicOutput: Uint8Array, sessionIdentifier: TransactionObjectArgument, signDuringDKGRequest: TransactionObjectArgument | null, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): TransactionResult;
export declare function signDuringDKGRequest(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, presignCap: TransactionObjectArgument, hashScheme: number, message: Uint8Array, messageCentralizedSignature: Uint8Array, tx: Transaction): TransactionObjectArgument;
export declare function processCheckpointMessageByQuorum(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, signature: Uint8Array, signersBitmap: Uint8Array, message: Uint8Array, tx: Transaction): TransactionObjectArgument;
export declare function initiateMidEpochReconfiguration(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, systemCurrentStatusInfo: string, tx: Transaction): void;
export declare function requestNetworkEncryptionKeyMidEpochReconfiguration(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletNetworkEncryptionKeyId: string, tx: Transaction): void;
export declare function advanceEpoch(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, advanceEpochApprover: string, tx: Transaction): void;
export declare function requestDwalletNetworkEncryptionKeyDkgByCap(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, paramsForNetwork: Uint8Array, verifiedProtocolCap: TransactionObjectArgument, tx: Transaction): void;
export declare function processCheckpointMessageByCap(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, message: Uint8Array, verifiedProtocolCap: string, tx: Transaction): TransactionObjectArgument;
export declare function setGasFeeReimbursementSuiSystemCallValueByCap(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, gasFeeReimbursementSuiSystemCallValue: number, verifiedProtocolCap: string, tx: Transaction): void;
export declare function setSupportedAndPricing(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, defaultPricing: TransactionObjectArgument, supportedCurvesToSignatureAlgorithmsToHashSchemes: TransactionObjectArgument, verifiedProtocolCap: string, tx: Transaction): void;
export declare function setPausedCurvesAndSignatureAlgorithms(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, pausedCurves: number[], pausedSignatureAlgorithms: number[], pausedHashSchemes: number[], verifiedProtocolCap: string, tx: Transaction): void;
export declare function setGlobalPresignConfig(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, curveToSignatureAlgorithmsForDkg: TransactionObjectArgument, curveToSignatureAlgorithmsForImportedKey: TransactionObjectArgument, verifiedProtocolCap: string, tx: Transaction): void;
export declare function requestLockEpochSessions(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, systemCurrentStatusInfo: string, tx: Transaction): void;
export declare function setPricingVote(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, pricing: TransactionObjectArgument, verifiedValidatorOperationCap: string, tx: Transaction): void;
export declare function calculatePricingVotes(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, curve: number, signatureAlgorithm: TransactionObjectArgument, protocol: number, tx: Transaction): void;
export declare function requestImportedKeyDwalletVerification(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletNetworkEncryptionKeyId: string, curve: number, userOutgoingMessage: Uint8Array, encryptedUserShareAndProof: Uint8Array, encryptionKeyAddress: string, userPublicOutput: Uint8Array, signerPublicKey: Uint8Array, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): TransactionObjectArgument;
export declare function requestMakeDwalletUserSecretKeySharesPublic(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletId: string, publicUserSecretKeyShare: Uint8Array, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): void;
export declare function requestReEncryptUserShareFor(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletId: string, destinationEncryptionKeyAddress: string, encryptedUserShareAndProof: Uint8Array, sourceEncryptedUserSecretKeyShareId: string, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): void;
export declare function acceptEncryptedUserShare(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletId: string, encryptedUserSecretKeyShareId: string, userOutputSignature: Uint8Array, tx: Transaction): void;
export declare function requestPresign(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletId: string, signatureAlgorithm: number, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): TransactionObjectArgument;
export declare function requestGlobalPresign(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletNetworkEncryptionKeyId: string, curve: number, signatureAlgorithm: number, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): TransactionObjectArgument;
export declare function isPresignValid(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, presignCap: string, tx: Transaction): TransactionObjectArgument;
export declare function verifyPresignCap(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, unverifiedPresignCap: TransactionObjectArgument, tx: Transaction): TransactionObjectArgument;
export declare function requestSign(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, verifiedPresignCap: TransactionObjectArgument, messageApproval: TransactionObjectArgument, messageUserSignature: Uint8Array, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): void;
export declare function requestSignAndReturnId(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, verifiedPresignCap: TransactionObjectArgument, messageApproval: TransactionObjectArgument, messageUserSignature: Uint8Array, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): TransactionObjectArgument;
export declare function requestImportedKeySign(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, verifiedPresignCap: TransactionObjectArgument, importedKeyMessageApproval: TransactionObjectArgument, messageUserSignature: Uint8Array, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): void;
export declare function requestImportedKeySignAndReturnId(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, verifiedPresignCap: TransactionObjectArgument, importedKeyMessageApproval: TransactionObjectArgument, messageUserSignature: Uint8Array, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): TransactionObjectArgument;
export declare function requestFutureSign(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletId: string, verifiedPresignCap: TransactionObjectArgument, message: Uint8Array, hashScheme: number, messageUserSignature: Uint8Array, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): TransactionObjectArgument;
export declare function isPartialUserSignatureValid(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, unverifiedPartialUserSignatureCap: string, tx: Transaction): TransactionObjectArgument;
export declare function verifyPartialUserSignatureCap(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, unverifiedPartialUserSignatureCap: TransactionObjectArgument, tx: Transaction): TransactionObjectArgument;
export declare function requestSignWithPartialUserSignature(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, verifiedPartialUserSignatureCap: TransactionObjectArgument, messageApproval: TransactionObjectArgument, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): void;
export declare function requestSignWithPartialUserSignatureAndReturnId(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, verifiedPartialUserSignatureCap: TransactionObjectArgument, messageApproval: TransactionObjectArgument, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): TransactionObjectArgument;
export declare function requestImportedKeySignWithPartialUserSignature(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, verifiedPartialUserSignatureCap: string, importedKeyMessageApproval: string, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): void;
export declare function requestImportedKeySignWithPartialUserSignatureAndReturnId(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, verifiedPartialUserSignatureCap: TransactionObjectArgument | string, importedKeyMessageApproval: TransactionObjectArgument | string, sessionIdentifier: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): TransactionObjectArgument;
export declare function matchPartialUserSignatureWithMessageApproval(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, verifiedPartialUserSignatureCap: string, messageApproval: string, tx: Transaction): TransactionObjectArgument;
export declare function matchPartialUserSignatureWithImportedKeyMessageApproval(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, verifiedPartialUserSignatureCap: string, importedKeyMessageApproval: string, tx: Transaction): TransactionObjectArgument;
export declare function hasDWallet(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletId: string, tx: Transaction): TransactionObjectArgument;
export declare function getDWallet(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, dwalletId: string, tx: Transaction): TransactionObjectArgument;
export declare function currentPricing(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, tx: Transaction): TransactionObjectArgument;
export declare function subsidizeCoordinatorWithSui(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, suiCoin: TransactionObjectArgument, tx: Transaction): void;
export declare function subsidizeCoordinatorWithIka(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, ikaCoin: TransactionObjectArgument, tx: Transaction): void;
export declare function commitUpgrade(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, upgradePackageApprover: string, tx: Transaction): void;
export declare function tryMigrateByCap(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, verifiedProtocolCap: string, tx: Transaction): void;
export declare function tryMigrate(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, tx: Transaction): void;
export declare function version(ikaConfig: IkaConfig, coordinatorObjectRef: TransactionObjectArgument, tx: Transaction): TransactionObjectArgument;
