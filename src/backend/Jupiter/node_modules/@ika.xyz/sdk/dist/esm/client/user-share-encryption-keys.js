var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _encryptedSecretShareSigningKeypair, _UserShareEncryptionKeys_instances, serializeShareEncryptionKeys_fn, _UserShareEncryptionKeys_static, parseShareEncryptionKeys_fn;
import { bcs, toHex } from "@mysten/bcs";
import { Ed25519Keypair, Ed25519PublicKey } from "@mysten/sui/keypairs/ed25519";
import { keccak_256 } from "@noble/hashes/sha3";
import {
  createClassGroupsKeypair,
  userAndNetworkDKGOutputMatch,
  verifyAndGetDWalletDKGPublicOutput
} from "./cryptography.js";
import { fromCurveToNumber, fromNumberToCurve } from "./hash-signature-validation.js";
import { encodeToASCII } from "./utils.js";
import { decrypt_user_share } from "./wasm-loader.js";
const VersionedUserShareEncryptionKeysBcs = bcs.enum("VersionedUserShareEncryptionKeys", {
  V1: bcs.struct("UserShareEncryptionKeysV1", {
    encryptionKey: bcs.vector(bcs.u8()),
    decryptionKey: bcs.vector(bcs.u8()),
    secretShareSigningSecretKey: bcs.string(),
    curve: bcs.u64()
  })
});
const _UserShareEncryptionKeys = class _UserShareEncryptionKeys {
  constructor(encryptionKey, decryptionKey, secretShareSigningSecretKey, curve) {
    __privateAdd(this, _UserShareEncryptionKeys_instances);
    /** The public encryption key used to encrypt secret shares */
    __publicField(this, "encryptionKey");
    /** The private decryption key used to decrypt secret shares */
    __publicField(this, "decryptionKey");
    /** The Ed25519 keypair used for signing encrypted secret share operations */
    __privateAdd(this, _encryptedSecretShareSigningKeypair);
    /** The curve used to generate the encryption/decryption keys */
    __publicField(this, "curve");
    this.encryptionKey = encryptionKey;
    this.decryptionKey = decryptionKey;
    __privateSet(this, _encryptedSecretShareSigningKeypair, secretShareSigningSecretKey);
    this.curve = curve;
  }
  /**
   * Creates UserShareEncryptionKeys from a root seed key (Uint8Array).
   *
   * @param rootSeedKey - The root seed key to generate keys from
   * @param curve - The curve to use for key generation
   * @returns A new UserShareEncryptionKeys instance
   */
  static async fromRootSeedKey(rootSeedKey, curve) {
    const classGroupsSeed = _UserShareEncryptionKeys.hash(
      _UserShareEncryptionKeys.domainSeparators.classGroups,
      rootSeedKey,
      curve
    );
    const encryptionSignerKeySeed = _UserShareEncryptionKeys.hash(
      _UserShareEncryptionKeys.domainSeparators.encryptionSignerKey,
      rootSeedKey,
      curve
    );
    const classGroupsKeypair = await createClassGroupsKeypair(classGroupsSeed, curve);
    const encryptionSignerKey = Ed25519Keypair.deriveKeypairFromSeed(
      toHex(encryptionSignerKeySeed)
    );
    return new _UserShareEncryptionKeys(
      new Uint8Array(classGroupsKeypair.encryptionKey),
      new Uint8Array(classGroupsKeypair.decryptionKey),
      encryptionSignerKey,
      curve
    );
  }
  static fromShareEncryptionKeysBytes(shareEncryptionKeysBytes) {
    const { encryptionKey, decryptionKey, secretShareSigningSecretKey, curve } = __privateMethod(this, _UserShareEncryptionKeys_static, parseShareEncryptionKeys_fn).call(this, shareEncryptionKeysBytes);
    const secretShareSigningKeypair = Ed25519Keypair.fromSecretKey(secretShareSigningSecretKey);
    return new _UserShareEncryptionKeys(
      encryptionKey,
      decryptionKey,
      secretShareSigningKeypair,
      curve
    );
  }
  toShareEncryptionKeysBytes() {
    return __privateMethod(this, _UserShareEncryptionKeys_instances, serializeShareEncryptionKeys_fn).call(this);
  }
  /**
   * Gets the public key of the encrypted secret share signing keypair.
   *
   * @returns The Ed25519 public key used for signature verification
   */
  getPublicKey() {
    return __privateGet(this, _encryptedSecretShareSigningKeypair).getPublicKey();
  }
  /**
   * Gets the Sui address derived from the encrypted secret share signing keypair.
   *
   * @returns The Sui address as a string
   */
  getSuiAddress() {
    return __privateGet(this, _encryptedSecretShareSigningKeypair).getPublicKey().toSuiAddress();
  }
  /**
   * Gets the raw bytes of the public key.
   *
   * @returns The raw bytes of the Ed25519 public key
   */
  getSigningPublicKeyBytes() {
    return __privateGet(this, _encryptedSecretShareSigningKeypair).getPublicKey().toRawBytes();
  }
  /**
   * Verifies a signature over a message.
   *
   * @param message - The message to verify
   * @param signature - The signature to verify
   * @returns Promise resolving to the verification result
   */
  async verifySignature(message, signature) {
    return await __privateGet(this, _encryptedSecretShareSigningKeypair).getPublicKey().verify(message, signature);
  }
  /**
   * Creates a signature over the encryption key using the signing keypair.
   * This signature proves ownership of the encryption key.
   *
   * @returns Promise resolving to the signature bytes
   */
  async getEncryptionKeySignature() {
    return await __privateGet(this, _encryptedSecretShareSigningKeypair).sign(this.encryptionKey);
  }
  /**
   * Creates a signature over the DWallet's public output.
   * This signature proves authorization to use the DWallet's encrypted share.
   *
   * @param dWallet - The DWallet to create a signature for
   * @param userPublicOutput - The user's public output from the DKG process, this is used to verify the user's public output signature.
   * @returns Promise resolving to the signature bytes
   * @throws {Error} If the DWallet is not in awaiting key holder signature state or public output is missing or the user public output does not match the DWallet public output
   */
  async getUserOutputSignature(dWallet, userPublicOutput) {
    if (!dWallet.state.AwaitingKeyHolderSignature?.public_output) {
      throw new Error("DWallet is not in awaiting key holder signature state");
    }
    const dWalletPublicOutput = Uint8Array.from(
      dWallet.state.AwaitingKeyHolderSignature?.public_output
    );
    const isOutputMatch = await userAndNetworkDKGOutputMatch(
      fromNumberToCurve(dWallet.curve),
      userPublicOutput,
      dWalletPublicOutput
    ).catch(() => false);
    if (!isOutputMatch) {
      throw new Error("User public output does not match the DWallet public output");
    }
    return await __privateGet(this, _encryptedSecretShareSigningKeypair).sign(dWalletPublicOutput);
  }
  /**
   * Creates a signature over the DWallet's public output for a transferred or shared DWallet.
   * This signature is later used as a fast verification method over the dWallet data (i.e. public output, against which the secret share is also verified.)
   * We do this at the time of accepting the dWallet, when we know the sender and their public key/address, against which their own signature on the public output is first verified.
   *
   * SECURITY WARNING: `sourceEncryptionKey` shouldn't be fetched from the network;
   * the public key of the sender (or its address) should be known to the receiver,
   * so that the verification here would be impactful.
   *
   * @param dWallet - The DWallet to create a signature for
   * @param sourceEncryptedUserSecretKeyShare - The encrypted user secret key share.
   * @param sourceEncryptionKey - The encryption key used to encrypt the user's secret share.
   * @returns Promise resolving to the signature bytes
   * @throws {Error} If the DWallet is not in awaiting key holder signature state or public output is missing or the user public output does not match the DWallet public output
   */
  async getUserOutputSignatureForTransferredDWallet(dWallet, sourceEncryptedUserSecretKeyShare, sourceEncryptionKey) {
    const dWalletPublicOutput = await verifyAndGetDWalletDKGPublicOutput(
      dWallet,
      sourceEncryptedUserSecretKeyShare,
      new Ed25519PublicKey(sourceEncryptionKey.signer_public_key)
    );
    return await __privateGet(this, _encryptedSecretShareSigningKeypair).sign(dWalletPublicOutput);
  }
  /**
   * Decrypt an encrypted user secret key share for a specific DWallet.
   * This method uses the user's decryption key to recover the secret share.
   *
   * @param dWallet - The DWallet that the encrypted share belongs to
   * @param encryptedUserSecretKeyShare - The encrypted secret key share to decrypt
   * @param protocolPublicParameters - The protocol public parameters for decryption
   * @returns Promise resolving to the decrypted secret share bytes
   * @throws {Error} If decryption fails, the DWallet is not active, or verification fails
   */
  async decryptUserShare(dWallet, encryptedUserSecretKeyShare, protocolPublicParameters) {
    const dWalletPublicOutput = await verifyAndGetDWalletDKGPublicOutput(
      dWallet,
      encryptedUserSecretKeyShare,
      __privateGet(this, _encryptedSecretShareSigningKeypair).getPublicKey()
    );
    return {
      verifiedPublicOutput: dWalletPublicOutput,
      secretShare: Uint8Array.from(
        await decrypt_user_share(
          fromCurveToNumber(this.curve),
          this.decryptionKey,
          dWalletPublicOutput,
          Uint8Array.from(encryptedUserSecretKeyShare.encrypted_centralized_secret_share_and_proof),
          protocolPublicParameters
        )
      )
    };
  }
  /**
   * Hashes a domain separator and root seed to produce a seed for a keypair.
   *
   * @param domainSeparator - The domain separator to use
   * @param rootSeed - The root seed to use
   * @returns The hashed seed as a Uint8Array
   */
  static hash(domainSeparator, rootSeed, curve) {
    return new Uint8Array(
      keccak_256(Uint8Array.from([...encodeToASCII(domainSeparator), curve, ...rootSeed]))
    );
  }
};
_encryptedSecretShareSigningKeypair = new WeakMap();
_UserShareEncryptionKeys_instances = new WeakSet();
serializeShareEncryptionKeys_fn = function() {
  return VersionedUserShareEncryptionKeysBcs.serialize({
    V1: {
      encryptionKey: this.encryptionKey,
      decryptionKey: this.decryptionKey,
      secretShareSigningSecretKey: __privateGet(this, _encryptedSecretShareSigningKeypair).getSecretKey(),
      curve: fromCurveToNumber(this.curve)
    }
  }).toBytes();
};
_UserShareEncryptionKeys_static = new WeakSet();
parseShareEncryptionKeys_fn = function(shareEncryptionKeysBytes) {
  const {
    V1: { encryptionKey, decryptionKey, secretShareSigningSecretKey, curve }
  } = VersionedUserShareEncryptionKeysBcs.parse(shareEncryptionKeysBytes);
  return {
    encryptionKey: new Uint8Array(encryptionKey),
    decryptionKey: new Uint8Array(decryptionKey),
    secretShareSigningSecretKey,
    curve: fromNumberToCurve(Number(curve))
  };
};
__privateAdd(_UserShareEncryptionKeys, _UserShareEncryptionKeys_static);
__publicField(_UserShareEncryptionKeys, "domainSeparators", {
  classGroups: "CLASS_GROUPS_DECRYPTION_KEY_V1",
  encryptionSignerKey: "ED25519_SIGNING_KEY_V1"
});
let UserShareEncryptionKeys = _UserShareEncryptionKeys;
export {
  UserShareEncryptionKeys,
  VersionedUserShareEncryptionKeysBcs
};
//# sourceMappingURL=user-share-encryption-keys.js.map
