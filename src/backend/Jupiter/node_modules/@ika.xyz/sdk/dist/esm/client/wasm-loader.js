let wasmModule = null;
let initPromise = null;
const isNode = typeof process !== "undefined" && !!process.versions?.node;
async function ensureWasmInitialized() {
  if (wasmModule) return;
  if (!initPromise) initPromise = init();
  await initPromise;
}
async function init() {
  const mod = await import("@ika.xyz/ika-wasm");
  if (isNode) {
    const normalized = mod && typeof mod === "object" && "default" in mod ? mod.default : mod;
    if (typeof normalized.generate_secp_cg_keypair_from_seed !== "function") {
      throw new Error("ika-wasm node glue not initialized (wrong target?)");
    }
    wasmModule = normalized;
    return;
  }
  const initFn = mod.default ?? mod.init;
  if (typeof initFn !== "function") throw new Error("ika-wasm web glue missing init()");
  await initFn();
  wasmModule = mod;
}
async function getWasmModule() {
  await ensureWasmInitialized();
  return wasmModule;
}
async function encrypt_secret_share(curve, userSecretKeyShare, encryptionKey, protocolPublicParameters) {
  const wasm = await getWasmModule();
  return wasm.encrypt_secret_share(
    curve,
    userSecretKeyShare,
    encryptionKey,
    protocolPublicParameters
  );
}
async function verify_user_share(curve, userSecretKeyShare, userDKGOutput, networkDkgPublicOutput) {
  const wasm = await getWasmModule();
  return wasm.verify_user_share(curve, userSecretKeyShare, userDKGOutput, networkDkgPublicOutput);
}
async function generate_secp_cg_keypair_from_seed(curve, seed) {
  const wasm = await getWasmModule();
  return wasm.generate_secp_cg_keypair_from_seed(curve, seed);
}
async function create_dkg_centralized_output_v1(protocolPublicParameters, networkFirstRoundOutput) {
  const wasm = await getWasmModule();
  return wasm.create_dkg_centralized_output_v1(protocolPublicParameters, networkFirstRoundOutput);
}
async function create_dkg_centralized_output_v2(curve, protocolPublicParameters, session_id) {
  const wasm = await getWasmModule();
  return wasm.create_dkg_centralized_output_v2(curve, protocolPublicParameters, session_id);
}
async function create_sign_centralized_party_message(protocolPublicParameters, publicOutput, userSecretKeyShare, presign, message, hash, signatureScheme, curve) {
  const wasm = await getWasmModule();
  return wasm.create_sign_centralized_party_message(
    protocolPublicParameters,
    publicOutput,
    userSecretKeyShare,
    presign,
    message,
    curve,
    signatureScheme,
    hash
  );
}
async function create_sign_centralized_party_message_with_centralized_party_dkg_output(protocolPublicParameters, centralizedDkgOutput, userSecretKeyShare, presign, message, hash, signatureScheme, curve) {
  const wasm = await getWasmModule();
  return wasm.create_sign_centralized_party_message_with_centralized_party_dkg_output(
    protocolPublicParameters,
    centralizedDkgOutput,
    userSecretKeyShare,
    presign,
    message,
    hash,
    signatureScheme,
    curve
  );
}
async function network_dkg_public_output_to_protocol_pp(curve, networkDkgPublicOutput) {
  const wasm = await getWasmModule();
  return wasm.network_dkg_public_output_to_protocol_pp(curve, networkDkgPublicOutput);
}
async function verify_secp_signature(publicKey, signature, message, networkDkgPublicOutput, hash, signatureAlgorithm, curve) {
  const wasm = await getWasmModule();
  return wasm.verify_secp_signature(
    publicKey,
    signature,
    message,
    networkDkgPublicOutput,
    curve,
    signatureAlgorithm,
    hash
  );
}
async function public_key_from_dwallet_output(curve, dWalletOutput) {
  const wasm = await getWasmModule();
  return wasm.public_key_from_dwallet_output(curve, dWalletOutput);
}
async function public_key_from_centralized_dkg_output(curve, centralizedDkgOutput) {
  const wasm = await getWasmModule();
  return wasm.public_key_from_centralized_dkg_output(curve, centralizedDkgOutput);
}
async function reconfiguration_public_output_to_protocol_pp(curve, reconfig_public_output, network_dkg_public_output) {
  const wasm = await getWasmModule();
  return wasm.reconfiguration_public_output_to_protocol_pp(
    curve,
    reconfig_public_output,
    network_dkg_public_output
  );
}
async function centralized_and_decentralized_parties_dkg_output_match(curve, userPublicOutput, networkDKGOutput) {
  const wasm = await getWasmModule();
  return wasm.centralized_and_decentralized_parties_dkg_output_match(
    curve,
    userPublicOutput,
    networkDKGOutput
  );
}
async function create_imported_dwallet_centralized_step(curve, protocolPublicParameters, sessionIdentifier, secretKey) {
  const wasm = await getWasmModule();
  return wasm.create_imported_dwallet_centralized_step(
    curve,
    protocolPublicParameters,
    sessionIdentifier,
    secretKey
  );
}
async function decrypt_user_share(curve, decryptionKey, dWalletPublicOutput, encryptedShare, protocolPublicParameters) {
  const wasm = await getWasmModule();
  return wasm.decrypt_user_share(
    curve,
    decryptionKey,
    dWalletPublicOutput,
    encryptedShare,
    protocolPublicParameters
  );
}
async function parse_signature_from_sign_output(curve, signatureAlgorithm, signatureOutput) {
  const wasm = await getWasmModule();
  return wasm.parse_signature_from_sign_output(curve, signatureAlgorithm, signatureOutput);
}
async function initializeWasm() {
  await ensureWasmInitialized();
}
export {
  centralized_and_decentralized_parties_dkg_output_match,
  create_dkg_centralized_output_v1,
  create_dkg_centralized_output_v2,
  create_imported_dwallet_centralized_step,
  create_sign_centralized_party_message,
  create_sign_centralized_party_message_with_centralized_party_dkg_output,
  decrypt_user_share,
  encrypt_secret_share,
  ensureWasmInitialized,
  generate_secp_cg_keypair_from_seed,
  initializeWasm,
  network_dkg_public_output_to_protocol_pp,
  parse_signature_from_sign_output,
  public_key_from_centralized_dkg_output,
  public_key_from_dwallet_output,
  reconfiguration_public_output_to_protocol_pp,
  verify_secp_signature,
  verify_user_share
};
//# sourceMappingURL=wasm-loader.js.map
