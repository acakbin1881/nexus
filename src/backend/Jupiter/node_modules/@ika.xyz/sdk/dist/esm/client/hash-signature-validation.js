import { Curve, Hash, SignatureAlgorithm } from "./types.js";
const VALID_HASH_SIGNATURE_COMBINATIONS = {
  [SignatureAlgorithm.ECDSASecp256k1]: [Hash.KECCAK256, Hash.SHA256, Hash.DoubleSHA256],
  [SignatureAlgorithm.Taproot]: [Hash.SHA256],
  [SignatureAlgorithm.ECDSASecp256r1]: [Hash.SHA256],
  [SignatureAlgorithm.EdDSA]: [Hash.SHA512],
  [SignatureAlgorithm.SchnorrkelSubstrate]: [Hash.Merlin]
};
const SIGNATURE_ALGORITHM_TO_CURVE = {
  [SignatureAlgorithm.ECDSASecp256k1]: Curve.SECP256K1,
  [SignatureAlgorithm.Taproot]: Curve.SECP256K1,
  [SignatureAlgorithm.ECDSASecp256r1]: Curve.SECP256R1,
  [SignatureAlgorithm.EdDSA]: Curve.ED25519,
  [SignatureAlgorithm.SchnorrkelSubstrate]: Curve.RISTRETTO
};
const SIGNATURE_ALGORITHM_ABSOLUTE_NUMBERS = {
  [SignatureAlgorithm.ECDSASecp256k1]: 0,
  [SignatureAlgorithm.Taproot]: 1,
  [SignatureAlgorithm.ECDSASecp256r1]: 2,
  [SignatureAlgorithm.EdDSA]: 3,
  [SignatureAlgorithm.SchnorrkelSubstrate]: 4
};
const HASH_ABSOLUTE_NUMBERS = {
  [Hash.KECCAK256]: 0,
  [Hash.SHA256]: 1,
  [Hash.DoubleSHA256]: 2,
  [Hash.SHA512]: 3,
  [Hash.Merlin]: 4
};
const CURVE_SIGNATURE_HASH_CONFIG = {
  [Curve.SECP256K1]: {
    curveNumber: 0,
    signatureAlgorithms: {
      [SignatureAlgorithm.ECDSASecp256k1]: {
        signatureAlgorithmNumber: 0,
        hashes: {
          [Hash.KECCAK256]: 0,
          [Hash.SHA256]: 1,
          [Hash.DoubleSHA256]: 2
        }
      },
      [SignatureAlgorithm.Taproot]: {
        signatureAlgorithmNumber: 1,
        hashes: {
          [Hash.SHA256]: 0
        }
      }
    }
  },
  [Curve.SECP256R1]: {
    curveNumber: 1,
    signatureAlgorithms: {
      [SignatureAlgorithm.ECDSASecp256r1]: {
        signatureAlgorithmNumber: 0,
        hashes: {
          [Hash.SHA256]: 0
        }
      }
    }
  },
  [Curve.ED25519]: {
    curveNumber: 2,
    signatureAlgorithms: {
      [SignatureAlgorithm.EdDSA]: {
        signatureAlgorithmNumber: 0,
        hashes: {
          [Hash.SHA512]: 0
        }
      }
    }
  },
  [Curve.RISTRETTO]: {
    curveNumber: 3,
    signatureAlgorithms: {
      [SignatureAlgorithm.SchnorrkelSubstrate]: {
        signatureAlgorithmNumber: 0,
        hashes: {
          [Hash.Merlin]: 0
        }
      }
    }
  }
};
function getHashName(hash) {
  switch (hash) {
    case Hash.KECCAK256:
      return "KECCAK256 (SHA3)";
    case Hash.SHA256:
      return "SHA256";
    case Hash.DoubleSHA256:
      return "DoubleSHA256";
    case Hash.SHA512:
      return "SHA512";
    case Hash.Merlin:
      return "Merlin";
    default:
      return `Unknown Hash (${hash})`;
  }
}
function getSignatureAlgorithmName(signatureAlgorithm) {
  switch (signatureAlgorithm) {
    case SignatureAlgorithm.ECDSASecp256k1:
      return "ECDSASecp256k1";
    case SignatureAlgorithm.Taproot:
      return "Taproot";
    case SignatureAlgorithm.ECDSASecp256r1:
      return "ECDSASecp256r1";
    case SignatureAlgorithm.EdDSA:
      return "EdDSA";
    case SignatureAlgorithm.SchnorrkelSubstrate:
      return "SchnorrkelSubstrate (Ristretto)";
    default:
      return `Unknown SignatureAlgorithm (${signatureAlgorithm})`;
  }
}
function getCurveName(curve) {
  switch (curve) {
    case Curve.SECP256K1:
      return "secp256k1";
    case Curve.SECP256R1:
      return "secp256r1";
    case Curve.ED25519:
      return "Ed25519";
    case Curve.RISTRETTO:
      return "Ristretto";
    default:
      return `Unknown Curve (${curve})`;
  }
}
function validateHashSignatureCombination(hash, signatureAlgorithm) {
  const validHashes = VALID_HASH_SIGNATURE_COMBINATIONS[signatureAlgorithm];
  if (!validHashes.includes(hash)) {
    const supportedHashNames = validHashes.map(getHashName).join(", ");
    throw new Error(
      `Invalid hash and signature algorithm combination: ${getSignatureAlgorithmName(signatureAlgorithm)} does not support ${getHashName(hash)}. Supported hash algorithms for ${getSignatureAlgorithmName(signatureAlgorithm)}: ${supportedHashNames}`
    );
  }
}
function validateCurveSignatureAlgorithm(curve, signatureAlgorithm) {
  const expectedCurve = SIGNATURE_ALGORITHM_TO_CURVE[signatureAlgorithm];
  if (curve !== expectedCurve) {
    throw new Error(
      `Invalid curve and signature algorithm combination: ${getSignatureAlgorithmName(signatureAlgorithm)} requires ${getCurveName(expectedCurve)}, but ${getCurveName(curve)} was provided.`
    );
  }
}
function isValidHashForSignature(hash, signatureAlgorithm) {
  const validHashes = VALID_HASH_SIGNATURE_COMBINATIONS[signatureAlgorithm];
  return validHashes.includes(hash);
}
function createValidatedSigningParams(hashScheme, signatureAlgorithm) {
  validateHashSignatureCombination(hashScheme, signatureAlgorithm);
  return { hashScheme, signatureAlgorithm };
}
function getValidHashesForSignatureAlgorithm(signatureAlgorithm) {
  const validHashes = VALID_HASH_SIGNATURE_COMBINATIONS[signatureAlgorithm];
  return validHashes.map(getHashName);
}
function fromCurveToNumber(curve) {
  const config = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!config) {
    throw new Error(`Unknown curve: ${curve}`);
  }
  return config.curveNumber;
}
function fromSignatureAlgorithmToNumber(curve, signatureAlgorithm) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) {
    throw new Error(`Unknown curve: ${curve}`);
  }
  const signatureAlgorithms = curveConfig.signatureAlgorithms;
  const signatureConfig = signatureAlgorithms[signatureAlgorithm];
  if (!signatureConfig) {
    throw new Error(
      `Invalid signature algorithm ${signatureAlgorithm} for curve ${curve}. Valid algorithms: ${Object.keys(curveConfig.signatureAlgorithms).join(", ")}`
    );
  }
  return signatureConfig.signatureAlgorithmNumber;
}
function fromHashToNumber(curve, signatureAlgorithm, hash) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) {
    throw new Error(`Unknown curve: ${curve}`);
  }
  const signatureAlgorithms = curveConfig.signatureAlgorithms;
  const signatureConfig = signatureAlgorithms[signatureAlgorithm];
  if (!signatureConfig) {
    throw new Error(
      `Invalid signature algorithm ${signatureAlgorithm} for curve ${curve}. Valid algorithms: ${Object.keys(curveConfig.signatureAlgorithms).join(", ")}`
    );
  }
  const hashes = signatureConfig.hashes;
  const hashNumber = hashes[hash];
  if (hashNumber === void 0) {
    throw new Error(
      `Invalid hash ${hash} for ${signatureAlgorithm} on ${curve}. Valid hashes: ${Object.keys(signatureConfig.hashes).join(", ")}`
    );
  }
  return hashNumber;
}
function fromCurveAndSignatureAlgorithmToNumbers(curve, signatureAlgorithm) {
  const curveNumber = fromCurveToNumber(curve);
  const signatureAlgorithmNumber = fromSignatureAlgorithmToNumber(curve, signatureAlgorithm);
  return {
    curveNumber,
    signatureAlgorithmNumber
  };
}
function fromCurveAndSignatureAlgorithmAndHashToNumbers(curve, signatureAlgorithm, hash) {
  const curveNumber = fromCurveToNumber(curve);
  const signatureAlgorithmNumber = fromSignatureAlgorithmToNumber(curve, signatureAlgorithm);
  const hashNumber = fromHashToNumber(curve, signatureAlgorithm, hash);
  return {
    curveNumber,
    signatureAlgorithmNumber,
    hashNumber
  };
}
function isValidSignatureAlgorithmForCurve(curve, signatureAlgorithm) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) return false;
  return signatureAlgorithm in curveConfig.signatureAlgorithms;
}
function isValidHashForCurveAndSignature(curve, signatureAlgorithm, hash) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) return false;
  const signatureAlgorithms = curveConfig.signatureAlgorithms;
  const signatureConfig = signatureAlgorithms[signatureAlgorithm];
  if (!signatureConfig) return false;
  const hashes = signatureConfig.hashes;
  return hash in hashes;
}
function getValidSignatureAlgorithmsForCurve(curve) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) return [];
  return Object.keys(curveConfig.signatureAlgorithms);
}
function getValidHashesForCurveAndSignature(curve, signatureAlgorithm) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) return [];
  const signatureAlgorithms = curveConfig.signatureAlgorithms;
  const signatureConfig = signatureAlgorithms[signatureAlgorithm];
  if (!signatureConfig) return [];
  return Object.keys(signatureConfig.hashes);
}
function fromNumberToCurve(curveNumber) {
  for (const [curve, config] of Object.entries(CURVE_SIGNATURE_HASH_CONFIG)) {
    if (config.curveNumber === curveNumber) {
      return curve;
    }
  }
  throw new Error(`Unknown curve number: ${curveNumber}`);
}
function fromAbsoluteNumberToSignatureAlgorithm(absoluteNumber) {
  for (const [signatureAlgorithm, number] of Object.entries(SIGNATURE_ALGORITHM_ABSOLUTE_NUMBERS)) {
    if (number === absoluteNumber) {
      return signatureAlgorithm;
    }
  }
  throw new Error(`Unknown absolute signature algorithm number: ${absoluteNumber}`);
}
function fromSignatureAlgorithmToAbsoluteNumber(signatureAlgorithm) {
  const absoluteNumber = SIGNATURE_ALGORITHM_ABSOLUTE_NUMBERS[signatureAlgorithm];
  if (absoluteNumber === void 0) {
    throw new Error(`Unknown signature algorithm: ${signatureAlgorithm}`);
  }
  return absoluteNumber;
}
function fromAbsoluteNumberToHash(absoluteNumber) {
  for (const [hash, number] of Object.entries(HASH_ABSOLUTE_NUMBERS)) {
    if (number === absoluteNumber) {
      return hash;
    }
  }
  throw new Error(`Unknown absolute hash number: ${absoluteNumber}`);
}
function fromHashToAbsoluteNumber(hash) {
  const absoluteNumber = HASH_ABSOLUTE_NUMBERS[hash];
  if (absoluteNumber === void 0) {
    throw new Error(`Unknown hash: ${hash}`);
  }
  return absoluteNumber;
}
function fromNumberToSignatureAlgorithm(curve, signatureAlgorithmNumber) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) {
    throw new Error(`Unknown curve: ${curve}`);
  }
  const signatureAlgorithms = curveConfig.signatureAlgorithms;
  for (const [signatureAlgorithm, config] of Object.entries(signatureAlgorithms)) {
    if (config.signatureAlgorithmNumber === signatureAlgorithmNumber) {
      return signatureAlgorithm;
    }
  }
  throw new Error(
    `Unknown signature algorithm number ${signatureAlgorithmNumber} for curve ${curve}`
  );
}
function fromNumberToHash(curve, signatureAlgorithm, hashNumber) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) {
    throw new Error(`Unknown curve: ${curve}`);
  }
  const signatureAlgorithms = curveConfig.signatureAlgorithms;
  const signatureConfig = signatureAlgorithms[signatureAlgorithm];
  if (!signatureConfig) {
    throw new Error(`Invalid signature algorithm ${signatureAlgorithm} for curve ${curve}`);
  }
  const hashes = signatureConfig.hashes;
  for (const [hash, number] of Object.entries(hashes)) {
    if (number === hashNumber) {
      return hash;
    }
  }
  throw new Error(`Unknown hash number ${hashNumber} for ${signatureAlgorithm} on ${curve}`);
}
function fromNumbersToCurveAndSignatureAlgorithm(curveNumber, signatureAlgorithmNumber) {
  const curve = fromNumberToCurve(curveNumber);
  const signatureAlgorithm = fromNumberToSignatureAlgorithm(curve, signatureAlgorithmNumber);
  return {
    curve,
    signatureAlgorithm
  };
}
function fromNumbersToCurveAndSignatureAlgorithmAndHash(curveNumber, signatureAlgorithmNumber, hashNumber) {
  const curve = fromNumberToCurve(curveNumber);
  const signatureAlgorithm = fromNumberToSignatureAlgorithm(curve, signatureAlgorithmNumber);
  const hash = fromNumberToHash(curve, signatureAlgorithm, hashNumber);
  return {
    curve,
    signatureAlgorithm,
    hash
  };
}
export {
  createValidatedSigningParams,
  fromAbsoluteNumberToHash,
  fromAbsoluteNumberToSignatureAlgorithm,
  fromCurveAndSignatureAlgorithmAndHashToNumbers,
  fromCurveAndSignatureAlgorithmToNumbers,
  fromCurveToNumber,
  fromHashToAbsoluteNumber,
  fromHashToNumber,
  fromNumberToCurve,
  fromNumberToHash,
  fromNumberToSignatureAlgorithm,
  fromNumbersToCurveAndSignatureAlgorithm,
  fromNumbersToCurveAndSignatureAlgorithmAndHash,
  fromSignatureAlgorithmToAbsoluteNumber,
  fromSignatureAlgorithmToNumber,
  getCurveName,
  getHashName,
  getSignatureAlgorithmName,
  getValidHashesForCurveAndSignature,
  getValidHashesForSignatureAlgorithm,
  getValidSignatureAlgorithmsForCurve,
  isValidHashForCurveAndSignature,
  isValidHashForSignature,
  isValidSignatureAlgorithmForCurve,
  validateCurveSignatureAlgorithm,
  validateHashSignatureCombination
};
//# sourceMappingURL=hash-signature-validation.js.map
