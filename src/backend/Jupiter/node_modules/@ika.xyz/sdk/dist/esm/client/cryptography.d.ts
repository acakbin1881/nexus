import type { PublicKey } from '@mysten/sui/cryptography';
import type { ValidHashForSignature, ValidSignatureAlgorithmForCurve } from './hash-signature-validation.js';
import type { IkaClient } from './ika-client.js';
import type { DWallet, EncryptedUserSecretKeyShare } from './types.js';
import { Curve } from './types.js';
import type { UserShareEncryptionKeys } from './user-share-encryption-keys.js';
/**
 * Prepared data for the second round of Distributed Key Generation (DKG).
 * Contains all cryptographic outputs needed to complete the DKG process.
 *
 * SECURITY WARNING: *secret key share must be kept private!* never send it to anyone, or store it anywhere unencrypted.
 */
export interface DKGRequestInput {
    /** The user's public key share along with its zero-knowledge proof */
    userDKGMessage: Uint8Array;
    /** The user's public output from the DKG process */
    userPublicOutput: Uint8Array;
    /** The encrypted user share with its proof of correct encryption */
    encryptedUserShareAndProof: Uint8Array;
    /** The raw secret key share (user share) */
    userSecretKeyShare: Uint8Array;
}
/**
 * Prepared data for importing an existing cryptographic key as a DWallet.
 * Contains verification data needed to prove ownership of the imported key.
 */
export interface ImportDWalletVerificationRequestInput {
    /** The public output that can be verified against the imported key */
    userPublicOutput: Uint8Array;
    /** The outgoing message for the verification protocol */
    userMessage: Uint8Array;
    /** The encrypted user share with proof for the imported key */
    encryptedUserShareAndProof: Uint8Array;
}
/**
 * Create a class groups keypair from a seed for encryption/decryption operations.
 * Uses SECP256k1, SECP256r1, Ristretto, or ED25519 curves with class groups for homomorphic encryption capabilities.
 *
 * @param seed - The seed bytes to generate the keypair from
 * @param curve - The curve to use for key generation
 * @returns Object containing the encryption key (public) and decryption key (private)
 */
export declare function createClassGroupsKeypair(seed: Uint8Array, curve: Curve): Promise<{
    encryptionKey: Uint8Array;
    decryptionKey: Uint8Array;
}>;
/**
 * Create the user's output and message for the Distributed Key Generation (DKG) protocol.
 * This function takes the first round output and produces the user's contribution.
 *
 * SECURITY WARNING: *secret key share must be kept private!* never send it to anyone, or store it anywhere unencrypted.
 *
 * @param protocolPublicParameters - The protocol public parameters for decryption
 * @param networkFirstRoundOutput - The output from the network's first round of DKG
 * @param sessionIdentifier - Unique identifier for this DKG session
 * @returns Object containing the user's DKG message, public output, and secret key share
 *
 */
export declare function createDKGUserOutput(protocolPublicParameters: Uint8Array, networkFirstRoundOutput: Uint8Array): Promise<{
    userDKGMessage: Uint8Array;
    userPublicOutput: Uint8Array;
    userSecretKeyShare: Uint8Array;
}>;
/**
 * Encrypt a secret share using the provided encryption key.
 * This creates an encrypted share that can only be decrypted by the corresponding decryption key.
 *
 * @param curve - The curve to use for encryption
 * @param userSecretKeyShare - The secret key share to encrypt
 * @param encryptionKey - The public encryption key to encrypt with
 * @param protocolPublicParameters - The protocol public parameters for encryption
 * @returns The encrypted secret share with proof of correct encryption
 */
export declare function encryptSecretShare(curve: Curve, userSecretKeyShare: Uint8Array, encryptionKey: Uint8Array, protocolPublicParameters: Uint8Array): Promise<Uint8Array>;
/**
 * @deprecated Use prepareDKG instead
 *
 * @param _protocolPublicParameters - The protocol public parameters
 * @param _dWallet - The DWallet object containing first round output
 * @param _encryptionKey - The user's public encryption key
 * @returns Complete prepared data for the second DKG round
 * @throws {Error} If the first round output is not available in the DWallet
 *
 * SECURITY WARNING: *secret key share must be kept private!* never send it to anyone, or store it anywhere unencrypted.
 */
export declare function prepareDKGSecondRound(_protocolPublicParameters: Uint8Array, _dWallet: DWallet, _encryptionKey: Uint8Array): Promise<DKGRequestInput>;
/**
 * Prepare all cryptographic data needed for DKG.
 *
 * @param protocolPublicParameters - The protocol public parameters
 * @param curve - The curve to use for key generation
 * @param encryptionKey - The user's public encryption key
 * @param bytesToHash - The bytes to hash for session identifier generation
 * @param senderAddress - The sender address for session identifier generation
 * @returns Complete prepared data for DKG including user message, public output, encrypted share, and secret key share
 *
 * SECURITY WARNING: *secret key share must be kept private!* never send it to anyone, or store it anywhere unencrypted.
 */
export declare function prepareDKG(protocolPublicParameters: Uint8Array, curve: Curve, encryptionKey: Uint8Array, bytesToHash: Uint8Array, senderAddress: string): Promise<DKGRequestInput>;
/**
 * @deprecated Use prepareDKGAsync instead
 *
 * @param ikaClient - The IkaClient instance to fetch network parameters from
 * @param dWallet - The DWallet object containing first round output
 * @param userShareEncryptionKeys - The user's encryption keys for securing the user's share
 * @returns Promise resolving to complete prepared data for the second DKG round
 * @throws {Error} If the first round output is not available or network parameters cannot be fetched
 *
 * SECURITY WARNING: *secret key share must be kept private!* never send it to anyone, or store it anywhere unencrypted.
 */
export declare function prepareDKGSecondRoundAsync(_ikaClient: IkaClient, _dWallet: DWallet, _userShareEncryptionKeys: UserShareEncryptionKeys): Promise<DKGRequestInput>;
/**
 * Prepare all cryptographic data needed for DKG (async version that fetches protocol parameters).
 *
 * @param ikaClient - The IkaClient instance to fetch network parameters from
 * @param curve - The curve to use for key generation
 * @param userShareEncryptionKeys - The user's encryption keys for securing the user's share
 * @param bytesToHash - The bytes to hash for session identifier generation
 * @param senderAddress - The sender address for session identifier generation
 * @returns Promise resolving to complete prepared data for DKG including user message, public output, encrypted share, and secret key share
 * @throws {Error} If network parameters cannot be fetched
 *
 * SECURITY WARNING: *secret key share must be kept private!* never send it to anyone, or store it anywhere unencrypted.
 */
export declare function prepareDKGAsync(ikaClient: IkaClient, curve: Curve, userShareEncryptionKeys: UserShareEncryptionKeys, bytesToHash: Uint8Array, senderAddress: string): Promise<DKGRequestInput>;
/**
 * Prepare verification data for importing an existing cryptographic key as a DWallet.
 * This function creates all necessary proofs and encrypted data for the import process.
 *
 * @param ikaClient - The IkaClient instance to fetch network parameters from
 * @param curve - The curve to use for key generation
 * @param bytesToHash - The bytes to hash for session identifier generation
 * @param senderAddress - The sender address for session identifier generation
 * @param userShareEncryptionKeys - The user's encryption keys for securing the imported share
 * @param privateKey - The existing private key to import as a DWallet
 * @returns Promise resolving to complete verification data for the import process including user public output, message, and encrypted share
 * @throws {Error} If network parameters cannot be fetched or key import preparation fails
 */
export declare function prepareImportedKeyDWalletVerification(ikaClient: IkaClient, curve: Curve, bytesToHash: Uint8Array, senderAddress: string, userShareEncryptionKeys: UserShareEncryptionKeys, privateKey: Uint8Array): Promise<ImportDWalletVerificationRequestInput>;
/**
 * Create the user's sign message for the signature generation process.
 * This function combines the user's secret key, presign, and message to create a sign message to be sent to the network.
 *
 * This function is used when developer has access to the user's public output which should be verified before using this method.
 *
 * @param protocolPublicParameters - The protocol public parameters
 * @param publicOutput - The user's public output
 * @param userSecretKeyShare - The user's secret key share
 * @param presign - The presignature data from a completed presign operation
 * @param message - The message bytes to sign
 * @param hash - The hash scheme to use for signing
 * @param signatureAlgorithm - The signature algorithm to use
 * @param curve - The curve to use
 * @returns The user's sign message that will be sent to the network for signature generation
 */
export declare function createUserSignMessageWithPublicOutput<C extends Curve, S extends ValidSignatureAlgorithmForCurve<C>, H extends ValidHashForSignature<S>>(protocolPublicParameters: Uint8Array, publicOutput: Uint8Array, userSecretKeyShare: Uint8Array, presign: Uint8Array, message: Uint8Array, hash: H, signatureAlgorithm: S, curve: C): Promise<Uint8Array>;
/**
 * Create the user's sign message for the signature generation process.
 * This function combines the user's secret key, presign, and message to create a sign message to be sent to the network.
 *
 * This function is used when developer has access to the centralized DKG output which should be verified before using this method.
 *
 * @param protocolPublicParameters - The protocol public parameters
 * @param centralizedDkgOutput - The centralized DKG output
 * @param userSecretKeyShare - The user's secret key share
 * @param presign - The presignature data from a completed presign operation
 * @param message - The message bytes to sign
 * @param hash - The hash scheme to use for signing
 * @param signatureAlgorithm - The signature algorithm to use
 * @param curve - The curve to use
 * @returns The user's sign message that will be sent to the network for signature generation
 */
export declare function createUserSignMessageWithCentralizedOutput<C extends Curve, S extends ValidSignatureAlgorithmForCurve<C>, H extends ValidHashForSignature<S>>(protocolPublicParameters: Uint8Array, centralizedDkgOutput: Uint8Array, userSecretKeyShare: Uint8Array, presign: Uint8Array, message: Uint8Array, hash: H, signatureAlgorithm: S, curve: C): Promise<Uint8Array>;
/**
 * Convert a network DKG public output to the protocol public parameters.
 *
 * @param curve - The curve to use for key generation
 * @param network_dkg_public_output - The network DKG public output
 * @returns The protocol public parameters
 */
export declare function networkDkgPublicOutputToProtocolPublicParameters(curve: Curve, network_dkg_public_output: Uint8Array): Promise<Uint8Array>;
/**
 * Convert a reconfiguration DKG public output to the protocol public parameters.
 *
 * @param curve - The curve to use for key generation
 * @param reconfiguration_public_output - The reconfiguration DKG public output
 * @param network_dkg_public_output - The network DKG public output
 * @returns The protocol public parameters
 */
export declare function reconfigurationPublicOutputToProtocolPublicParameters(curve: Curve, reconfiguration_public_output: Uint8Array, network_dkg_public_output: Uint8Array): Promise<Uint8Array>;
/**
 * Verify a user's secret key share.
 *
 * @param curve - The curve to use for key generation
 * @param userSecretKeyShare - The user's unencrypted secret key share
 * @param userDKGOutput - The user's DKG output
 * @param networkDkgPublicOutput - The network DKG public output
 * @returns True if the user's secret key share is valid, false otherwise
 */
export declare function verifyUserShare(curve: Curve, userSecretKeyShare: Uint8Array, userDKGOutput: Uint8Array, networkDkgPublicOutput: Uint8Array): Promise<boolean>;
/**
 * Verify a signature.
 *
 * @param publicKey - The public key bytes
 * @param signature - The signature bytes to verify
 * @param message - The message bytes that was signed
 * @param networkDkgPublicOutput - The network DKG public output
 * @param hash - The hash scheme to use for verification
 * @param signatureAlgorithm - The signature algorithm to use
 * @param curve - The curve to use
 * @returns True if the signature is valid, false otherwise
 */
export declare function verifySecpSignature<C extends Curve, S extends ValidSignatureAlgorithmForCurve<C>, H extends ValidHashForSignature<S>>(publicKey: Uint8Array, signature: Uint8Array, message: Uint8Array, networkDkgPublicOutput: Uint8Array, hash: H, signatureAlgorithm: S, curve: C): Promise<boolean>;
/**
 * Create a public key from a DWallet output.
 *
 * @param curve - The curve to use for key generation
 * @param dWalletOutput - The DWallet output
 *
 * @returns The BCS-encoded public key
 */
export declare function publicKeyFromDWalletOutput(curve: Curve, dWalletOutput: Uint8Array): Promise<Uint8Array>;
/**
 * Create a public key from a centralized DKG output.
 *
 * @param curve - The curve to use for key generation
 * @param centralizedDkgOutput - The centralized DKG output
 *
 * @returns The BCS-encoded public key
 */
export declare function publicKeyFromCentralizedDKGOutput(curve: Curve, centralizedDkgOutput: Uint8Array): Promise<Uint8Array>;
/**
 * Verify and get the DWallet DKG public output.
 * The `publicKey` is used to verify the user's public output signature.
 *
 * SECURITY WARNING: For withSecrets flows, the public key or public output must be saved by the developer during DKG,
 * NOT fetched from the network, to ensure proper verification.
 *
 * @param dWallet - The DWallet object containing the user's public output
 * @param encryptedUserSecretKeyShare - The encrypted user secret key share
 * @param publicKey - The user share encryption key's public key for verification
 * @returns The DKG public output
 */
export declare function verifyAndGetDWalletDKGPublicOutput(dWallet: DWallet, encryptedUserSecretKeyShare: EncryptedUserSecretKeyShare, publicKey: PublicKey): Promise<Uint8Array>;
/**
 * Verify that the user's public output matches the network's public output.
 *
 * @param curve - The curve to use
 * @param userPublicOutput - The user's public output
 * @param networkDKGOutput - The network's public output
 * @returns True if the user's public output matches the network's public output, false otherwise
 */
export declare function userAndNetworkDKGOutputMatch(curve: Curve, userPublicOutput: Uint8Array, networkDKGOutput: Uint8Array): Promise<boolean>;
/**
 * Parse a signature from a sign output.
 *
 * @param curve - The curve to use
 * @param signatureAlgorithm - The signature algorithm to use
 * @param signatureOutput - The signature output bytes from the network
 * @returns The parsed signature bytes
 */
export declare function parseSignatureFromSignOutput<C extends Curve, S extends ValidSignatureAlgorithmForCurve<C>>(curve: C, signatureAlgorithm: S, signatureOutput: Uint8Array): Promise<Uint8Array>;
/**
 * Create a digest of the session identifier for cryptographic operations.
 * This function creates a versioned, domain-separated hash of the session identifier.
 *
 * @param bytesToHash - The bytes to hash for session identifier generation
 * @param senderAddressBytes - The sender address bytes for session identifier generation
 * @returns The KECCAK-256 digest of the versioned and domain-separated session identifier
 * @private
 */
export declare function sessionIdentifierDigest(bytesToHash: Uint8Array, senderAddressBytes: Uint8Array): Uint8Array;
/**
 * Create a random session identifier.
 *
 * @returns 32 random bytes for use as a session identifier
 */
export declare function createRandomSessionIdentifier(): Uint8Array;
