{
  "version": 3,
  "sources": ["../../../src/client/hash-signature-validation.ts"],
  "sourcesContent": ["// Copyright (c) dWallet Labs, Ltd.\n// SPDX-License-Identifier: BSD-3-Clause-Clear\n\nimport { Curve, Hash, SignatureAlgorithm } from './types.js';\n\n// Valid hash algorithms per signature algorithm (for runtime validation)\nconst VALID_HASH_SIGNATURE_COMBINATIONS: Record<SignatureAlgorithm, readonly Hash[]> = {\n\t[SignatureAlgorithm.ECDSASecp256k1]: [Hash.KECCAK256, Hash.SHA256, Hash.DoubleSHA256],\n\t[SignatureAlgorithm.Taproot]: [Hash.SHA256],\n\t[SignatureAlgorithm.ECDSASecp256r1]: [Hash.SHA256],\n\t[SignatureAlgorithm.EdDSA]: [Hash.SHA512],\n\t[SignatureAlgorithm.SchnorrkelSubstrate]: [Hash.Merlin],\n} as const;\n\n// Maps signature algorithms to their curves (for validation)\nconst SIGNATURE_ALGORITHM_TO_CURVE: Record<SignatureAlgorithm, Curve> = {\n\t[SignatureAlgorithm.ECDSASecp256k1]: Curve.SECP256K1,\n\t[SignatureAlgorithm.Taproot]: Curve.SECP256K1,\n\t[SignatureAlgorithm.ECDSASecp256r1]: Curve.SECP256R1,\n\t[SignatureAlgorithm.EdDSA]: Curve.ED25519,\n\t[SignatureAlgorithm.SchnorrkelSubstrate]: Curve.RISTRETTO,\n} as const;\n\n// Absolute numbering for signature algorithms (global, not relative to curve)\nconst SIGNATURE_ALGORITHM_ABSOLUTE_NUMBERS: Record<SignatureAlgorithm, number> = {\n\t[SignatureAlgorithm.ECDSASecp256k1]: 0,\n\t[SignatureAlgorithm.Taproot]: 1,\n\t[SignatureAlgorithm.ECDSASecp256r1]: 2,\n\t[SignatureAlgorithm.EdDSA]: 3,\n\t[SignatureAlgorithm.SchnorrkelSubstrate]: 4,\n} as const;\n\n// Absolute numbering for hashes (global, not relative to curve/signature)\nconst HASH_ABSOLUTE_NUMBERS: Record<Hash, number> = {\n\t[Hash.KECCAK256]: 0,\n\t[Hash.SHA256]: 1,\n\t[Hash.DoubleSHA256]: 2,\n\t[Hash.SHA512]: 3,\n\t[Hash.Merlin]: 4,\n} as const;\n\n// Mirrors Rust SUPPORTED_CURVES_TO_SIGNATURE_ALGORITHMS_TO_HASH_SCHEMES\n// Single source of truth for curve -> signature algorithm -> hash number mappings\nconst CURVE_SIGNATURE_HASH_CONFIG = {\n\t[Curve.SECP256K1]: {\n\t\tcurveNumber: 0,\n\t\tsignatureAlgorithms: {\n\t\t\t[SignatureAlgorithm.ECDSASecp256k1]: {\n\t\t\t\tsignatureAlgorithmNumber: 0,\n\t\t\t\thashes: {\n\t\t\t\t\t[Hash.KECCAK256]: 0,\n\t\t\t\t\t[Hash.SHA256]: 1,\n\t\t\t\t\t[Hash.DoubleSHA256]: 2,\n\t\t\t\t},\n\t\t\t},\n\t\t\t[SignatureAlgorithm.Taproot]: {\n\t\t\t\tsignatureAlgorithmNumber: 1,\n\t\t\t\thashes: {\n\t\t\t\t\t[Hash.SHA256]: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\t[Curve.SECP256R1]: {\n\t\tcurveNumber: 1,\n\t\tsignatureAlgorithms: {\n\t\t\t[SignatureAlgorithm.ECDSASecp256r1]: {\n\t\t\t\tsignatureAlgorithmNumber: 0,\n\t\t\t\thashes: {\n\t\t\t\t\t[Hash.SHA256]: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\t[Curve.ED25519]: {\n\t\tcurveNumber: 2,\n\t\tsignatureAlgorithms: {\n\t\t\t[SignatureAlgorithm.EdDSA]: {\n\t\t\t\tsignatureAlgorithmNumber: 0,\n\t\t\t\thashes: {\n\t\t\t\t\t[Hash.SHA512]: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\t[Curve.RISTRETTO]: {\n\t\tcurveNumber: 3,\n\t\tsignatureAlgorithms: {\n\t\t\t[SignatureAlgorithm.SchnorrkelSubstrate]: {\n\t\t\t\tsignatureAlgorithmNumber: 0,\n\t\t\t\thashes: {\n\t\t\t\t\t[Hash.Merlin]: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n} as const;\n\ntype SignatureAlgorithmConfig = {\n\tsignatureAlgorithmNumber: number;\n\thashes: Record<string, number>;\n};\n\n/** Returns human-readable name for a hash algorithm */\nexport function getHashName(hash: Hash): string {\n\tswitch (hash) {\n\t\tcase Hash.KECCAK256:\n\t\t\treturn 'KECCAK256 (SHA3)';\n\t\tcase Hash.SHA256:\n\t\t\treturn 'SHA256';\n\t\tcase Hash.DoubleSHA256:\n\t\t\treturn 'DoubleSHA256';\n\t\tcase Hash.SHA512:\n\t\t\treturn 'SHA512';\n\t\tcase Hash.Merlin:\n\t\t\treturn 'Merlin';\n\t\tdefault:\n\t\t\treturn `Unknown Hash (${hash})`;\n\t}\n}\n\n/** Returns human-readable name for a signature algorithm */\nexport function getSignatureAlgorithmName(signatureAlgorithm: SignatureAlgorithm): string {\n\tswitch (signatureAlgorithm) {\n\t\tcase SignatureAlgorithm.ECDSASecp256k1:\n\t\t\treturn 'ECDSASecp256k1';\n\t\tcase SignatureAlgorithm.Taproot:\n\t\t\treturn 'Taproot';\n\t\tcase SignatureAlgorithm.ECDSASecp256r1:\n\t\t\treturn 'ECDSASecp256r1';\n\t\tcase SignatureAlgorithm.EdDSA:\n\t\t\treturn 'EdDSA';\n\t\tcase SignatureAlgorithm.SchnorrkelSubstrate:\n\t\t\treturn 'SchnorrkelSubstrate (Ristretto)';\n\t\tdefault:\n\t\t\treturn `Unknown SignatureAlgorithm (${signatureAlgorithm})`;\n\t}\n}\n\n/** Returns human-readable name for a curve */\nexport function getCurveName(curve: Curve): string {\n\tswitch (curve) {\n\t\tcase Curve.SECP256K1:\n\t\t\treturn 'secp256k1';\n\t\tcase Curve.SECP256R1:\n\t\t\treturn 'secp256r1';\n\t\tcase Curve.ED25519:\n\t\t\treturn 'Ed25519';\n\t\tcase Curve.RISTRETTO:\n\t\t\treturn 'Ristretto';\n\t\tdefault:\n\t\t\treturn `Unknown Curve (${curve})`;\n\t}\n}\n\n/**\n * Validates hash and signature algorithm combination.\n * @throws {Error} with supported hashes if invalid\n */\nexport function validateHashSignatureCombination(\n\thash: Hash,\n\tsignatureAlgorithm: SignatureAlgorithm,\n): void {\n\tconst validHashes = VALID_HASH_SIGNATURE_COMBINATIONS[signatureAlgorithm];\n\n\tif (!validHashes.includes(hash)) {\n\t\tconst supportedHashNames = validHashes.map(getHashName).join(', ');\n\t\tthrow new Error(\n\t\t\t`Invalid hash and signature algorithm combination: ` +\n\t\t\t\t`${getSignatureAlgorithmName(signatureAlgorithm)} does not support ${getHashName(hash)}. ` +\n\t\t\t\t`Supported hash algorithms for ${getSignatureAlgorithmName(signatureAlgorithm)}: ${supportedHashNames}`,\n\t\t);\n\t}\n}\n\n/**\n * Validates curve matches the signature algorithm.\n * @throws {Error} with expected curve if mismatch\n */\nexport function validateCurveSignatureAlgorithm(\n\tcurve: Curve,\n\tsignatureAlgorithm: SignatureAlgorithm,\n): void {\n\tconst expectedCurve = SIGNATURE_ALGORITHM_TO_CURVE[signatureAlgorithm];\n\n\tif (curve !== expectedCurve) {\n\t\tthrow new Error(\n\t\t\t`Invalid curve and signature algorithm combination: ` +\n\t\t\t\t`${getSignatureAlgorithmName(signatureAlgorithm)} requires ${getCurveName(expectedCurve)}, ` +\n\t\t\t\t`but ${getCurveName(curve)} was provided.`,\n\t\t);\n\t}\n}\n\n/** Compile-time type for valid signature algorithms per curve */\nexport type ValidSignatureAlgorithmForCurve<C extends Curve> = C extends typeof Curve.SECP256K1\n\t? typeof SignatureAlgorithm.ECDSASecp256k1 | typeof SignatureAlgorithm.Taproot\n\t: C extends typeof Curve.SECP256R1\n\t\t? typeof SignatureAlgorithm.ECDSASecp256r1\n\t\t: C extends typeof Curve.ED25519\n\t\t\t? typeof SignatureAlgorithm.EdDSA\n\t\t\t: C extends typeof Curve.RISTRETTO\n\t\t\t\t? typeof SignatureAlgorithm.SchnorrkelSubstrate\n\t\t\t\t: never;\n\n/** Compile-time type for valid hash/signature combinations */\nexport type ValidHashForSignature<S extends SignatureAlgorithm> =\n\tS extends typeof SignatureAlgorithm.ECDSASecp256k1\n\t\t? typeof Hash.KECCAK256 | typeof Hash.SHA256 | typeof Hash.DoubleSHA256\n\t\t: S extends typeof SignatureAlgorithm.Taproot\n\t\t\t? typeof Hash.SHA256\n\t\t\t: S extends typeof SignatureAlgorithm.ECDSASecp256r1\n\t\t\t\t? typeof Hash.SHA256\n\t\t\t\t: S extends typeof SignatureAlgorithm.EdDSA\n\t\t\t\t\t? typeof Hash.SHA512\n\t\t\t\t\t: S extends typeof SignatureAlgorithm.SchnorrkelSubstrate\n\t\t\t\t\t\t? typeof Hash.Merlin\n\t\t\t\t\t\t: never;\n\n/** Type guard: checks if hash is valid for signature algorithm */\nexport function isValidHashForSignature<S extends SignatureAlgorithm>(\n\thash: Hash,\n\tsignatureAlgorithm: S,\n): hash is ValidHashForSignature<S> {\n\tconst validHashes = VALID_HASH_SIGNATURE_COMBINATIONS[signatureAlgorithm];\n\treturn validHashes.includes(hash);\n}\n\n/** Compile-time validated signing parameters */\nexport type ValidatedSigningParams<S extends SignatureAlgorithm> = {\n\thashScheme: ValidHashForSignature<S>;\n\tsignatureAlgorithm: S;\n};\n\n/**\n * Creates validated signing params with compile-time checking.\n * @example\n * createValidatedSigningParams(Hash.SHA256, SignatureAlgorithm.ECDSASecp256k1); // OK\n * createValidatedSigningParams(Hash.SHA512, SignatureAlgorithm.ECDSASecp256k1); // Compile error\n */\nexport function createValidatedSigningParams<S extends SignatureAlgorithm>(\n\thashScheme: ValidHashForSignature<S>,\n\tsignatureAlgorithm: S,\n): ValidatedSigningParams<S> {\n\t// Runtime validation as well\n\tvalidateHashSignatureCombination(hashScheme, signatureAlgorithm);\n\treturn { hashScheme, signatureAlgorithm };\n}\n\n/**\n * Returns array of valid hash names for signature algorithm.\n * @example getValidHashesForSignatureAlgorithm(SignatureAlgorithm.ECDSASecp256k1)\n * // => ['KECCAK256 (SHA3)', 'SHA256', 'DoubleSHA256']\n */\nexport function getValidHashesForSignatureAlgorithm(\n\tsignatureAlgorithm: SignatureAlgorithm,\n): string[] {\n\tconst validHashes = VALID_HASH_SIGNATURE_COMBINATIONS[signatureAlgorithm];\n\treturn validHashes.map(getHashName);\n}\n\n/** Converts curve to its numeric representation */\nexport function fromCurveToNumber(curve: Curve): number {\n\tconst config = CURVE_SIGNATURE_HASH_CONFIG[curve];\n\tif (!config) {\n\t\tthrow new Error(`Unknown curve: ${curve}`);\n\t}\n\treturn config.curveNumber;\n}\n\n/**\n * Converts signature algorithm to its numeric representation.\n * Number is relative to the curve (e.g., Secp256k1: ECDSA=0, Taproot=1).\n * @throws {Error} with valid algorithms if invalid combination\n */\nexport function fromSignatureAlgorithmToNumber(\n\tcurve: Curve,\n\tsignatureAlgorithm: SignatureAlgorithm,\n): number {\n\tconst curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];\n\tif (!curveConfig) {\n\t\tthrow new Error(`Unknown curve: ${curve}`);\n\t}\n\n\tconst signatureAlgorithms = curveConfig.signatureAlgorithms as Record<\n\t\tstring,\n\t\tSignatureAlgorithmConfig\n\t>;\n\tconst signatureConfig = signatureAlgorithms[signatureAlgorithm];\n\tif (!signatureConfig) {\n\t\tthrow new Error(\n\t\t\t`Invalid signature algorithm ${signatureAlgorithm} for curve ${curve}. ` +\n\t\t\t\t`Valid algorithms: ${Object.keys(curveConfig.signatureAlgorithms).join(', ')}`,\n\t\t);\n\t}\n\n\treturn signatureConfig.signatureAlgorithmNumber;\n}\n\n/**\n * Converts hash to its numeric representation.\n * Number is relative to curve+signature (e.g., Secp256k1+ECDSA: KECCAK256=0, SHA256=1).\n * @throws {Error} with valid hashes if invalid combination\n */\nexport function fromHashToNumber(\n\tcurve: Curve,\n\tsignatureAlgorithm: SignatureAlgorithm,\n\thash: Hash,\n): number {\n\tconst curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];\n\tif (!curveConfig) {\n\t\tthrow new Error(`Unknown curve: ${curve}`);\n\t}\n\n\tconst signatureAlgorithms = curveConfig.signatureAlgorithms as Record<\n\t\tstring,\n\t\tSignatureAlgorithmConfig\n\t>;\n\tconst signatureConfig = signatureAlgorithms[signatureAlgorithm];\n\tif (!signatureConfig) {\n\t\tthrow new Error(\n\t\t\t`Invalid signature algorithm ${signatureAlgorithm} for curve ${curve}. ` +\n\t\t\t\t`Valid algorithms: ${Object.keys(curveConfig.signatureAlgorithms).join(', ')}`,\n\t\t);\n\t}\n\n\tconst hashes = signatureConfig.hashes as Record<string, number>;\n\tconst hashNumber = hashes[hash];\n\tif (hashNumber === undefined) {\n\t\tthrow new Error(\n\t\t\t`Invalid hash ${hash} for ${signatureAlgorithm} on ${curve}. ` +\n\t\t\t\t`Valid hashes: ${Object.keys(signatureConfig.hashes).join(', ')}`,\n\t\t);\n\t}\n\n\treturn hashNumber;\n}\n\n/** Converts curve and signature algorithm to their numeric representations */\nexport function fromCurveAndSignatureAlgorithmToNumbers(\n\tcurve: Curve,\n\tsignatureAlgorithm: SignatureAlgorithm,\n): {\n\tcurveNumber: number;\n\tsignatureAlgorithmNumber: number;\n} {\n\tconst curveNumber = fromCurveToNumber(curve);\n\tconst signatureAlgorithmNumber = fromSignatureAlgorithmToNumber(curve, signatureAlgorithm);\n\n\treturn {\n\t\tcurveNumber,\n\t\tsignatureAlgorithmNumber,\n\t};\n}\n\n/** Converts curve, signature algorithm, and hash to their numeric representations */\nexport function fromCurveAndSignatureAlgorithmAndHashToNumbers(\n\tcurve: Curve,\n\tsignatureAlgorithm: SignatureAlgorithm,\n\thash: Hash,\n): {\n\tcurveNumber: number;\n\tsignatureAlgorithmNumber: number;\n\thashNumber: number;\n} {\n\tconst curveNumber = fromCurveToNumber(curve);\n\tconst signatureAlgorithmNumber = fromSignatureAlgorithmToNumber(curve, signatureAlgorithm);\n\tconst hashNumber = fromHashToNumber(curve, signatureAlgorithm, hash);\n\n\treturn {\n\t\tcurveNumber,\n\t\tsignatureAlgorithmNumber,\n\t\thashNumber,\n\t};\n}\n\n/** Type guard: is signature algorithm valid for curve? */\nexport function isValidSignatureAlgorithmForCurve(\n\tcurve: Curve,\n\tsignatureAlgorithm: SignatureAlgorithm,\n): boolean {\n\tconst curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];\n\tif (!curveConfig) return false;\n\treturn signatureAlgorithm in curveConfig.signatureAlgorithms;\n}\n\n/** Type guard: is hash valid for curve+signature algorithm? */\nexport function isValidHashForCurveAndSignature(\n\tcurve: Curve,\n\tsignatureAlgorithm: SignatureAlgorithm,\n\thash: Hash,\n): boolean {\n\tconst curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];\n\tif (!curveConfig) return false;\n\n\tconst signatureAlgorithms = curveConfig.signatureAlgorithms as Record<\n\t\tstring,\n\t\tSignatureAlgorithmConfig\n\t>;\n\tconst signatureConfig = signatureAlgorithms[signatureAlgorithm];\n\tif (!signatureConfig) return false;\n\n\tconst hashes = signatureConfig.hashes as Record<string, number>;\n\treturn hash in hashes;\n}\n\n/** Returns all valid signature algorithms for a curve */\nexport function getValidSignatureAlgorithmsForCurve(curve: Curve): SignatureAlgorithm[] {\n\tconst curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];\n\tif (!curveConfig) return [];\n\treturn Object.keys(curveConfig.signatureAlgorithms) as SignatureAlgorithm[];\n}\n\n/** Returns all valid hashes for a curve and signature algorithm */\nexport function getValidHashesForCurveAndSignature(\n\tcurve: Curve,\n\tsignatureAlgorithm: SignatureAlgorithm,\n): Hash[] {\n\tconst curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];\n\tif (!curveConfig) return [];\n\n\tconst signatureAlgorithms = curveConfig.signatureAlgorithms as Record<\n\t\tstring,\n\t\tSignatureAlgorithmConfig\n\t>;\n\tconst signatureConfig = signatureAlgorithms[signatureAlgorithm];\n\tif (!signatureConfig) return [];\n\n\treturn Object.keys(signatureConfig.hashes) as Hash[];\n}\n\n/**\n * Converts curve number to its Curve enum (direct conversion).\n * @throws {Error} if curve number is unknown\n */\nexport function fromNumberToCurve(curveNumber: number): Curve {\n\tfor (const [curve, config] of Object.entries(CURVE_SIGNATURE_HASH_CONFIG)) {\n\t\tif (config.curveNumber === curveNumber) {\n\t\t\treturn curve as Curve;\n\t\t}\n\t}\n\tthrow new Error(`Unknown curve number: ${curveNumber}`);\n}\n\n/**\n * Converts absolute signature algorithm number to its SignatureAlgorithm enum (direct conversion).\n * Uses global numbering: ECDSASecp256k1=0, Taproot=1, ECDSASecp256r1=2, EdDSA=3, SchnorrkelSubstrate=4\n * @throws {Error} if number is unknown\n */\nexport function fromAbsoluteNumberToSignatureAlgorithm(absoluteNumber: number): SignatureAlgorithm {\n\tfor (const [signatureAlgorithm, number] of Object.entries(SIGNATURE_ALGORITHM_ABSOLUTE_NUMBERS)) {\n\t\tif (number === absoluteNumber) {\n\t\t\treturn signatureAlgorithm as SignatureAlgorithm;\n\t\t}\n\t}\n\tthrow new Error(`Unknown absolute signature algorithm number: ${absoluteNumber}`);\n}\n\n/**\n * Converts SignatureAlgorithm enum to its absolute number (direct conversion).\n * Uses global numbering: ECDSASecp256k1=0, Taproot=1, ECDSASecp256r1=2, EdDSA=3, SchnorrkelSubstrate=4\n */\nexport function fromSignatureAlgorithmToAbsoluteNumber(\n\tsignatureAlgorithm: SignatureAlgorithm,\n): number {\n\tconst absoluteNumber = SIGNATURE_ALGORITHM_ABSOLUTE_NUMBERS[signatureAlgorithm];\n\tif (absoluteNumber === undefined) {\n\t\tthrow new Error(`Unknown signature algorithm: ${signatureAlgorithm}`);\n\t}\n\treturn absoluteNumber;\n}\n\n/**\n * Converts absolute hash number to its Hash enum (direct conversion).\n * Uses global numbering: KECCAK256=0, SHA256=1, DoubleSHA256=2, SHA512=3, Merlin=4\n * @throws {Error} if number is unknown\n */\nexport function fromAbsoluteNumberToHash(absoluteNumber: number): Hash {\n\tfor (const [hash, number] of Object.entries(HASH_ABSOLUTE_NUMBERS)) {\n\t\tif (number === absoluteNumber) {\n\t\t\treturn hash as Hash;\n\t\t}\n\t}\n\tthrow new Error(`Unknown absolute hash number: ${absoluteNumber}`);\n}\n\n/**\n * Converts Hash enum to its absolute number (direct conversion).\n * Uses global numbering: KECCAK256=0, SHA256=1, DoubleSHA256=2, SHA512=3, Merlin=4\n */\nexport function fromHashToAbsoluteNumber(hash: Hash): number {\n\tconst absoluteNumber = HASH_ABSOLUTE_NUMBERS[hash];\n\tif (absoluteNumber === undefined) {\n\t\tthrow new Error(`Unknown hash: ${hash}`);\n\t}\n\treturn absoluteNumber;\n}\n\n/**\n * Converts signature algorithm number to its SignatureAlgorithm enum.\n * Number is relative to the curve (e.g., Secp256k1: 0=ECDSA, 1=Taproot).\n * @throws {Error} if signature algorithm number is unknown for the curve\n */\nexport function fromNumberToSignatureAlgorithm(\n\tcurve: Curve,\n\tsignatureAlgorithmNumber: number,\n): SignatureAlgorithm {\n\tconst curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];\n\tif (!curveConfig) {\n\t\tthrow new Error(`Unknown curve: ${curve}`);\n\t}\n\n\tconst signatureAlgorithms = curveConfig.signatureAlgorithms as Record<\n\t\tstring,\n\t\tSignatureAlgorithmConfig\n\t>;\n\n\tfor (const [signatureAlgorithm, config] of Object.entries(signatureAlgorithms)) {\n\t\tif (config.signatureAlgorithmNumber === signatureAlgorithmNumber) {\n\t\t\treturn signatureAlgorithm as SignatureAlgorithm;\n\t\t}\n\t}\n\n\tthrow new Error(\n\t\t`Unknown signature algorithm number ${signatureAlgorithmNumber} for curve ${curve}`,\n\t);\n}\n\n/**\n * Converts hash number to its Hash enum.\n * Number is relative to curve+signature (e.g., Secp256k1+ECDSA: 0=KECCAK256, 1=SHA256).\n * @throws {Error} if hash number is unknown for the curve+signature algorithm combination\n */\nexport function fromNumberToHash(\n\tcurve: Curve,\n\tsignatureAlgorithm: SignatureAlgorithm,\n\thashNumber: number,\n): Hash {\n\tconst curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];\n\tif (!curveConfig) {\n\t\tthrow new Error(`Unknown curve: ${curve}`);\n\t}\n\n\tconst signatureAlgorithms = curveConfig.signatureAlgorithms as Record<\n\t\tstring,\n\t\tSignatureAlgorithmConfig\n\t>;\n\tconst signatureConfig = signatureAlgorithms[signatureAlgorithm];\n\tif (!signatureConfig) {\n\t\tthrow new Error(`Invalid signature algorithm ${signatureAlgorithm} for curve ${curve}`);\n\t}\n\n\tconst hashes = signatureConfig.hashes as Record<string, number>;\n\tfor (const [hash, number] of Object.entries(hashes)) {\n\t\tif (number === hashNumber) {\n\t\t\treturn hash as Hash;\n\t\t}\n\t}\n\n\tthrow new Error(`Unknown hash number ${hashNumber} for ${signatureAlgorithm} on ${curve}`);\n}\n\n/**\n * Converts curve and signature algorithm numbers to their enum representations.\n * @throws {Error} if numbers are unknown\n */\nexport function fromNumbersToCurveAndSignatureAlgorithm(\n\tcurveNumber: number,\n\tsignatureAlgorithmNumber: number,\n): {\n\tcurve: Curve;\n\tsignatureAlgorithm: SignatureAlgorithm;\n} {\n\tconst curve = fromNumberToCurve(curveNumber);\n\tconst signatureAlgorithm = fromNumberToSignatureAlgorithm(curve, signatureAlgorithmNumber);\n\n\treturn {\n\t\tcurve,\n\t\tsignatureAlgorithm,\n\t};\n}\n\n/**\n * Converts curve, signature algorithm, and hash numbers to their enum representations.\n * @throws {Error} if numbers are unknown\n */\nexport function fromNumbersToCurveAndSignatureAlgorithmAndHash(\n\tcurveNumber: number,\n\tsignatureAlgorithmNumber: number,\n\thashNumber: number,\n): {\n\tcurve: Curve;\n\tsignatureAlgorithm: SignatureAlgorithm;\n\thash: Hash;\n} {\n\tconst curve = fromNumberToCurve(curveNumber);\n\tconst signatureAlgorithm = fromNumberToSignatureAlgorithm(curve, signatureAlgorithmNumber);\n\tconst hash = fromNumberToHash(curve, signatureAlgorithm, hashNumber);\n\n\treturn {\n\t\tcurve,\n\t\tsignatureAlgorithm,\n\t\thash,\n\t};\n}\n"],
  "mappings": "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",
  "names": []
}
