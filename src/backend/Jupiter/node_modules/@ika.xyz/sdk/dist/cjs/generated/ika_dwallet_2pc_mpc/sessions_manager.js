"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var sessions_manager_exports = {};
__export(sessions_manager_exports, {
  DWalletSession: () => DWalletSession,
  DWalletSessionEvent: () => DWalletSessionEvent,
  DWalletSessionResultEvent: () => DWalletSessionResultEvent,
  DWalletSessionStatusEvent: () => DWalletSessionStatusEvent,
  SessionIdentifier: () => SessionIdentifier,
  SessionType: () => SessionType,
  SessionsKeeper: () => SessionsKeeper,
  SessionsManager: () => SessionsManager,
  UserSessionIdentifierRegisteredEvent: () => UserSessionIdentifierRegisteredEvent
});
module.exports = __toCommonJS(sessions_manager_exports);
var import_utils = require("../utils/index.js");
var import_bcs = require("@mysten/sui/bcs");
var object_table = __toESM(require("./deps/sui/object_table.js"));
var bag = __toESM(require("./deps/sui/bag.js"));
var table = __toESM(require("./deps/sui/table.js"));
var object = __toESM(require("./deps/sui/object.js"));
var balance = __toESM(require("./deps/sui/balance.js"));
const $moduleName = "@local-pkg/2pc-mpc::sessions_manager";
const SessionsKeeper = new import_utils.MoveStruct({ name: `${$moduleName}::SessionsKeeper`, fields: {
  /** Active sessions indexed by sequence number */
  sessions: object_table.ObjectTable,
  /** Events for sessions, keyed by session ID */
  session_events: bag.Bag,
  /** Count of started sessions */
  started_sessions_count: import_bcs.bcs.u64(),
  /** Count of completed sessions */
  completed_sessions_count: import_bcs.bcs.u64(),
  /**
   * The sequence number to assign to the next session. Initialized to `1` and
   * incremented at every new session creation.
   */
  next_session_sequence_number: import_bcs.bcs.u64()
} });
const SessionsManager = new import_utils.MoveStruct({ name: `${$moduleName}::SessionsManager`, fields: {
  /**
     * Registered user session identifiers, keyed by the session identifier bytes -> to
     * session object ID
     */
  registered_user_session_identifiers: table.Table,
  /** Holds the data for user-initiated sessions */
  user_sessions_keeper: SessionsKeeper,
  /** Holds the data for system-initiated sessions */
  system_sessions_keeper: SessionsKeeper,
  /**
   * The last MPC session to process in the current epoch. The validators of the Ika
   * network must always begin sessions, when they become available to them, so long
   * their sequence number is lesser or equal to this value. Initialized to `0`, as
   * when the system is initialized no user-requested session exists so none should
   * be started and we shouldn't wait for any to complete before advancing epoch
   * (until the first session is created), and updated at every new session creation
   * or completion, and when advancing epochs, to the latest session whilst assuring
   * a maximum of `max_active_sessions_buffer` sessions to be completed in the
   * current epoch. Validators should complete every session they start before
   * switching epochs.
   */
  last_user_initiated_session_to_complete_in_current_epoch: import_bcs.bcs.u64(),
  /**
   * Denotes whether the `last_user_initiated_session_to_complete_in_current_epoch`
   * field is locked or not. This field gets locked before performing the epoch
   * switch.
   */
  locked_last_user_initiated_session_to_complete_in_current_epoch: import_bcs.bcs.bool(),
  /**
   * The maximum number of active MPC sessions Ika nodes may run during an epoch.
   * Validators should complete every session they start before switching epochs.
   */
  max_active_sessions_buffer: import_bcs.bcs.u64()
} });
const SessionIdentifier = new import_utils.MoveStruct({ name: `${$moduleName}::SessionIdentifier`, fields: {
  id: object.UID,
  identifier_preimage: import_bcs.bcs.vector(import_bcs.bcs.u8())
} });
const DWalletSession = new import_utils.MoveStruct({ name: `${$moduleName}::DWalletSession`, fields: {
  id: object.UID,
  /** Session identifier */
  session_identifier: SessionIdentifier,
  /** Sequential number for session ordering */
  session_sequence_number: import_bcs.bcs.u64(),
  /** Associated network encryption key */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address,
  /** IKA fees for the session */
  fee_charged_ika: balance.Balance,
  /** SUI balance for gas reimbursement */
  gas_fee_reimbursement_sui: balance.Balance
} });
const UserSessionIdentifierRegisteredEvent = new import_utils.MoveStruct({ name: `${$moduleName}::UserSessionIdentifierRegisteredEvent`, fields: {
  /** ID of the session object */
  session_object_id: import_bcs.bcs.Address,
  /** Unique session identifier */
  session_identifier_preimage: import_bcs.bcs.vector(import_bcs.bcs.u8())
} });
const SessionType = new import_utils.MoveEnum({ name: `${$moduleName}::SessionType`, fields: {
  /** User-initiated session (across epochs scheduling) */
  User: null,
  /** System-initiated session (always completes in current epoch) */
  System: null
} });
function DWalletSessionEvent(...typeParameters) {
  return new import_utils.MoveStruct({ name: `${$moduleName}::DWalletSessionEvent<${typeParameters[0].name}>`, fields: {
    /** Epoch when the event occurred */
    epoch: import_bcs.bcs.u64(),
    /** ID of the session object */
    session_object_id: import_bcs.bcs.Address,
    /** Type of session (User or System) */
    session_type: SessionType,
    /** Sequential number for session ordering */
    session_sequence_number: import_bcs.bcs.u64(),
    /** Unique session identifier */
    session_identifier_preimage: import_bcs.bcs.vector(import_bcs.bcs.u8()),
    /** Event-specific data */
    event_data: typeParameters[0]
  } });
}
function DWalletSessionStatusEvent(...typeParameters) {
  return new import_utils.MoveEnum({ name: `${$moduleName}::DWalletSessionStatusEvent<${typeParameters[0].name}, ${typeParameters[1].name}>`, fields: {
    /** The event was successful */
    Success: typeParameters[0],
    /** The event was rejected */
    Rejected: typeParameters[1]
  } });
}
function DWalletSessionResultEvent(...typeParameters) {
  return new import_utils.MoveStruct({ name: `${$moduleName}::DWalletSessionResultEvent<${typeParameters[0].name}, ${typeParameters[1].name}, ${typeParameters[2].name}>`, fields: {
    /** Epoch when the event occurred */
    epoch: import_bcs.bcs.u64(),
    /** Epoch when the event was initiated */
    event_initiated_at_epoch: import_bcs.bcs.u64(),
    /** ID of the session object */
    session_object_id: import_bcs.bcs.Address,
    /** Type of session (User or System) */
    session_type: SessionType,
    /** Sequential number for session ordering */
    session_sequence_number: import_bcs.bcs.u64(),
    /** The identifier of the session */
    session_identifier_preimage: import_bcs.bcs.vector(import_bcs.bcs.u8()),
    /** Event-specific data of the session initiator */
    session_initiator_event_data: typeParameters[0],
    /** The status of the event */
    status: DWalletSessionStatusEvent(typeParameters[1], typeParameters[2])
  } });
}
//# sourceMappingURL=sessions_manager.js.map
