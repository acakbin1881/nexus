{
  "version": 3,
  "sources": ["../../../src/client/cryptography.ts"],
  "sourcesContent": ["// Copyright (c) dWallet Labs, Ltd.\n// SPDX-License-Identifier: BSD-3-Clause-Clear\n\nimport { bcs } from '@mysten/sui/bcs';\nimport type { PublicKey } from '@mysten/sui/cryptography';\nimport { SIGNATURE_FLAG_TO_SCHEME } from '@mysten/sui/cryptography';\nimport { keccak_256 } from '@noble/hashes/sha3';\nimport { randomBytes } from '@noble/hashes/utils.js';\n\nimport {\n\tfromCurveAndSignatureAlgorithmAndHashToNumbers,\n\tfromCurveToNumber,\n\tfromSignatureAlgorithmToNumber,\n} from './hash-signature-validation.js';\nimport type {\n\tValidHashForSignature,\n\tValidSignatureAlgorithmForCurve,\n} from './hash-signature-validation.js';\nimport type { IkaClient } from './ika-client.js';\nimport type { DWallet, EncryptedUserSecretKeyShare } from './types.js';\nimport { Curve } from './types.js';\nimport type { UserShareEncryptionKeys } from './user-share-encryption-keys.js';\nimport { encodeToASCII, u64ToBytesBigEndian } from './utils.js';\nimport {\n\tcentralized_and_decentralized_parties_dkg_output_match,\n\tcreate_dkg_centralized_output_v2,\n\tcreate_dkg_centralized_output_v1 as create_dkg_user_output,\n\tcreate_imported_dwallet_centralized_step as create_imported_dwallet_user_output,\n\tcreate_sign_centralized_party_message_with_centralized_party_dkg_output,\n\tcreate_sign_centralized_party_message as create_sign_user_message,\n\tencrypt_secret_share,\n\tgenerate_secp_cg_keypair_from_seed,\n\tnetwork_dkg_public_output_to_protocol_pp,\n\tparse_signature_from_sign_output,\n\tpublic_key_from_centralized_dkg_output,\n\tpublic_key_from_dwallet_output,\n\treconfiguration_public_output_to_protocol_pp,\n\tverify_secp_signature,\n\tverify_user_share,\n} from './wasm-loader.js';\n\n/**\n * Prepared data for the second round of Distributed Key Generation (DKG).\n * Contains all cryptographic outputs needed to complete the DKG process.\n *\n * SECURITY WARNING: *secret key share must be kept private!* never send it to anyone, or store it anywhere unencrypted.\n */\nexport interface DKGRequestInput {\n\t/** The user's public key share along with its zero-knowledge proof */\n\tuserDKGMessage: Uint8Array;\n\t/** The user's public output from the DKG process */\n\tuserPublicOutput: Uint8Array;\n\t/** The encrypted user share with its proof of correct encryption */\n\tencryptedUserShareAndProof: Uint8Array;\n\t/** The raw secret key share (user share) */\n\tuserSecretKeyShare: Uint8Array;\n}\n\n/**\n * Prepared data for importing an existing cryptographic key as a DWallet.\n * Contains verification data needed to prove ownership of the imported key.\n */\nexport interface ImportDWalletVerificationRequestInput {\n\t/** The public output that can be verified against the imported key */\n\tuserPublicOutput: Uint8Array;\n\t/** The outgoing message for the verification protocol */\n\tuserMessage: Uint8Array;\n\t/** The encrypted user share with proof for the imported key */\n\tencryptedUserShareAndProof: Uint8Array;\n}\n\n/**\n * Create a class groups keypair from a seed for encryption/decryption operations.\n * Uses SECP256k1, SECP256r1, Ristretto, or ED25519 curves with class groups for homomorphic encryption capabilities.\n *\n * @param seed - The seed bytes to generate the keypair from\n * @param curve - The curve to use for key generation\n * @returns Object containing the encryption key (public) and decryption key (private)\n */\nexport async function createClassGroupsKeypair(\n\tseed: Uint8Array,\n\tcurve: Curve,\n): Promise<{\n\tencryptionKey: Uint8Array;\n\tdecryptionKey: Uint8Array;\n}> {\n\tif (seed.length !== 32) {\n\t\tthrow new Error('Seed must be 32 bytes');\n\t}\n\n\tlet encryptionKey: Uint8Array;\n\tlet decryptionKey: Uint8Array;\n\n\tif (\n\t\tcurve === Curve.SECP256K1 ||\n\t\tcurve === Curve.SECP256R1 ||\n\t\tcurve === Curve.RISTRETTO ||\n\t\tcurve === Curve.ED25519\n\t) {\n\t\t[encryptionKey, decryptionKey] = await generate_secp_cg_keypair_from_seed(\n\t\t\tfromCurveToNumber(curve),\n\t\t\tseed,\n\t\t);\n\t} else {\n\t\tthrow new Error(\n\t\t\t'Only SECP256K1, SECP256R1, RISTRETTO, and ED25519 curves are supported for now',\n\t\t);\n\t}\n\n\treturn {\n\t\tencryptionKey: Uint8Array.from(encryptionKey),\n\t\tdecryptionKey: Uint8Array.from(decryptionKey),\n\t};\n}\n\n/**\n * Create the user's output and message for the Distributed Key Generation (DKG) protocol.\n * This function takes the first round output and produces the user's contribution.\n *\n * SECURITY WARNING: *secret key share must be kept private!* never send it to anyone, or store it anywhere unencrypted.\n *\n * @param protocolPublicParameters - The protocol public parameters for decryption\n * @param networkFirstRoundOutput - The output from the network's first round of DKG\n * @param sessionIdentifier - Unique identifier for this DKG session\n * @returns Object containing the user's DKG message, public output, and secret key share\n *\n */\nexport async function createDKGUserOutput(\n\tprotocolPublicParameters: Uint8Array,\n\tnetworkFirstRoundOutput: Uint8Array,\n): Promise<{\n\tuserDKGMessage: Uint8Array;\n\tuserPublicOutput: Uint8Array;\n\tuserSecretKeyShare: Uint8Array;\n}> {\n\tconst [userDKGMessage, userPublicOutput, userSecretKeyShare] = await create_dkg_user_output(\n\t\tprotocolPublicParameters,\n\t\tUint8Array.from(networkFirstRoundOutput),\n\t);\n\n\treturn {\n\t\tuserDKGMessage: Uint8Array.from(userDKGMessage),\n\t\tuserPublicOutput: Uint8Array.from(userPublicOutput),\n\t\tuserSecretKeyShare: Uint8Array.from(userSecretKeyShare),\n\t};\n}\n\n/**\n * Encrypt a secret share using the provided encryption key.\n * This creates an encrypted share that can only be decrypted by the corresponding decryption key.\n *\n * @param curve - The curve to use for encryption\n * @param userSecretKeyShare - The secret key share to encrypt\n * @param encryptionKey - The public encryption key to encrypt with\n * @param protocolPublicParameters - The protocol public parameters for encryption\n * @returns The encrypted secret share with proof of correct encryption\n */\nexport async function encryptSecretShare(\n\tcurve: Curve,\n\tuserSecretKeyShare: Uint8Array,\n\tencryptionKey: Uint8Array,\n\tprotocolPublicParameters: Uint8Array,\n): Promise<Uint8Array> {\n\tconst encryptedUserShareAndProof = await encrypt_secret_share(\n\t\tfromCurveToNumber(curve),\n\t\tuserSecretKeyShare,\n\t\tencryptionKey,\n\t\tprotocolPublicParameters,\n\t);\n\n\treturn Uint8Array.from(encryptedUserShareAndProof);\n}\n\n/**\n * @deprecated Use prepareDKG instead\n *\n * @param _protocolPublicParameters - The protocol public parameters\n * @param _dWallet - The DWallet object containing first round output\n * @param _encryptionKey - The user's public encryption key\n * @returns Complete prepared data for the second DKG round\n * @throws {Error} If the first round output is not available in the DWallet\n *\n * SECURITY WARNING: *secret key share must be kept private!* never send it to anyone, or store it anywhere unencrypted.\n */\nexport async function prepareDKGSecondRound(\n\t_protocolPublicParameters: Uint8Array,\n\t_dWallet: DWallet,\n\t_encryptionKey: Uint8Array,\n): Promise<DKGRequestInput> {\n\tthrow new Error('prepareDKGSecondRound is deprecated. Use prepareDKG instead');\n}\n\n/**\n * Prepare all cryptographic data needed for DKG.\n *\n * @param protocolPublicParameters - The protocol public parameters\n * @param curve - The curve to use for key generation\n * @param encryptionKey - The user's public encryption key\n * @param bytesToHash - The bytes to hash for session identifier generation\n * @param senderAddress - The sender address for session identifier generation\n * @returns Complete prepared data for DKG including user message, public output, encrypted share, and secret key share\n *\n * SECURITY WARNING: *secret key share must be kept private!* never send it to anyone, or store it anywhere unencrypted.\n */\nexport async function prepareDKG(\n\tprotocolPublicParameters: Uint8Array,\n\tcurve: Curve,\n\tencryptionKey: Uint8Array,\n\tbytesToHash: Uint8Array,\n\tsenderAddress: string,\n): Promise<DKGRequestInput> {\n\tconst senderAddressBytes = bcs.Address.serialize(senderAddress).toBytes();\n\n\tconst [userDKGMessage, userPublicOutput, userSecretKeyShare] =\n\t\tawait create_dkg_centralized_output_v2(\n\t\t\tfromCurveToNumber(curve),\n\t\t\tprotocolPublicParameters,\n\t\t\tsessionIdentifierDigest(bytesToHash, senderAddressBytes),\n\t\t);\n\n\tconst encryptedUserShareAndProof = await encryptSecretShare(\n\t\tcurve,\n\t\tuserSecretKeyShare,\n\t\tencryptionKey,\n\t\tprotocolPublicParameters,\n\t);\n\n\treturn {\n\t\tuserDKGMessage: Uint8Array.from(userDKGMessage),\n\t\tuserPublicOutput: Uint8Array.from(userPublicOutput),\n\t\tencryptedUserShareAndProof: Uint8Array.from(encryptedUserShareAndProof),\n\t\tuserSecretKeyShare: Uint8Array.from(userSecretKeyShare),\n\t};\n}\n\n/**\n * @deprecated Use prepareDKGAsync instead\n *\n * @param ikaClient - The IkaClient instance to fetch network parameters from\n * @param dWallet - The DWallet object containing first round output\n * @param userShareEncryptionKeys - The user's encryption keys for securing the user's share\n * @returns Promise resolving to complete prepared data for the second DKG round\n * @throws {Error} If the first round output is not available or network parameters cannot be fetched\n *\n * SECURITY WARNING: *secret key share must be kept private!* never send it to anyone, or store it anywhere unencrypted.\n */\nexport async function prepareDKGSecondRoundAsync(\n\t_ikaClient: IkaClient,\n\t_dWallet: DWallet,\n\t_userShareEncryptionKeys: UserShareEncryptionKeys,\n): Promise<DKGRequestInput> {\n\tthrow new Error('prepareDKGSecondRoundAsync is deprecated. Use prepareDKGAsync instead');\n}\n\n/**\n * Prepare all cryptographic data needed for DKG (async version that fetches protocol parameters).\n *\n * @param ikaClient - The IkaClient instance to fetch network parameters from\n * @param curve - The curve to use for key generation\n * @param userShareEncryptionKeys - The user's encryption keys for securing the user's share\n * @param bytesToHash - The bytes to hash for session identifier generation\n * @param senderAddress - The sender address for session identifier generation\n * @returns Promise resolving to complete prepared data for DKG including user message, public output, encrypted share, and secret key share\n * @throws {Error} If network parameters cannot be fetched\n *\n * SECURITY WARNING: *secret key share must be kept private!* never send it to anyone, or store it anywhere unencrypted.\n */\nexport async function prepareDKGAsync(\n\tikaClient: IkaClient,\n\tcurve: Curve,\n\tuserShareEncryptionKeys: UserShareEncryptionKeys,\n\tbytesToHash: Uint8Array,\n\tsenderAddress: string,\n): Promise<DKGRequestInput> {\n\tconst protocolPublicParameters = await ikaClient.getProtocolPublicParameters(undefined, curve);\n\n\treturn prepareDKG(\n\t\tprotocolPublicParameters,\n\t\tcurve,\n\t\tuserShareEncryptionKeys.encryptionKey,\n\t\tbytesToHash,\n\t\tsenderAddress,\n\t);\n}\n\n/**\n * Prepare verification data for importing an existing cryptographic key as a DWallet.\n * This function creates all necessary proofs and encrypted data for the import process.\n *\n * @param ikaClient - The IkaClient instance to fetch network parameters from\n * @param curve - The curve to use for key generation\n * @param bytesToHash - The bytes to hash for session identifier generation\n * @param senderAddress - The sender address for session identifier generation\n * @param userShareEncryptionKeys - The user's encryption keys for securing the imported share\n * @param privateKey - The existing private key to import as a DWallet\n * @returns Promise resolving to complete verification data for the import process including user public output, message, and encrypted share\n * @throws {Error} If network parameters cannot be fetched or key import preparation fails\n */\nexport async function prepareImportedKeyDWalletVerification(\n\tikaClient: IkaClient,\n\tcurve: Curve,\n\tbytesToHash: Uint8Array,\n\tsenderAddress: string,\n\tuserShareEncryptionKeys: UserShareEncryptionKeys,\n\tprivateKey: Uint8Array,\n): Promise<ImportDWalletVerificationRequestInput> {\n\tconst senderAddressBytes = bcs.Address.serialize(senderAddress).toBytes();\n\tconst protocolPublicParameters = await ikaClient.getProtocolPublicParameters(undefined, curve);\n\n\tconst [userSecretShare, userPublicOutput, userMessage] =\n\t\tawait create_imported_dwallet_user_output(\n\t\t\tfromCurveToNumber(curve),\n\t\t\tprotocolPublicParameters,\n\t\t\tsessionIdentifierDigest(bytesToHash, senderAddressBytes),\n\t\t\tprivateKey,\n\t\t);\n\n\tconst encryptedUserShareAndProof = await encryptSecretShare(\n\t\tcurve,\n\t\tuserSecretShare,\n\t\tuserShareEncryptionKeys.encryptionKey,\n\t\tprotocolPublicParameters,\n\t);\n\n\treturn {\n\t\tuserPublicOutput: Uint8Array.from(userPublicOutput),\n\t\tuserMessage: Uint8Array.from(userMessage),\n\t\tencryptedUserShareAndProof: Uint8Array.from(encryptedUserShareAndProof),\n\t};\n}\n\n/**\n * Create the user's sign message for the signature generation process.\n * This function combines the user's secret key, presign, and message to create a sign message to be sent to the network.\n *\n * This function is used when developer has access to the user's public output which should be verified before using this method.\n *\n * @param protocolPublicParameters - The protocol public parameters\n * @param publicOutput - The user's public output\n * @param userSecretKeyShare - The user's secret key share\n * @param presign - The presignature data from a completed presign operation\n * @param message - The message bytes to sign\n * @param hash - The hash scheme to use for signing\n * @param signatureAlgorithm - The signature algorithm to use\n * @param curve - The curve to use\n * @returns The user's sign message that will be sent to the network for signature generation\n */\nexport async function createUserSignMessageWithPublicOutput<\n\tC extends Curve,\n\tS extends ValidSignatureAlgorithmForCurve<C>,\n\tH extends ValidHashForSignature<S>,\n>(\n\tprotocolPublicParameters: Uint8Array,\n\tpublicOutput: Uint8Array,\n\tuserSecretKeyShare: Uint8Array,\n\tpresign: Uint8Array,\n\tmessage: Uint8Array,\n\thash: H,\n\tsignatureAlgorithm: S,\n\tcurve: C,\n): Promise<Uint8Array> {\n\tconst { signatureAlgorithmNumber, hashNumber, curveNumber } =\n\t\tfromCurveAndSignatureAlgorithmAndHashToNumbers(curve, signatureAlgorithm, hash);\n\n\treturn Uint8Array.from(\n\t\tawait create_sign_user_message(\n\t\t\tprotocolPublicParameters,\n\t\t\tpublicOutput,\n\t\t\tuserSecretKeyShare,\n\t\t\tpresign,\n\t\t\tmessage,\n\t\t\thashNumber,\n\t\t\tsignatureAlgorithmNumber,\n\t\t\tcurveNumber,\n\t\t),\n\t);\n}\n\n/**\n * Create the user's sign message for the signature generation process.\n * This function combines the user's secret key, presign, and message to create a sign message to be sent to the network.\n *\n * This function is used when developer has access to the centralized DKG output which should be verified before using this method.\n *\n * @param protocolPublicParameters - The protocol public parameters\n * @param centralizedDkgOutput - The centralized DKG output\n * @param userSecretKeyShare - The user's secret key share\n * @param presign - The presignature data from a completed presign operation\n * @param message - The message bytes to sign\n * @param hash - The hash scheme to use for signing\n * @param signatureAlgorithm - The signature algorithm to use\n * @param curve - The curve to use\n * @returns The user's sign message that will be sent to the network for signature generation\n */\nexport async function createUserSignMessageWithCentralizedOutput<\n\tC extends Curve,\n\tS extends ValidSignatureAlgorithmForCurve<C>,\n\tH extends ValidHashForSignature<S>,\n>(\n\tprotocolPublicParameters: Uint8Array,\n\tcentralizedDkgOutput: Uint8Array,\n\tuserSecretKeyShare: Uint8Array,\n\tpresign: Uint8Array,\n\tmessage: Uint8Array,\n\thash: H,\n\tsignatureAlgorithm: S,\n\tcurve: C,\n): Promise<Uint8Array> {\n\tconst { signatureAlgorithmNumber, hashNumber, curveNumber } =\n\t\tfromCurveAndSignatureAlgorithmAndHashToNumbers(curve, signatureAlgorithm, hash);\n\n\treturn Uint8Array.from(\n\t\tawait create_sign_centralized_party_message_with_centralized_party_dkg_output(\n\t\t\tprotocolPublicParameters,\n\t\t\tcentralizedDkgOutput,\n\t\t\tuserSecretKeyShare,\n\t\t\tpresign,\n\t\t\tmessage,\n\t\t\thashNumber,\n\t\t\tsignatureAlgorithmNumber,\n\t\t\tcurveNumber,\n\t\t),\n\t);\n}\n\n/**\n * Convert a network DKG public output to the protocol public parameters.\n *\n * @param curve - The curve to use for key generation\n * @param network_dkg_public_output - The network DKG public output\n * @returns The protocol public parameters\n */\nexport async function networkDkgPublicOutputToProtocolPublicParameters(\n\tcurve: Curve,\n\tnetwork_dkg_public_output: Uint8Array,\n): Promise<Uint8Array> {\n\treturn Uint8Array.from(\n\t\tawait network_dkg_public_output_to_protocol_pp(\n\t\t\tfromCurveToNumber(curve),\n\t\t\tnetwork_dkg_public_output,\n\t\t),\n\t);\n}\n\n/**\n * Convert a reconfiguration DKG public output to the protocol public parameters.\n *\n * @param curve - The curve to use for key generation\n * @param reconfiguration_public_output - The reconfiguration DKG public output\n * @param network_dkg_public_output - The network DKG public output\n * @returns The protocol public parameters\n */\nexport async function reconfigurationPublicOutputToProtocolPublicParameters(\n\tcurve: Curve,\n\treconfiguration_public_output: Uint8Array,\n\tnetwork_dkg_public_output: Uint8Array,\n): Promise<Uint8Array> {\n\treturn Uint8Array.from(\n\t\tawait reconfiguration_public_output_to_protocol_pp(\n\t\t\tfromCurveToNumber(curve),\n\t\t\treconfiguration_public_output,\n\t\t\tnetwork_dkg_public_output,\n\t\t),\n\t);\n}\n\n/**\n * Verify a user's secret key share.\n *\n * @param curve - The curve to use for key generation\n * @param userSecretKeyShare - The user's unencrypted secret key share\n * @param userDKGOutput - The user's DKG output\n * @param networkDkgPublicOutput - The network DKG public output\n * @returns True if the user's secret key share is valid, false otherwise\n */\nexport async function verifyUserShare(\n\tcurve: Curve,\n\tuserSecretKeyShare: Uint8Array,\n\tuserDKGOutput: Uint8Array,\n\tnetworkDkgPublicOutput: Uint8Array,\n): Promise<boolean> {\n\treturn await verify_user_share(\n\t\tfromCurveToNumber(curve),\n\t\tuserSecretKeyShare,\n\t\tuserDKGOutput,\n\t\tnetworkDkgPublicOutput,\n\t);\n}\n\n/**\n * Verify a signature.\n *\n * @param publicKey - The public key bytes\n * @param signature - The signature bytes to verify\n * @param message - The message bytes that was signed\n * @param networkDkgPublicOutput - The network DKG public output\n * @param hash - The hash scheme to use for verification\n * @param signatureAlgorithm - The signature algorithm to use\n * @param curve - The curve to use\n * @returns True if the signature is valid, false otherwise\n */\nexport async function verifySecpSignature<\n\tC extends Curve,\n\tS extends ValidSignatureAlgorithmForCurve<C>,\n\tH extends ValidHashForSignature<S>,\n>(\n\tpublicKey: Uint8Array,\n\tsignature: Uint8Array,\n\tmessage: Uint8Array,\n\tnetworkDkgPublicOutput: Uint8Array,\n\thash: H,\n\tsignatureAlgorithm: S,\n\tcurve: C,\n): Promise<boolean> {\n\tconst { signatureAlgorithmNumber, hashNumber, curveNumber } =\n\t\tfromCurveAndSignatureAlgorithmAndHashToNumbers(curve, signatureAlgorithm, hash);\n\n\treturn await verify_secp_signature(\n\t\tpublicKey,\n\t\tsignature,\n\t\tmessage,\n\t\tnetworkDkgPublicOutput,\n\t\thashNumber,\n\t\tsignatureAlgorithmNumber,\n\t\tcurveNumber,\n\t);\n}\n\n/**\n * Create a public key from a DWallet output.\n *\n * @param curve - The curve to use for key generation\n * @param dWalletOutput - The DWallet output\n *\n * @returns The BCS-encoded public key\n */\nexport async function publicKeyFromDWalletOutput(\n\tcurve: Curve,\n\tdWalletOutput: Uint8Array,\n): Promise<Uint8Array> {\n\treturn Uint8Array.from(\n\t\tawait public_key_from_dwallet_output(fromCurveToNumber(curve), dWalletOutput),\n\t);\n}\n\n/**\n * Create a public key from a centralized DKG output.\n *\n * @param curve - The curve to use for key generation\n * @param centralizedDkgOutput - The centralized DKG output\n *\n * @returns The BCS-encoded public key\n */\nexport async function publicKeyFromCentralizedDKGOutput(\n\tcurve: Curve,\n\tcentralizedDkgOutput: Uint8Array,\n): Promise<Uint8Array> {\n\treturn Uint8Array.from(\n\t\tawait public_key_from_centralized_dkg_output(fromCurveToNumber(curve), centralizedDkgOutput),\n\t);\n}\n\n/**\n * Verify and get the DWallet DKG public output.\n * The `publicKey` is used to verify the user's public output signature.\n *\n * SECURITY WARNING: For withSecrets flows, the public key or public output must be saved by the developer during DKG,\n * NOT fetched from the network, to ensure proper verification.\n *\n * @param dWallet - The DWallet object containing the user's public output\n * @param encryptedUserSecretKeyShare - The encrypted user secret key share\n * @param publicKey - The user share encryption key's public key for verification\n * @returns The DKG public output\n */\nexport async function verifyAndGetDWalletDKGPublicOutput(\n\tdWallet: DWallet,\n\tencryptedUserSecretKeyShare: EncryptedUserSecretKeyShare,\n\tpublicKey: PublicKey,\n): Promise<Uint8Array> {\n\tif (\n\t\tSIGNATURE_FLAG_TO_SCHEME[publicKey.flag() as keyof typeof SIGNATURE_FLAG_TO_SCHEME] !==\n\t\t'ED25519'\n\t) {\n\t\tthrow new Error('Only ED25519 public keys are supported.');\n\t}\n\n\tif (!dWallet.state.Active?.public_output) {\n\t\tthrow new Error('DWallet is not in active state');\n\t}\n\n\tif (!encryptedUserSecretKeyShare.state.KeyHolderSigned?.user_output_signature) {\n\t\tthrow new Error('User output signature is undefined');\n\t}\n\n\tconst userPublicOutput = Uint8Array.from(dWallet.state.Active.public_output);\n\n\tconst userOutputSignature = Uint8Array.from(\n\t\tencryptedUserSecretKeyShare.state.KeyHolderSigned?.user_output_signature,\n\t);\n\n\tif (!(await publicKey.verify(userPublicOutput, userOutputSignature))) {\n\t\tthrow new Error('Invalid signature');\n\t}\n\n\tif (publicKey.toSuiAddress() !== encryptedUserSecretKeyShare.encryption_key_address) {\n\t\tthrow new Error(\n\t\t\t'Invalid Sui address. The encryption key address does not match the signing keypair address.',\n\t\t);\n\t}\n\n\treturn Uint8Array.from(dWallet.state.Active.public_output);\n}\n\n/**\n * Verify that the user's public output matches the network's public output.\n *\n * @param curve - The curve to use\n * @param userPublicOutput - The user's public output\n * @param networkDKGOutput - The network's public output\n * @returns True if the user's public output matches the network's public output, false otherwise\n */\nexport async function userAndNetworkDKGOutputMatch(\n\tcurve: Curve,\n\tuserPublicOutput: Uint8Array,\n\tnetworkDKGOutput: Uint8Array,\n): Promise<boolean> {\n\treturn await centralized_and_decentralized_parties_dkg_output_match(\n\t\tfromCurveToNumber(curve),\n\t\tuserPublicOutput,\n\t\tnetworkDKGOutput,\n\t);\n}\n\n/**\n * Parse a signature from a sign output.\n *\n * @param curve - The curve to use\n * @param signatureAlgorithm - The signature algorithm to use\n * @param signatureOutput - The signature output bytes from the network\n * @returns The parsed signature bytes\n */\nexport async function parseSignatureFromSignOutput<\n\tC extends Curve,\n\tS extends ValidSignatureAlgorithmForCurve<C>,\n>(curve: C, signatureAlgorithm: S, signatureOutput: Uint8Array): Promise<Uint8Array> {\n\treturn Uint8Array.from(\n\t\tawait parse_signature_from_sign_output(\n\t\t\tfromCurveToNumber(curve),\n\t\t\tfromSignatureAlgorithmToNumber(curve, signatureAlgorithm),\n\t\t\tsignatureOutput,\n\t\t),\n\t);\n}\n\n/**\n * Create a digest of the session identifier for cryptographic operations.\n * This function creates a versioned, domain-separated hash of the session identifier.\n *\n * @param bytesToHash - The bytes to hash for session identifier generation\n * @param senderAddressBytes - The sender address bytes for session identifier generation\n * @returns The KECCAK-256 digest of the versioned and domain-separated session identifier\n * @private\n */\nexport function sessionIdentifierDigest(\n\tbytesToHash: Uint8Array,\n\tsenderAddressBytes: Uint8Array,\n): Uint8Array {\n\tconst preimage = keccak_256(Uint8Array.from([...senderAddressBytes, ...bytesToHash]));\n\tconst version = 0; // Version of the session identifier\n\t// Calculate the user session identifier for digest\n\tconst data = Uint8Array.from([\n\t\t...u64ToBytesBigEndian(version),\n\t\t...encodeToASCII('USER'),\n\t\t...preimage,\n\t]);\n\t// Compute the SHA3-256 digest of the serialized data\n\tconst digest = keccak_256(data);\n\treturn Uint8Array.from(digest);\n}\n\n/**\n * Create a random session identifier.\n *\n * @returns 32 random bytes for use as a session identifier\n */\nexport function createRandomSessionIdentifier(): Uint8Array {\n\treturn Uint8Array.from(randomBytes(32));\n}\n"],
  "mappings": "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",
  "names": ["import_utils", "create_dkg_user_output", "create_imported_dwallet_user_output", "create_sign_user_message"]
}
