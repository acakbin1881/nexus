{
  "version": 3,
  "sources": ["../../../src/client/ika-client.ts"],
  "sourcesContent": ["// Copyright (c) dWallet Labs, Ltd.\n// SPDX-License-Identifier: BSD-3-Clause-Clear\n\nimport type { SuiClient } from '@mysten/sui/client';\nimport { Transaction } from '@mysten/sui/transactions';\nimport { toHex } from '@mysten/sui/utils';\n\nimport * as CoordinatorInnerModule from '../generated/ika_dwallet_2pc_mpc/coordinator_inner.js';\nimport * as CoordinatorModule from '../generated/ika_dwallet_2pc_mpc/coordinator.js';\nimport { TableVec } from '../generated/ika_system/deps/sui/table_vec.js';\nimport * as SystemModule from '../generated/ika_system/system.js';\nimport { getActiveEncryptionKey as getActiveEncryptionKeyFromCoordinator } from '../tx/coordinator.js';\nimport {\n\tnetworkDkgPublicOutputToProtocolPublicParameters,\n\tparseSignatureFromSignOutput,\n\treconfigurationPublicOutputToProtocolPublicParameters,\n} from './cryptography.js';\nimport { InvalidObjectError, NetworkError, ObjectNotFoundError } from './errors.js';\nimport { fromNumberToCurve, validateCurveSignatureAlgorithm } from './hash-signature-validation.js';\nimport type { ValidSignatureAlgorithmForCurve } from './hash-signature-validation.js';\nimport { CoordinatorInnerDynamicField, DynamicField, SystemInnerDynamicField } from './types.js';\nimport type {\n\tCoordinatorInner,\n\tCurve,\n\tDWallet,\n\tDWalletCap,\n\tDWalletInternal,\n\tDWalletKind,\n\tDWalletState,\n\tDWalletWithState,\n\tEncryptedUserSecretKeyShare,\n\tEncryptedUserSecretKeyShareState,\n\tEncryptedUserSecretKeyShareWithState,\n\tEncryptionKey,\n\tEncryptionKeyOptions,\n\tIkaClientOptions,\n\tIkaConfig,\n\tNetworkEncryptionKey,\n\tPartialUserSignature,\n\tPartialUserSignatureState,\n\tPartialUserSignatureWithState,\n\tPresign,\n\tPresignState,\n\tPresignWithState,\n\tSharedObjectOwner,\n\tSign,\n\tSignatureAlgorithm,\n\tSignState,\n\tSignWithState,\n\tSystemInner,\n} from './types.js';\nimport { fetchAllDynamicFields, objResToBcs } from './utils.js';\n\n/**\n * IkaClient provides a high-level interface for interacting with the Ika network.\n * It handles network configuration, object fetching, caching, and provides methods\n * for retrieving DWallets, presigns, and other network objects.\n */\nexport class IkaClient {\n\t/** The Ika network configuration including package IDs and object references */\n\tpublic ikaConfig: IkaConfig;\n\t/** Default encryption key options for the client */\n\tpublic encryptionKeyOptions: EncryptionKeyOptions;\n\n\t/** The underlying Sui client for blockchain interactions */\n\tprivate client: SuiClient;\n\t/** Whether to enable caching of network objects and parameters */\n\tprivate cache: boolean;\n\t/** Cached network public parameters by encryption key ID and curve to avoid repeated fetching */\n\tprivate cachedProtocolPublicParameters: Map<\n\t\tstring,\n\t\t{\n\t\t\tnetworkEncryptionKeyPublicOutputID: string;\n\t\t\tepoch: number;\n\t\t\tcurve: Curve;\n\t\t\tprotocolPublicParameters: Uint8Array;\n\t\t}\n\t> = new Map();\n\t/** Cached network objects (coordinator and system inner objects) - separate from encryption keys */\n\tprivate cachedObjects?: {\n\t\tcoordinatorInner: CoordinatorInner;\n\t\tsystemInner: SystemInner;\n\t};\n\t/** Cached encryption keys by ID for efficient access */\n\tprivate cachedEncryptionKeys: Map<string, NetworkEncryptionKey> = new Map();\n\t/** Promise for ongoing object fetching to prevent duplicate requests */\n\tprivate objectsPromise?: Promise<{\n\t\tcoordinatorInner: CoordinatorInner;\n\t\tsystemInner: SystemInner;\n\t}>;\n\t/** Promise for ongoing encryption key fetching to prevent duplicate requests */\n\tprivate encryptionKeysPromise?: Promise<NetworkEncryptionKey[]>;\n\n\t/**\n\t * Creates a new IkaClient instance\n\t *\n\t * @param options - Configuration options for the client\n\t * @param options.suiClient - The Sui client instance to use for blockchain interactions\n\t * @param options.config - The Ika network configuration\n\t * @param options.cache - Whether to enable caching (default: true)\n\t */\n\tconstructor({ suiClient, config, cache = true, encryptionKeyOptions }: IkaClientOptions) {\n\t\tthis.client = suiClient;\n\t\tthis.ikaConfig = config;\n\t\tthis.cache = cache;\n\t\tthis.encryptionKeyOptions = encryptionKeyOptions || { autoDetect: true };\n\t}\n\n\t/**\n\t * Invalidate all cached data including objects and public parameters.\n\t * This forces the client to refetch data on the next request.\n\t */\n\tinvalidateCache(): void {\n\t\tthis.cachedObjects = undefined;\n\t\tthis.cachedProtocolPublicParameters.clear();\n\t\tthis.objectsPromise = undefined;\n\t\tthis.cachedEncryptionKeys.clear();\n\t\tthis.encryptionKeysPromise = undefined;\n\t}\n\n\t/**\n\t * Invalidate only the cached objects (coordinator and system inner objects).\n\t * Public parameters and encryption key caches are preserved.\n\t */\n\tinvalidateObjectCache(): void {\n\t\tthis.cachedObjects = undefined;\n\t\tthis.objectsPromise = undefined;\n\t}\n\n\t/**\n\t * Invalidate only the cached encryption keys.\n\t * Network objects and public parameters caches are preserved.\n\t */\n\tinvalidateEncryptionKeyCache(): void {\n\t\tthis.cachedEncryptionKeys.clear();\n\t\tthis.encryptionKeysPromise = undefined;\n\t}\n\n\t/**\n\t * Invalidate cached protocol public parameters for a specific encryption key and/or curve.\n\t * If no parameters are provided, clears all cached protocol parameters.\n\t * If only encryptionKeyID is provided, clears all curves for that key.\n\t * If both are provided, clears only that specific combination.\n\t *\n\t * @param encryptionKeyID - Optional specific encryption key ID to invalidate\n\t * @param curve - Optional specific curve to invalidate\n\t */\n\tinvalidateProtocolPublicParametersCache(encryptionKeyID?: string, curve?: Curve): void {\n\t\tif (encryptionKeyID !== undefined && curve !== undefined) {\n\t\t\tthis.cachedProtocolPublicParameters.delete(this.#getCacheKey(encryptionKeyID, curve));\n\t\t} else if (encryptionKeyID !== undefined) {\n\t\t\t// Clear all curves for this encryption key\n\t\t\tfor (const key of this.cachedProtocolPublicParameters.keys()) {\n\t\t\t\tif (key.startsWith(`${encryptionKeyID}-`)) {\n\t\t\t\t\tthis.cachedProtocolPublicParameters.delete(key);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.cachedProtocolPublicParameters.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the client by fetching and caching network objects.\n\t * This method should be called before using other client methods.\n\t *\n\t * @returns Promise that resolves when initialization is complete\n\t */\n\tasync initialize(): Promise<void> {\n\t\tawait this.ensureInitialized();\n\t}\n\n\t/**\n\t * Ensure the client is initialized with core network objects.\n\t * This method handles caching and prevents duplicate initialization requests.\n\t *\n\t * @returns Promise resolving to the core network objects\n\t * @throws {NetworkError} If initialization fails\n\t * @private\n\t */\n\tasync ensureInitialized(): Promise<{\n\t\tcoordinatorInner: CoordinatorInner;\n\t\tsystemInner: SystemInner;\n\t}> {\n\t\tif (!this.cache) {\n\t\t\treturn this.#getObjects();\n\t\t}\n\n\t\tif (this.cachedObjects) {\n\t\t\treturn this.cachedObjects;\n\t\t}\n\n\t\tif (this.objectsPromise) {\n\t\t\tawait this.objectsPromise;\n\t\t\treturn this.cachedObjects!;\n\t\t}\n\n\t\tawait this.#getObjects();\n\t\treturn this.cachedObjects!;\n\t}\n\n\t/**\n\t * Get all available network encryption keys.\n\t * This method fetches and caches all encryption keys for efficient access.\n\t *\n\t * @returns Promise resolving to an array of all network encryption keys\n\t * @throws {NetworkError} If the encryption keys cannot be fetched\n\t */\n\tasync getAllNetworkEncryptionKeys(): Promise<NetworkEncryptionKey[]> {\n\t\tif (!this.cache) {\n\t\t\treturn this.#fetchEncryptionKeys();\n\t\t}\n\n\t\tif (this.cachedEncryptionKeys.size > 0) {\n\t\t\treturn Array.from(this.cachedEncryptionKeys.values());\n\t\t}\n\n\t\tif (this.encryptionKeysPromise) {\n\t\t\tawait this.encryptionKeysPromise;\n\t\t\treturn Array.from(this.cachedEncryptionKeys.values());\n\t\t}\n\n\t\tawait this.#fetchEncryptionKeys();\n\t\treturn Array.from(this.cachedEncryptionKeys.values());\n\t}\n\n\t/**\n\t * Get the latest network encryption key.\n\t * This is the most recent encryption key created for the network.\n\t *\n\t * @returns Promise resolving to the latest network encryption key\n\t * @throws {NetworkError} If the encryption keys cannot be fetched\n\t */\n\tasync getLatestNetworkEncryptionKey(): Promise<NetworkEncryptionKey> {\n\t\tconst keys = await this.getAllNetworkEncryptionKeys();\n\t\tif (keys.length === 0) {\n\t\t\tthrow new NetworkError('No network encryption keys found');\n\t\t}\n\t\treturn keys[keys.length - 1];\n\t}\n\n\t/**\n\t * Get a specific network encryption key by ID.\n\t *\n\t * @param encryptionKeyID - The ID of the encryption key to retrieve\n\t * @returns Promise resolving to the specified network encryption key\n\t * @throws {ObjectNotFoundError} If the encryption key is not found\n\t * @throws {NetworkError} If the encryption keys cannot be fetched\n\t */\n\tasync getNetworkEncryptionKey(encryptionKeyID: string): Promise<NetworkEncryptionKey> {\n\t\tconst keys = await this.getAllNetworkEncryptionKeys();\n\t\tconst key = keys.find((k) => k.id === encryptionKeyID);\n\t\tif (!key) {\n\t\t\tthrow new ObjectNotFoundError(`Network encryption key ${encryptionKeyID} not found`);\n\t\t}\n\t\treturn key;\n\t}\n\n\t/**\n\t * Get the network encryption key used by a specific dWallet.\n\t * This method automatically detects which encryption key the dWallet uses.\n\t *\n\t * @param dwalletID - The ID of the dWallet to check\n\t * @returns Promise resolving to the network encryption key used by the dWallet\n\t * @throws {InvalidObjectError} If the dWallet cannot be parsed\n\t * @throws {NetworkError} If the network request fails\n\t */\n\tasync getDWalletNetworkEncryptionKey(dwalletID: string): Promise<NetworkEncryptionKey> {\n\t\tconst dWallet = await this.getDWallet(dwalletID);\n\n\t\tconst encryptionKeyID = dWallet.dwallet_network_encryption_key_id;\n\n\t\treturn this.getNetworkEncryptionKey(encryptionKeyID);\n\t}\n\n\t/**\n\t * Get the network encryption key based on client configuration.\n\t * This method respects the client's encryption key options.\n\t *\n\t * @returns Promise resolving to the appropriate network encryption key\n\t * @throws {NetworkError} If the encryption keys cannot be fetched\n\t */\n\tasync getConfiguredNetworkEncryptionKey(): Promise<NetworkEncryptionKey> {\n\t\tif (this.encryptionKeyOptions.encryptionKeyID) {\n\t\t\t// Use specific encryption key if configured\n\t\t\treturn this.getNetworkEncryptionKey(this.encryptionKeyOptions.encryptionKeyID);\n\t\t}\n\n\t\t// Default to latest encryption key\n\t\treturn this.getLatestNetworkEncryptionKey();\n\t}\n\n\t/**\n\t * Retrieve a DWallet object by its ID.\n\t *\n\t * @param dwalletID - The unique identifier of the DWallet to retrieve\n\t * @returns Promise resolving to the DWallet object\n\t * @throws {InvalidObjectError} If the object cannot be parsed or is invalid\n\t * @throws {NetworkError} If the network request fails\n\t */\n\tasync getDWallet(dwalletID: string): Promise<DWallet> {\n\t\tawait this.ensureInitialized();\n\n\t\treturn this.client\n\t\t\t.getObject({\n\t\t\t\tid: dwalletID,\n\t\t\t\toptions: { showBcs: true },\n\t\t\t})\n\t\t\t.then((obj) => {\n\t\t\t\tconst dWallet = CoordinatorInnerModule.DWallet.fromBase64(objResToBcs(obj));\n\n\t\t\t\treturn {\n\t\t\t\t\t...dWallet,\n\t\t\t\t\tkind: this.#getDWalletKind(dWallet),\n\t\t\t\t};\n\t\t\t});\n\t}\n\n\t/**\n\t * Retrieve a DWallet in a particular state, waiting until it reaches that state.\n\t * This method polls the DWallet until it matches the specified state.\n\t *\n\t * @param dwalletID - The unique identifier of the DWallet to retrieve\n\t * @param state - The target state to wait for\n\t * @param options - Optional configuration for polling behavior\n\t * @param options.timeout - Maximum time to wait in milliseconds (default: 30000)\n\t * @param options.interval - Initial polling interval in milliseconds (default: 1000)\n\t * @param options.maxInterval - Maximum polling interval with exponential backoff (default: 5000)\n\t * @param options.backoffMultiplier - Multiplier for exponential backoff (default: 1.5)\n\t * @param options.signal - AbortSignal to cancel the polling\n\t * @returns Promise resolving to the DWallet object when it reaches the target state\n\t * @throws {InvalidObjectError} If the object cannot be parsed or is invalid\n\t * @throws {NetworkError} If the network request fails\n\t * @throws {Error} If timeout is reached before the target state is achieved or operation is aborted\n\t */\n\tasync getDWalletInParticularState<S extends DWalletState>(\n\t\tdwalletID: string,\n\t\tstate: S,\n\t\toptions?: {\n\t\t\ttimeout?: number;\n\t\t\tinterval?: number;\n\t\t\tmaxInterval?: number;\n\t\t\tbackoffMultiplier?: number;\n\t\t\tsignal?: AbortSignal;\n\t\t},\n\t): Promise<DWalletWithState<S>>;\n\tasync getDWalletInParticularState(\n\t\tdwalletID: string,\n\t\tstate: DWalletState,\n\t\toptions: {\n\t\t\ttimeout?: number;\n\t\t\tinterval?: number;\n\t\t\tmaxInterval?: number;\n\t\t\tbackoffMultiplier?: number;\n\t\t\tsignal?: AbortSignal;\n\t\t} = {},\n\t): Promise<DWallet> {\n\t\treturn this.#pollUntilState(\n\t\t\t() => this.getDWallet(dwalletID),\n\t\t\tstate,\n\t\t\t`DWallet ${dwalletID} to reach state ${state}`,\n\t\t\toptions,\n\t\t) as Promise<DWallet>;\n\t}\n\n\t/**\n\t * Retrieve a presign session object by its ID.\n\t *\n\t * @param presignID - The unique identifier of the presign session to retrieve\n\t * @returns Promise resolving to the Presign object\n\t * @throws {InvalidObjectError} If the object cannot be parsed or is invalid\n\t * @throws {NetworkError} If the network request fails\n\t */\n\tasync getPresign(presignID: string): Promise<Presign> {\n\t\tawait this.ensureInitialized();\n\n\t\treturn this.client\n\t\t\t.getObject({\n\t\t\t\tid: presignID,\n\t\t\t\toptions: { showBcs: true },\n\t\t\t})\n\t\t\t.then((obj) => {\n\t\t\t\treturn CoordinatorInnerModule.PresignSession.fromBase64(objResToBcs(obj));\n\t\t\t});\n\t}\n\n\t/**\n\t * Retrieve a presign session object in a particular state, waiting until it reaches that state.\n\t * This method polls the presign until it matches the specified state.\n\t *\n\t * @param presignID - The unique identifier of the presign session to retrieve\n\t * @param state - The target state to wait for\n\t * @param options - Optional configuration for polling behavior\n\t * @param options.timeout - Maximum time to wait in milliseconds (default: 30000)\n\t * @param options.interval - Initial polling interval in milliseconds (default: 1000)\n\t * @param options.maxInterval - Maximum polling interval with exponential backoff (default: 5000)\n\t * @param options.backoffMultiplier - Multiplier for exponential backoff (default: 1.5)\n\t * @param options.signal - AbortSignal to cancel the polling\n\t * @returns Promise resolving to the Presign object when it reaches the target state\n\t * @throws {InvalidObjectError} If the object cannot be parsed or is invalid\n\t * @throws {NetworkError} If the network request fails\n\t * @throws {Error} If timeout is reached before the target state is achieved or operation is aborted\n\t */\n\tasync getPresignInParticularState<S extends PresignState>(\n\t\tpresignID: string,\n\t\tstate: S,\n\t\toptions?: {\n\t\t\ttimeout?: number;\n\t\t\tinterval?: number;\n\t\t\tmaxInterval?: number;\n\t\t\tbackoffMultiplier?: number;\n\t\t\tsignal?: AbortSignal;\n\t\t},\n\t): Promise<PresignWithState<S>>;\n\tasync getPresignInParticularState(\n\t\tpresignID: string,\n\t\tstate: PresignState,\n\t\toptions: {\n\t\t\ttimeout?: number;\n\t\t\tinterval?: number;\n\t\t\tmaxInterval?: number;\n\t\t\tbackoffMultiplier?: number;\n\t\t\tsignal?: AbortSignal;\n\t\t} = {},\n\t): Promise<Presign> {\n\t\treturn this.#pollUntilState(\n\t\t\t() => this.getPresign(presignID),\n\t\t\tstate,\n\t\t\t`presign ${presignID} to reach state ${state}`,\n\t\t\toptions,\n\t\t) as Promise<Presign>;\n\t}\n\n\t/**\n\t * Retrieve an encrypted user secret key share object by its ID.\n\t *\n\t * @param encryptedUserSecretKeyShareID - The unique identifier of the encrypted share to retrieve\n\t * @returns Promise resolving to the EncryptedUserSecretKeyShare object\n\t * @throws {InvalidObjectError} If the object cannot be parsed or is invalid\n\t * @throws {NetworkError} If the network request fails\n\t */\n\tasync getEncryptedUserSecretKeyShare(\n\t\tencryptedUserSecretKeyShareID: string,\n\t): Promise<EncryptedUserSecretKeyShare> {\n\t\tawait this.ensureInitialized();\n\n\t\treturn this.client\n\t\t\t.getObject({\n\t\t\t\tid: encryptedUserSecretKeyShareID,\n\t\t\t\toptions: { showBcs: true },\n\t\t\t})\n\t\t\t.then((obj) => {\n\t\t\t\treturn CoordinatorInnerModule.EncryptedUserSecretKeyShare.fromBase64(objResToBcs(obj));\n\t\t\t});\n\t}\n\n\t/**\n\t * Retrieve an encrypted user secret key share object by its ID.\n\t *\n\t * @param encryptedUserSecretKeyShareID - The unique identifier of the encrypted share to retrieve\n\t * @param state - The target state to wait for\n\t * @param options - Optional configuration for polling behavior\n\t * @param options.timeout - Maximum time to wait in milliseconds (default: 30000)\n\t * @param options.interval - Initial polling interval in milliseconds (default: 1000)\n\t * @param options.maxInterval - Maximum polling interval with exponential backoff (default: 5000)\n\t * @param options.backoffMultiplier - Multiplier for exponential backoff (default: 1.5)\n\t * @param options.signal - AbortSignal to cancel the polling\n\t * @returns Promise resolving to the EncryptedUserSecretKeyShare object\n\t * @throws {InvalidObjectError} If the object cannot be parsed or is invalid\n\t * @throws {NetworkError} If the network request fails\n\t * @throws {Error} If timeout is reached before the target state is achieved or operation is aborted\n\t */\n\tasync getEncryptedUserSecretKeyShareInParticularState<S extends EncryptedUserSecretKeyShareState>(\n\t\tencryptedUserSecretKeyShareID: string,\n\t\tstate: S,\n\t\toptions?: {\n\t\t\ttimeout?: number;\n\t\t\tinterval?: number;\n\t\t\tmaxInterval?: number;\n\t\t\tbackoffMultiplier?: number;\n\t\t\tsignal?: AbortSignal;\n\t\t},\n\t): Promise<EncryptedUserSecretKeyShareWithState<S>>;\n\tasync getEncryptedUserSecretKeyShareInParticularState(\n\t\tencryptedUserSecretKeyShareID: string,\n\t\tstate: EncryptedUserSecretKeyShareState,\n\t\toptions: {\n\t\t\ttimeout?: number;\n\t\t\tinterval?: number;\n\t\t\tmaxInterval?: number;\n\t\t\tbackoffMultiplier?: number;\n\t\t\tsignal?: AbortSignal;\n\t\t} = {},\n\t): Promise<EncryptedUserSecretKeyShare> {\n\t\treturn this.#pollUntilState(\n\t\t\t() => this.getEncryptedUserSecretKeyShare(encryptedUserSecretKeyShareID),\n\t\t\tstate,\n\t\t\t`encrypted user secret key share ${encryptedUserSecretKeyShareID} to reach state ${state}`,\n\t\t\toptions,\n\t\t) as Promise<EncryptedUserSecretKeyShare>;\n\t}\n\n\t/**\n\t * Retrieve a partial user signature object by its ID.\n\t *\n\t * @param partialCentralizedSignedMessageID - The unique identifier of the partial signature to retrieve\n\t * @returns Promise resolving to the PartialUserSignature object\n\t * @throws {InvalidObjectError} If the object cannot be parsed or is invalid\n\t * @throws {NetworkError} If the network request fails\n\t */\n\tasync getPartialUserSignature(\n\t\tpartialCentralizedSignedMessageID: string,\n\t): Promise<PartialUserSignature> {\n\t\tawait this.ensureInitialized();\n\n\t\treturn this.client\n\t\t\t.getObject({\n\t\t\t\tid: partialCentralizedSignedMessageID,\n\t\t\t\toptions: { showBcs: true },\n\t\t\t})\n\t\t\t.then((obj) => {\n\t\t\t\treturn CoordinatorInnerModule.PartialUserSignature.fromBase64(objResToBcs(obj));\n\t\t\t});\n\t}\n\n\tasync getPartialUserSignatureInParticularState<S extends PartialUserSignatureState>(\n\t\tpartialCentralizedSignedMessageID: string,\n\t\tstate: S,\n\t\toptions?: {\n\t\t\ttimeout?: number;\n\t\t\tinterval?: number;\n\t\t\tmaxInterval?: number;\n\t\t\tbackoffMultiplier?: number;\n\t\t\tsignal?: AbortSignal;\n\t\t},\n\t): Promise<PartialUserSignatureWithState<S>>;\n\tasync getPartialUserSignatureInParticularState(\n\t\tpartialCentralizedSignedMessageID: string,\n\t\tstate: PartialUserSignatureState,\n\t\toptions: {\n\t\t\ttimeout?: number;\n\t\t\tinterval?: number;\n\t\t\tmaxInterval?: number;\n\t\t\tbackoffMultiplier?: number;\n\t\t\tsignal?: AbortSignal;\n\t\t} = {},\n\t): Promise<PartialUserSignature> {\n\t\treturn this.#pollUntilState(\n\t\t\t() => this.getPartialUserSignature(partialCentralizedSignedMessageID),\n\t\t\tstate,\n\t\t\t`partial user signature ${partialCentralizedSignedMessageID} to reach state ${state}`,\n\t\t\toptions,\n\t\t) as Promise<PartialUserSignature>;\n\t}\n\n\t/**\n\t * Retrieve a sign session object by its ID.\n\t *\n\t * @param signID - The unique identifier of the sign session to retrieve\n\t * @param curve - The curve to use for parsing\n\t * @param signatureAlgorithm - The signature algorithm to use for parsing (must be valid for the curve)\n\t *\n\t * @returns Promise resolving to the Sign object\n\t * @throws {InvalidObjectError} If the object cannot be parsed or is invalid\n\t * @throws {NetworkError} If the network request fails\n\t */\n\tasync getSign<C extends Curve>(\n\t\tsignID: string,\n\t\tcurve: C,\n\t\tsignatureAlgorithm: ValidSignatureAlgorithmForCurve<C>,\n\t): Promise<Sign> {\n\t\tawait this.ensureInitialized();\n\n\t\tvalidateCurveSignatureAlgorithm(curve, signatureAlgorithm);\n\n\t\tconst unparsedSign = await this.client.getObject({\n\t\t\tid: signID,\n\t\t\toptions: { showBcs: true },\n\t\t});\n\n\t\tconst sign = CoordinatorInnerModule.SignSession.fromBase64(objResToBcs(unparsedSign));\n\n\t\tif (sign.state.$kind === 'Completed') {\n\t\t\tsign.state.Completed.signature = Array.from(\n\t\t\t\tawait parseSignatureFromSignOutput(\n\t\t\t\t\tcurve,\n\t\t\t\t\tsignatureAlgorithm,\n\t\t\t\t\tUint8Array.from(sign.state.Completed.signature),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\treturn sign;\n\t}\n\n\t/**\n\t * Retrieve a sign session object in a particular state, waiting until it reaches that state.\n\t * This method polls the sign until it matches the specified state.\n\t *\n\t * @param signID - The unique identifier of the sign session to retrieve\n\t * @param curve - The curve to use for parsing\n\t * @param signatureAlgorithm - The signature algorithm to use for parsing (must be valid for the curve)\n\t * @param state - The target state to wait for\n\t * @param options - Optional configuration for polling behavior\n\t * @param options.timeout - Maximum time to wait in milliseconds (default: 30000)\n\t * @param options.interval - Initial polling interval in milliseconds (default: 1000)\n\t * @param options.maxInterval - Maximum polling interval with exponential backoff (default: 5000)\n\t * @param options.backoffMultiplier - Multiplier for exponential backoff (default: 1.5)\n\t * @param options.signal - AbortSignal to cancel the polling\n\t * @returns Promise resolving to the Sign object when it reaches the target state\n\t * @throws {InvalidObjectError} If the object cannot be parsed or is invalid\n\t * @throws {NetworkError} If the network request fails\n\t * @throws {Error} If timeout is reached before the target state is achieved or operation is aborted\n\t */\n\tasync getSignInParticularState<S extends SignState>(\n\t\tsignID: string,\n\t\tcurve: Curve,\n\t\tsignatureAlgorithm: SignatureAlgorithm,\n\t\tstate: S,\n\t\toptions?: {\n\t\t\ttimeout?: number;\n\t\t\tinterval?: number;\n\t\t\tmaxInterval?: number;\n\t\t\tbackoffMultiplier?: number;\n\t\t\tsignal?: AbortSignal;\n\t\t},\n\t): Promise<SignWithState<S>>;\n\tasync getSignInParticularState(\n\t\tsignID: string,\n\t\tcurve: Curve,\n\t\tsignatureAlgorithm: SignatureAlgorithm,\n\t\tstate: SignState,\n\t\toptions: {\n\t\t\ttimeout?: number;\n\t\t\tinterval?: number;\n\t\t\tmaxInterval?: number;\n\t\t\tbackoffMultiplier?: number;\n\t\t\tsignal?: AbortSignal;\n\t\t} = {},\n\t): Promise<Sign> {\n\t\treturn this.#pollUntilState(\n\t\t\t() => this.getSign(signID, curve, signatureAlgorithm),\n\t\t\tstate,\n\t\t\t`sign ${signID} to reach state ${state}`,\n\t\t\toptions,\n\t\t) as Promise<Sign>;\n\t}\n\n\t/**\n\t * Retrieve multiple DWallet objects by their IDs in a single batch request.\n\t * This is more efficient than making individual requests for multiple DWallets.\n\t *\n\t * @param dwalletIDs - Array of unique identifiers for the DWallets to retrieve\n\t * @returns Promise resolving to an array of DWallet objects\n\t * @throws {InvalidObjectError} If any object cannot be parsed or is invalid\n\t * @throws {NetworkError} If the network request fails\n\t */\n\tasync getMultipleDWallets(dwalletIDs: string[]): Promise<DWallet[]> {\n\t\tawait this.ensureInitialized();\n\n\t\treturn this.client\n\t\t\t.multiGetObjects({\n\t\t\t\tids: dwalletIDs,\n\t\t\t\toptions: { showBcs: true },\n\t\t\t})\n\t\t\t.then((objs) => {\n\t\t\t\treturn objs.map((obj) => {\n\t\t\t\t\tconst dWallet = CoordinatorInnerModule.DWallet.fromBase64(objResToBcs(obj));\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...dWallet,\n\t\t\t\t\t\tkind: this.#getDWalletKind(dWallet),\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\t/**\n\t * Retrieve DWallet capabilities owned by a specific address.\n\t * DWallet capabilities grant the holder permission to use the associated DWallet.\n\t *\n\t * @param address - The Sui address to query for owned DWallet capabilities\n\t * @param cursor - Optional cursor for pagination (from previous request)\n\t * @param limit - Optional limit on the number of results to return\n\t * @returns Promise resolving to paginated results containing DWallet capabilities\n\t * @throws {InvalidObjectError} If any object cannot be parsed or is invalid\n\t * @throws {NetworkError} If the network request fails\n\t */\n\tasync getOwnedDWalletCaps(\n\t\taddress: string,\n\t\tcursor?: string,\n\t\tlimit?: number,\n\t): Promise<{\n\t\tdWalletCaps: DWalletCap[];\n\t\tcursor: string | null | undefined;\n\t\thasNextPage: boolean;\n\t}> {\n\t\tawait this.ensureInitialized();\n\n\t\tconst response = await this.client.getOwnedObjects({\n\t\t\towner: address,\n\t\t\tfilter: {\n\t\t\t\tStructType: `${this.ikaConfig.packages.ikaDwallet2pcMpcOriginalPackage}::coordinator_inner::DWalletCap`,\n\t\t\t},\n\t\t\toptions: {\n\t\t\t\tshowBcs: true,\n\t\t\t},\n\t\t\tcursor,\n\t\t\tlimit,\n\t\t});\n\n\t\treturn {\n\t\t\tdWalletCaps: response.data.map((obj) =>\n\t\t\t\tCoordinatorInnerModule.DWalletCap.fromBase64(objResToBcs(obj)),\n\t\t\t),\n\t\t\tcursor: response.nextCursor,\n\t\t\thasNextPage: response.hasNextPage,\n\t\t};\n\t}\n\n\t/**\n\t * Get cached protocol public parameters for a specific encryption key and curve.\n\t * Returns undefined if not cached or if the cache is invalid.\n\t *\n\t * @param encryptionKeyID - The ID of the encryption key to get cached parameters for\n\t * @param curve - The curve to get cached parameters for\n\t * @returns Cached protocol public parameters or undefined if not cached\n\t */\n\tgetCachedProtocolPublicParameters(encryptionKeyID: string, curve: Curve): Uint8Array | undefined {\n\t\tconst cacheKey = this.#getCacheKey(encryptionKeyID, curve);\n\t\tconst cachedParams = this.cachedProtocolPublicParameters.get(cacheKey);\n\t\tif (!cachedParams) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Get the current encryption key to check if cache is still valid\n\t\tconst currentKey = this.cachedEncryptionKeys.get(encryptionKeyID);\n\t\tif (!currentKey) {\n\t\t\t// Key not in cache, cache is invalid\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Check if the cached parameters match the current key state and curve\n\t\tif (\n\t\t\tcachedParams.networkEncryptionKeyPublicOutputID === currentKey.networkDKGOutputID &&\n\t\t\tcachedParams.epoch === currentKey.epoch &&\n\t\t\tcachedParams.curve === curve\n\t\t) {\n\t\t\treturn cachedParams.protocolPublicParameters;\n\t\t}\n\n\t\t// Cache is invalid, remove it\n\t\tthis.cachedProtocolPublicParameters.delete(cacheKey);\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Check if protocol public parameters are cached for a specific encryption key and curve.\n\t *\n\t * @param encryptionKeyID - The ID of the encryption key to check\n\t * @param curve - The curve to check\n\t * @returns True if valid cached parameters exist, false otherwise\n\t */\n\tisProtocolPublicParametersCached(encryptionKeyID: string, curve: Curve): boolean {\n\t\treturn this.getCachedProtocolPublicParameters(encryptionKeyID, curve) !== undefined;\n\t}\n\n\t/**\n\t * Get the current encryption key options for the client.\n\t *\n\t * @returns The current encryption key options\n\t */\n\tgetEncryptionKeyOptions(): EncryptionKeyOptions {\n\t\treturn { ...this.encryptionKeyOptions };\n\t}\n\n\t/**\n\t * Set the encryption key options for the client.\n\t * This affects all subsequent calls to methods that use encryption keys.\n\t *\n\t * @param options - The new encryption key options\n\t */\n\tsetEncryptionKeyOptions(options: EncryptionKeyOptions): void {\n\t\tthis.encryptionKeyOptions = { ...options };\n\t}\n\n\t/**\n\t * Set a specific encryption key ID to use for all operations.\n\t * This is a convenience method for setting just the encryption key ID.\n\t *\n\t * @param encryptionKeyID - The encryption key ID to use\n\t */\n\tsetEncryptionKeyID(encryptionKeyID: string): void {\n\t\tthis.encryptionKeyOptions = { ...this.encryptionKeyOptions, encryptionKeyID };\n\t}\n\n\t/**\n\t * Retrieve the protocol public parameters used for cryptographic operations.\n\t * These parameters are cached by encryption key ID and only refetched when the epoch or decryption key changes.\n\t *\n\t * @param dWallet - The DWallet to get the protocol public parameters for\n\t * @param curve - The curve to use for key generation\n\t * @returns Promise resolving to the protocol public parameters as bytes\n\t * @throws {ObjectNotFoundError} If the public parameters cannot be found\n\t * @throws {NetworkError} If the network request fails\n\t */\n\tasync getProtocolPublicParameters(dWallet?: DWallet, curve?: Curve): Promise<Uint8Array> {\n\t\tawait this.#fetchEncryptionKeysFromNetwork();\n\n\t\tlet networkEncryptionKey: NetworkEncryptionKey;\n\n\t\tif (dWallet) {\n\t\t\tnetworkEncryptionKey = await this.getDWalletNetworkEncryptionKey(dWallet.id.id);\n\t\t} else {\n\t\t\t// Use client's configured encryption key options\n\t\t\tnetworkEncryptionKey = await this.getConfiguredNetworkEncryptionKey();\n\t\t}\n\n\t\tconst encryptionKeyID = networkEncryptionKey.id;\n\t\tconst networkEncryptionKeyPublicOutputID = networkEncryptionKey.networkDKGOutputID;\n\t\tconst epoch = networkEncryptionKey.epoch;\n\n\t\tlet selectedCurve: Curve;\n\n\t\tif (dWallet) {\n\t\t\tselectedCurve = fromNumberToCurve(dWallet.curve);\n\t\t} else {\n\t\t\tselectedCurve = curve !== undefined ? curve : fromNumberToCurve(0);\n\t\t}\n\n\t\t// Check if we have cached parameters for this specific encryption key and curve\n\t\tconst cacheKey = this.#getCacheKey(encryptionKeyID, selectedCurve);\n\t\tconst cachedParams = this.cachedProtocolPublicParameters.get(cacheKey);\n\t\tif (cachedParams) {\n\t\t\tif (\n\t\t\t\tcachedParams.networkEncryptionKeyPublicOutputID === networkEncryptionKeyPublicOutputID &&\n\t\t\t\tcachedParams.epoch === epoch &&\n\t\t\t\tcachedParams.curve === selectedCurve\n\t\t\t) {\n\t\t\t\treturn cachedParams.protocolPublicParameters;\n\t\t\t}\n\t\t}\n\n\t\tconst protocolPublicParameters = !networkEncryptionKey.reconfigurationOutputID\n\t\t\t? await networkDkgPublicOutputToProtocolPublicParameters(\n\t\t\t\t\tselectedCurve,\n\t\t\t\t\tawait this.readTableVecAsRawBytes(networkEncryptionKeyPublicOutputID),\n\t\t\t\t)\n\t\t\t: await reconfigurationPublicOutputToProtocolPublicParameters(\n\t\t\t\t\tselectedCurve,\n\t\t\t\t\tawait this.readTableVecAsRawBytes(networkEncryptionKey.reconfigurationOutputID),\n\t\t\t\t\tawait this.readTableVecAsRawBytes(networkEncryptionKeyPublicOutputID),\n\t\t\t\t);\n\n\t\t// Cache the parameters by encryption key ID and curve\n\t\tthis.cachedProtocolPublicParameters.set(cacheKey, {\n\t\t\tnetworkEncryptionKeyPublicOutputID,\n\t\t\tepoch,\n\t\t\tcurve: selectedCurve,\n\t\t\tprotocolPublicParameters,\n\t\t});\n\n\t\treturn protocolPublicParameters;\n\t}\n\n\t/**\n\t * Get the active encryption key for a specific address.\n\t * This key is used for encrypting user shares and other cryptographic operations.\n\t *\n\t * @param address - The Sui address to get the encryption key for\n\t * @returns Promise resolving to the EncryptionKey object\n\t * @throws {InvalidObjectError} If the encryption key object cannot be parsed\n\t * @throws {NetworkError} If the network request fails\n\t */\n\tasync getActiveEncryptionKey(address: string): Promise<EncryptionKey> {\n\t\tawait this.ensureInitialized();\n\n\t\tconst tx = new Transaction();\n\n\t\tgetActiveEncryptionKeyFromCoordinator(\n\t\t\tthis.ikaConfig,\n\t\t\ttx.sharedObjectRef({\n\t\t\t\tobjectId: this.ikaConfig.objects.ikaDWalletCoordinator.objectID,\n\t\t\t\tinitialSharedVersion: this.ikaConfig.objects.ikaDWalletCoordinator.initialSharedVersion,\n\t\t\t\tmutable: true,\n\t\t\t}),\n\t\t\taddress,\n\t\t\ttx,\n\t\t);\n\n\t\tconst res = await this.client.devInspectTransactionBlock({\n\t\t\tsender: address,\n\t\t\ttransactionBlock: tx,\n\t\t});\n\n\t\tconst objIDArray = new Uint8Array(res.results?.at(0)?.returnValues?.at(0)?.at(0) as number[]);\n\t\tconst objID = toHex(objIDArray);\n\n\t\tconst obj = await this.client.getObject({\n\t\t\tid: objID,\n\t\t\toptions: { showBcs: true },\n\t\t});\n\n\t\treturn CoordinatorInnerModule.EncryptionKey.fromBase64(objResToBcs(obj));\n\t}\n\n\t/**\n\t * Get the current network epoch number.\n\t * The epoch is used for versioning and determining when to refresh cached parameters.\n\t *\n\t * @returns Promise resolving to the current epoch number\n\t * @throws {NetworkError} If the network objects cannot be fetched\n\t */\n\tasync getEpoch(): Promise<number> {\n\t\tconst objects = await this.ensureInitialized();\n\t\treturn Number(objects.coordinatorInner.current_epoch);\n\t}\n\n\t/**\n\t * Get the core network objects (coordinator inner and system inner objects).\n\t * Uses caching to avoid redundant network requests.\n\t *\n\t * @returns Promise resolving to the core network objects\n\t * @throws {NetworkError} If the network request fails\n\t * @private\n\t */\n\tasync #getObjects() {\n\t\tif (this.cachedObjects) {\n\t\t\treturn {\n\t\t\t\tcoordinatorInner: this.cachedObjects.coordinatorInner,\n\t\t\t\tsystemInner: this.cachedObjects.systemInner,\n\t\t\t};\n\t\t}\n\n\t\tif (this.objectsPromise) {\n\t\t\treturn this.objectsPromise;\n\t\t}\n\n\t\tthis.objectsPromise = this.#fetchObjectsFromNetwork();\n\n\t\ttry {\n\t\t\tconst result = await this.objectsPromise;\n\t\t\tthis.cachedObjects = {\n\t\t\t\tcoordinatorInner: result.coordinatorInner,\n\t\t\t\tsystemInner: result.systemInner,\n\t\t\t};\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tthis.objectsPromise = undefined;\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Fetch core network objects from the blockchain.\n\t * This method retrieves coordinator and system objects along with their dynamic fields.\n\t *\n\t * @returns Promise resolving to the fetched network objects\n\t * @throws {ObjectNotFoundError} If required objects or dynamic fields are not found\n\t * @throws {InvalidObjectError} If objects cannot be parsed\n\t * @throws {NetworkError} If network requests fail\n\t * @private\n\t */\n\tasync #fetchObjectsFromNetwork() {\n\t\ttry {\n\t\t\tconst [coordinator, system] = await this.client.multiGetObjects({\n\t\t\t\tids: [\n\t\t\t\t\tthis.ikaConfig.objects.ikaDWalletCoordinator.objectID,\n\t\t\t\t\tthis.ikaConfig.objects.ikaSystemObject.objectID,\n\t\t\t\t],\n\t\t\t\toptions: { showBcs: true, showOwner: true },\n\t\t\t});\n\n\t\t\tconst coordinatorParsed = CoordinatorModule.DWalletCoordinator.fromBase64(\n\t\t\t\tobjResToBcs(coordinator),\n\t\t\t);\n\t\t\tconst systemParsed = SystemModule.System.fromBase64(objResToBcs(system));\n\n\t\t\tconst [coordinatorDFs, systemDFs] = await Promise.all([\n\t\t\t\tthis.client.getDynamicFields({\n\t\t\t\t\tparentId: coordinatorParsed.id.id,\n\t\t\t\t}),\n\t\t\t\tthis.client.getDynamicFields({\n\t\t\t\t\tparentId: systemParsed.id.id,\n\t\t\t\t}),\n\t\t\t]);\n\n\t\t\tif (!coordinatorDFs.data?.length || !systemDFs.data?.length) {\n\t\t\t\tthrow new ObjectNotFoundError('Dynamic fields for coordinator or system');\n\t\t\t}\n\n\t\t\tconst coordinatorInnerDF = coordinatorDFs.data[coordinatorDFs.data.length - 1];\n\t\t\tconst systemInnerDF = systemDFs.data[systemDFs.data.length - 1];\n\n\t\t\tconst [coordinatorInner, systemInner] = await this.client.multiGetObjects({\n\t\t\t\tids: [coordinatorInnerDF.objectId, systemInnerDF.objectId],\n\t\t\t\toptions: { showBcs: true },\n\t\t\t});\n\n\t\t\tconst coordinatorInnerParsed = CoordinatorInnerDynamicField.fromBase64(\n\t\t\t\tobjResToBcs(coordinatorInner),\n\t\t\t).value;\n\n\t\t\tconst systemInnerParsed = SystemInnerDynamicField.fromBase64(objResToBcs(systemInner)).value;\n\n\t\t\tthis.ikaConfig.packages.ikaSystemPackage = systemParsed.package_id;\n\t\t\tthis.ikaConfig.packages.ikaDwallet2pcMpcPackage = coordinatorParsed.package_id;\n\n\t\t\tthis.ikaConfig.objects.ikaSystemObject.initialSharedVersion =\n\t\t\t\t(system.data?.owner as unknown as SharedObjectOwner)?.Shared?.initial_shared_version ?? 0;\n\t\t\tthis.ikaConfig.objects.ikaDWalletCoordinator.initialSharedVersion =\n\t\t\t\t(coordinator.data?.owner as unknown as SharedObjectOwner)?.Shared?.initial_shared_version ??\n\t\t\t\t0;\n\n\t\t\treturn {\n\t\t\t\tcoordinatorInner: coordinatorInnerParsed,\n\t\t\t\tsystemInner: systemInnerParsed,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (error instanceof InvalidObjectError || error instanceof ObjectNotFoundError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tthrow new NetworkError('Failed to fetch objects', error as Error);\n\t\t}\n\t}\n\n\t/**\n\t * Fetch encryption keys from the network and parse them.\n\t *\n\t * @returns Promise resolving to the fetched encryption keys\n\t * @private\n\t */\n\tasync #fetchEncryptionKeys(): Promise<NetworkEncryptionKey[]> {\n\t\tif (this.encryptionKeysPromise) {\n\t\t\treturn this.encryptionKeysPromise;\n\t\t}\n\n\t\tthis.encryptionKeysPromise = this.#fetchEncryptionKeysFromNetwork();\n\n\t\ttry {\n\t\t\tconst result = await this.encryptionKeysPromise;\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tthis.encryptionKeysPromise = undefined;\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Fetch encryption keys from the network and parse them.\n\t *\n\t * @returns Promise resolving to the fetched encryption keys\n\t * @private\n\t */\n\tasync #fetchEncryptionKeysFromNetwork(): Promise<NetworkEncryptionKey[]> {\n\t\ttry {\n\t\t\tconst objects = await this.ensureInitialized();\n\t\t\tconst keysDFs = await this.client.getDynamicFields({\n\t\t\t\tparentId: objects.coordinatorInner.dwallet_network_encryption_keys.id.id,\n\t\t\t});\n\n\t\t\tif (!keysDFs.data?.length) {\n\t\t\t\tthrow new ObjectNotFoundError('Network encryption keys');\n\t\t\t}\n\n\t\t\tconst encryptionKeys: NetworkEncryptionKey[] = [];\n\n\t\t\tfor (const keyDF of keysDFs.data) {\n\t\t\t\tconst keyName = keyDF.name.value as string;\n\t\t\t\tconst keyObject = await this.client.getObject({\n\t\t\t\t\tid: keyDF.objectId,\n\t\t\t\t\toptions: { showBcs: true },\n\t\t\t\t});\n\n\t\t\t\tconst keyParsed = CoordinatorInnerModule.DWalletNetworkEncryptionKey.fromBase64(\n\t\t\t\t\tobjResToBcs(keyObject),\n\t\t\t\t);\n\n\t\t\t\tconst reconfigOutputsDFs = await fetchAllDynamicFields(\n\t\t\t\t\tthis.client,\n\t\t\t\t\tkeyParsed.reconfiguration_public_outputs.id.id,\n\t\t\t\t);\n\n\t\t\t\tconst lastReconfigOutput = (\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\treconfigOutputsDFs.map(async (df) => {\n\t\t\t\t\t\t\tconst name = df.name.value as string;\n\t\t\t\t\t\t\tconst reconfigObject = await this.client.getObject({\n\t\t\t\t\t\t\t\tid: df.objectId,\n\t\t\t\t\t\t\t\toptions: { showBcs: true },\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tconst parsedValue = DynamicField(TableVec).fromBase64(objResToBcs(reconfigObject));\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tparsedValue,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}),\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\t.sort((a, b) => Number(a.name) - Number(b.name))\n\t\t\t\t\t// The last reconfiguration has not necessarily been completed, so we take the second to last\n\t\t\t\t\t.at(-2);\n\n\t\t\t\tconst encryptionKey: NetworkEncryptionKey = {\n\t\t\t\t\tid: keyName,\n\t\t\t\t\tepoch: Number(keyParsed.dkg_at_epoch),\n\t\t\t\t\tnetworkDKGOutputID: keyParsed.network_dkg_public_output.contents.id.id,\n\t\t\t\t\treconfigurationOutputID: lastReconfigOutput?.parsedValue.value.contents.id.id,\n\t\t\t\t};\n\n\t\t\t\tencryptionKeys.push(encryptionKey);\n\t\t\t\tthis.cachedEncryptionKeys.set(keyName, encryptionKey);\n\t\t\t}\n\n\t\t\t// Sort by epoch to ensure proper ordering\n\t\t\tencryptionKeys.sort((a, b) => a.epoch - b.epoch);\n\n\t\t\treturn encryptionKeys;\n\t\t} catch (error) {\n\t\t\tif (error instanceof InvalidObjectError || error instanceof ObjectNotFoundError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tthrow new NetworkError('Failed to fetch encryption keys', error as Error);\n\t\t}\n\t}\n\n\t/**\n\t * Read a table vector as raw bytes from the blockchain.\n\t * This method handles paginated dynamic field retrieval and assembles the data in order.\n\t *\n\t * @param tableID - The ID of the table object to read\n\t * @returns Promise resolving to the concatenated raw bytes from the table\n\t * @throws {ObjectNotFoundError} If the table or its dynamic fields are not found\n\t * @throws {InvalidObjectError} If table indices are invalid\n\t * @throws {NetworkError} If network requests fail\n\t * @private\n\t */\n\tasync readTableVecAsRawBytes(tableID: string): Promise<Uint8Array> {\n\t\ttry {\n\t\t\tlet cursor: string | null = null;\n\t\t\tconst allTableRows: { objectId: string }[] = [];\n\n\t\t\tdo {\n\t\t\t\tconst dynamicFieldPage = await this.client.getDynamicFields({\n\t\t\t\t\tparentId: tableID,\n\t\t\t\t\tcursor,\n\t\t\t\t});\n\n\t\t\t\tif (!dynamicFieldPage?.data?.length) {\n\t\t\t\t\tif (allTableRows.length === 0) {\n\t\t\t\t\t\tthrow new ObjectNotFoundError('Dynamic fields', tableID);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tallTableRows.push(...dynamicFieldPage.data);\n\t\t\t\tcursor = dynamicFieldPage.nextCursor;\n\n\t\t\t\tif (!dynamicFieldPage.hasNextPage) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (cursor);\n\n\t\t\tconst dataMap = new Map<number, Uint8Array>();\n\n\t\t\tconst objectIds = new Set(allTableRows.map((tableRowResult) => tableRowResult.objectId));\n\n\t\t\tawait this.#processBatchedObjects([...objectIds], ({ objectId, fields }) => {\n\t\t\t\tconst tableIndex = parseInt(fields.name);\n\n\t\t\t\tif (isNaN(tableIndex)) {\n\t\t\t\t\tthrow new InvalidObjectError('Table index (expected numeric name)', objectId);\n\t\t\t\t}\n\n\t\t\t\tdataMap.set(tableIndex, fields.value);\n\t\t\t});\n\n\t\t\tconst indices = Array.from(dataMap.keys()).sort((a, b) => a - b);\n\n\t\t\tif (indices.length === 0) {\n\t\t\t\tthrow new ObjectNotFoundError('No table chunks found', tableID);\n\t\t\t}\n\n\t\t\tconst orderedChunks: Uint8Array[] = indices\n\t\t\t\t.map((idx) => dataMap.get(idx)!)\n\t\t\t\t.filter((chunk): chunk is Uint8Array => !!chunk);\n\n\t\t\tconst totalLength = orderedChunks.reduce((acc, arr) => acc + arr.length, 0);\n\t\t\tconst result = new Uint8Array(totalLength);\n\t\t\tlet offset = 0;\n\n\t\t\tfor (const chunk of orderedChunks) {\n\t\t\t\tresult.set(chunk, offset);\n\t\t\t\toffset += chunk.length;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tif (\n\t\t\t\terror instanceof InvalidObjectError ||\n\t\t\t\terror instanceof ObjectNotFoundError ||\n\t\t\t\terror instanceof NetworkError\n\t\t\t) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`Failed to read table vector as raw bytes: ${tableID}`,\n\t\t\t\terror as Error,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Process multiple objects in batches to avoid overwhelming the network.\n\t * This method fetches objects in configurable batch sizes and applies a processor function to each.\n\t *\n\t * @param objectIds - Array of object IDs to fetch and process\n\t * @param processor - Function to apply to each fetched object\n\t * @returns Promise that resolves when all objects are processed\n\t * @throws {NetworkError} If any network request fails or object fetching fails\n\t * @throws {InvalidObjectError} If any object processing fails\n\t * @private\n\t */\n\tasync #processBatchedObjects<TReturn = void>(\n\t\tobjectIds: string[],\n\t\tprocessor: (input: {\n\t\t\tobjectId: string;\n\t\t\tfields: { name: string; value: Uint8Array };\n\t\t}) => TReturn,\n\t): Promise<TReturn[]> {\n\t\tconst batchSize = 50;\n\n\t\ttry {\n\t\t\tconst results: TReturn[] = [];\n\t\t\tfor (let i = 0; i < objectIds.length; i += batchSize) {\n\t\t\t\tconst batchIds = objectIds.slice(i, i + batchSize);\n\n\t\t\t\tconst dynFields = await this.client.multiGetObjects({\n\t\t\t\t\tids: batchIds,\n\t\t\t\t\toptions: { showContent: true },\n\t\t\t\t});\n\n\t\t\t\tfor (const dynField of dynFields) {\n\t\t\t\t\tif (dynField.error) {\n\t\t\t\t\t\tconst errorInfo =\n\t\t\t\t\t\t\t'object_id' in dynField.error\n\t\t\t\t\t\t\t\t? `object ${dynField.error.object_id}`\n\t\t\t\t\t\t\t\t: 'unknown object';\n\t\t\t\t\t\tthrow new NetworkError(`Failed to fetch ${errorInfo}: ${dynField.error.code}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst objectIdForError = dynField.data?.objectId;\n\t\t\t\t\tconst content = dynField.data?.content;\n\t\t\t\t\tif (!content || content.dataType !== 'moveObject') {\n\t\t\t\t\t\tthrow new InvalidObjectError('Object content (expected moveObject)', objectIdForError);\n\t\t\t\t\t}\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\t\tconst fields = (content as any).fields as { name?: unknown; value?: unknown } | undefined;\n\t\t\t\t\tif (!fields) {\n\t\t\t\t\t\tthrow new InvalidObjectError('Object content.fields missing', objectIdForError);\n\t\t\t\t\t}\n\t\t\t\t\tconst name = typeof fields.name === 'string' ? fields.name : String(fields.name);\n\t\t\t\t\tconst value =\n\t\t\t\t\t\tfields.value instanceof Uint8Array\n\t\t\t\t\t\t\t? fields.value\n\t\t\t\t\t\t\t: new Uint8Array(fields.value as ArrayLike<number>);\n\n\t\t\t\t\tresults.push(\n\t\t\t\t\t\tprocessor({\n\t\t\t\t\t\t\tobjectId: objectIdForError ?? 'unknown',\n\t\t\t\t\t\t\tfields: { name, value },\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn results;\n\t\t} catch (error) {\n\t\t\tif (error instanceof NetworkError || error instanceof InvalidObjectError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new NetworkError('Failed to process batched objects', error as Error);\n\t\t}\n\t}\n\n\t/**\n\t * Generate a cache key for protocol public parameters based on encryption key ID and curve.\n\t *\n\t * @param encryptionKeyID - The encryption key ID\n\t * @param curve - The curve\n\t * @returns A unique cache key string\n\t * @private\n\t */\n\t#getCacheKey(encryptionKeyID: string, curve: Curve): string {\n\t\treturn `${encryptionKeyID}-${curve}`;\n\t}\n\n\t#getDWalletKind(dWallet: DWalletInternal): DWalletKind {\n\t\tif (dWallet.is_imported_key_dwallet && dWallet.public_user_secret_key_share) {\n\t\t\treturn 'imported-key-shared';\n\t\t}\n\n\t\tif (dWallet.is_imported_key_dwallet) {\n\t\t\treturn 'imported-key';\n\t\t}\n\n\t\tif (dWallet.public_user_secret_key_share) {\n\t\t\treturn 'shared';\n\t\t}\n\n\t\treturn 'zero-trust';\n\t}\n\n\t/**\n\t * Generic polling method that waits for an object to meet a specific condition.\n\t * Implements exponential backoff and abort signal support.\n\t *\n\t * @param fetcher - Function that fetches the object\n\t * @param condition - Function that checks if the object meets the desired condition\n\t * @param errorContext - Context string for error messages (e.g., \"DWallet X to reach state Y\")\n\t * @param options - Optional configuration for polling behavior\n\t * @returns Promise resolving to the object when the condition is met\n\t * @throws {Error} If timeout is reached before condition is met or operation is aborted\n\t * @private\n\t */\n\tasync #pollUntilCondition<T>(\n\t\tfetcher: () => Promise<T>,\n\t\tcondition: (obj: T) => boolean,\n\t\terrorContext: string,\n\t\toptions: {\n\t\t\ttimeout?: number;\n\t\t\tinterval?: number;\n\t\t\tmaxInterval?: number;\n\t\t\tbackoffMultiplier?: number;\n\t\t\tsignal?: AbortSignal;\n\t\t} = {},\n\t): Promise<T> {\n\t\tawait this.ensureInitialized();\n\n\t\tconst {\n\t\t\ttimeout = 30000,\n\t\t\tinterval = 1000,\n\t\t\tmaxInterval = 5000,\n\t\t\tbackoffMultiplier = 1.5,\n\t\t\tsignal,\n\t\t} = options;\n\n\t\tif (signal?.aborted) {\n\t\t\tthrow new Error('Operation aborted');\n\t\t}\n\n\t\tconst startTime = Date.now();\n\t\tlet currentInterval = interval;\n\t\tlet lastError: Error | undefined;\n\n\t\twhile (Date.now() - startTime < timeout) {\n\t\t\tif (signal?.aborted) {\n\t\t\t\tthrow new Error('Operation aborted');\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst obj = await fetcher();\n\n\t\t\t\tif (condition(obj)) {\n\t\t\t\t\treturn obj;\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlastError = error as Error;\n\t\t\t}\n\n\t\t\tconst waitTime = currentInterval;\n\t\t\tawait new Promise((resolve, reject) => {\n\t\t\t\tconst timeoutId = setTimeout(resolve, waitTime);\n\t\t\t\tsignal?.addEventListener('abort', () => {\n\t\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\t\treject(new Error('Operation aborted'));\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tcurrentInterval = Math.min(currentInterval * backoffMultiplier, maxInterval);\n\t\t}\n\n\t\tconst errorMessage = lastError\n\t\t\t? `Timeout waiting for ${errorContext}. Last error: ${lastError.message}`\n\t\t\t: `Timeout waiting for ${errorContext}`;\n\n\t\tthrow new Error(errorMessage);\n\t}\n\n\t/**\n\t * Specialized polling method that waits for an object to reach a specific state.\n\t * This is a convenience wrapper around #pollUntilCondition for the common case of checking state.$kind.\n\t *\n\t * @param fetcher - Function that fetches the object\n\t * @param state - The state to wait for (compared with obj.state.$kind)\n\t * @param errorContext - Context string for error messages (e.g., \"DWallet X to reach state Y\")\n\t * @param options - Optional configuration for polling behavior\n\t * @returns Promise resolving to the object when it reaches the desired state\n\t * @throws {Error} If timeout is reached before state is achieved or operation is aborted\n\t * @private\n\t */\n\tasync #pollUntilState<T extends { state: { $kind: string } }>(\n\t\tfetcher: () => Promise<T>,\n\t\tstate: string,\n\t\terrorContext: string,\n\t\toptions: {\n\t\t\ttimeout?: number;\n\t\t\tinterval?: number;\n\t\t\tmaxInterval?: number;\n\t\t\tbackoffMultiplier?: number;\n\t\t\tsignal?: AbortSignal;\n\t\t} = {},\n\t): Promise<T> {\n\t\treturn this.#pollUntilCondition(\n\t\t\tfetcher,\n\t\t\t(obj) => obj.state.$kind === state,\n\t\t\terrorContext,\n\t\t\toptions,\n\t\t);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["import_utils", "getActiveEncryptionKeyFromCoordinator"]
}
