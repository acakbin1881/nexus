"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var cryptography_exports = {};
__export(cryptography_exports, {
  createClassGroupsKeypair: () => createClassGroupsKeypair,
  createDKGUserOutput: () => createDKGUserOutput,
  createRandomSessionIdentifier: () => createRandomSessionIdentifier,
  createUserSignMessageWithCentralizedOutput: () => createUserSignMessageWithCentralizedOutput,
  createUserSignMessageWithPublicOutput: () => createUserSignMessageWithPublicOutput,
  encryptSecretShare: () => encryptSecretShare,
  networkDkgPublicOutputToProtocolPublicParameters: () => networkDkgPublicOutputToProtocolPublicParameters,
  parseSignatureFromSignOutput: () => parseSignatureFromSignOutput,
  prepareDKG: () => prepareDKG,
  prepareDKGAsync: () => prepareDKGAsync,
  prepareDKGSecondRound: () => prepareDKGSecondRound,
  prepareDKGSecondRoundAsync: () => prepareDKGSecondRoundAsync,
  prepareImportedKeyDWalletVerification: () => prepareImportedKeyDWalletVerification,
  publicKeyFromCentralizedDKGOutput: () => publicKeyFromCentralizedDKGOutput,
  publicKeyFromDWalletOutput: () => publicKeyFromDWalletOutput,
  reconfigurationPublicOutputToProtocolPublicParameters: () => reconfigurationPublicOutputToProtocolPublicParameters,
  sessionIdentifierDigest: () => sessionIdentifierDigest,
  userAndNetworkDKGOutputMatch: () => userAndNetworkDKGOutputMatch,
  verifyAndGetDWalletDKGPublicOutput: () => verifyAndGetDWalletDKGPublicOutput,
  verifySecpSignature: () => verifySecpSignature,
  verifyUserShare: () => verifyUserShare
});
module.exports = __toCommonJS(cryptography_exports);
var import_bcs = require("@mysten/sui/bcs");
var import_cryptography = require("@mysten/sui/cryptography");
var import_sha3 = require("@noble/hashes/sha3");
var import_utils = require("@noble/hashes/utils.js");
var import_hash_signature_validation = require("./hash-signature-validation.js");
var import_types = require("./types.js");
var import_utils2 = require("./utils.js");
var import_wasm_loader = require("./wasm-loader.js");
async function createClassGroupsKeypair(seed, curve) {
  if (seed.length !== 32) {
    throw new Error("Seed must be 32 bytes");
  }
  let encryptionKey;
  let decryptionKey;
  if (curve === import_types.Curve.SECP256K1 || curve === import_types.Curve.SECP256R1 || curve === import_types.Curve.RISTRETTO || curve === import_types.Curve.ED25519) {
    [encryptionKey, decryptionKey] = await (0, import_wasm_loader.generate_secp_cg_keypair_from_seed)(
      (0, import_hash_signature_validation.fromCurveToNumber)(curve),
      seed
    );
  } else {
    throw new Error(
      "Only SECP256K1, SECP256R1, RISTRETTO, and ED25519 curves are supported for now"
    );
  }
  return {
    encryptionKey: Uint8Array.from(encryptionKey),
    decryptionKey: Uint8Array.from(decryptionKey)
  };
}
async function createDKGUserOutput(protocolPublicParameters, networkFirstRoundOutput) {
  const [userDKGMessage, userPublicOutput, userSecretKeyShare] = await (0, import_wasm_loader.create_dkg_centralized_output_v1)(
    protocolPublicParameters,
    Uint8Array.from(networkFirstRoundOutput)
  );
  return {
    userDKGMessage: Uint8Array.from(userDKGMessage),
    userPublicOutput: Uint8Array.from(userPublicOutput),
    userSecretKeyShare: Uint8Array.from(userSecretKeyShare)
  };
}
async function encryptSecretShare(curve, userSecretKeyShare, encryptionKey, protocolPublicParameters) {
  const encryptedUserShareAndProof = await (0, import_wasm_loader.encrypt_secret_share)(
    (0, import_hash_signature_validation.fromCurveToNumber)(curve),
    userSecretKeyShare,
    encryptionKey,
    protocolPublicParameters
  );
  return Uint8Array.from(encryptedUserShareAndProof);
}
async function prepareDKGSecondRound(_protocolPublicParameters, _dWallet, _encryptionKey) {
  throw new Error("prepareDKGSecondRound is deprecated. Use prepareDKG instead");
}
async function prepareDKG(protocolPublicParameters, curve, encryptionKey, bytesToHash, senderAddress) {
  const senderAddressBytes = import_bcs.bcs.Address.serialize(senderAddress).toBytes();
  const [userDKGMessage, userPublicOutput, userSecretKeyShare] = await (0, import_wasm_loader.create_dkg_centralized_output_v2)(
    (0, import_hash_signature_validation.fromCurveToNumber)(curve),
    protocolPublicParameters,
    sessionIdentifierDigest(bytesToHash, senderAddressBytes)
  );
  const encryptedUserShareAndProof = await encryptSecretShare(
    curve,
    userSecretKeyShare,
    encryptionKey,
    protocolPublicParameters
  );
  return {
    userDKGMessage: Uint8Array.from(userDKGMessage),
    userPublicOutput: Uint8Array.from(userPublicOutput),
    encryptedUserShareAndProof: Uint8Array.from(encryptedUserShareAndProof),
    userSecretKeyShare: Uint8Array.from(userSecretKeyShare)
  };
}
async function prepareDKGSecondRoundAsync(_ikaClient, _dWallet, _userShareEncryptionKeys) {
  throw new Error("prepareDKGSecondRoundAsync is deprecated. Use prepareDKGAsync instead");
}
async function prepareDKGAsync(ikaClient, curve, userShareEncryptionKeys, bytesToHash, senderAddress) {
  const protocolPublicParameters = await ikaClient.getProtocolPublicParameters(void 0, curve);
  return prepareDKG(
    protocolPublicParameters,
    curve,
    userShareEncryptionKeys.encryptionKey,
    bytesToHash,
    senderAddress
  );
}
async function prepareImportedKeyDWalletVerification(ikaClient, curve, bytesToHash, senderAddress, userShareEncryptionKeys, privateKey) {
  const senderAddressBytes = import_bcs.bcs.Address.serialize(senderAddress).toBytes();
  const protocolPublicParameters = await ikaClient.getProtocolPublicParameters(void 0, curve);
  const [userSecretShare, userPublicOutput, userMessage] = await (0, import_wasm_loader.create_imported_dwallet_centralized_step)(
    (0, import_hash_signature_validation.fromCurveToNumber)(curve),
    protocolPublicParameters,
    sessionIdentifierDigest(bytesToHash, senderAddressBytes),
    privateKey
  );
  const encryptedUserShareAndProof = await encryptSecretShare(
    curve,
    userSecretShare,
    userShareEncryptionKeys.encryptionKey,
    protocolPublicParameters
  );
  return {
    userPublicOutput: Uint8Array.from(userPublicOutput),
    userMessage: Uint8Array.from(userMessage),
    encryptedUserShareAndProof: Uint8Array.from(encryptedUserShareAndProof)
  };
}
async function createUserSignMessageWithPublicOutput(protocolPublicParameters, publicOutput, userSecretKeyShare, presign, message, hash, signatureAlgorithm, curve) {
  const { signatureAlgorithmNumber, hashNumber, curveNumber } = (0, import_hash_signature_validation.fromCurveAndSignatureAlgorithmAndHashToNumbers)(curve, signatureAlgorithm, hash);
  return Uint8Array.from(
    await (0, import_wasm_loader.create_sign_centralized_party_message)(
      protocolPublicParameters,
      publicOutput,
      userSecretKeyShare,
      presign,
      message,
      hashNumber,
      signatureAlgorithmNumber,
      curveNumber
    )
  );
}
async function createUserSignMessageWithCentralizedOutput(protocolPublicParameters, centralizedDkgOutput, userSecretKeyShare, presign, message, hash, signatureAlgorithm, curve) {
  const { signatureAlgorithmNumber, hashNumber, curveNumber } = (0, import_hash_signature_validation.fromCurveAndSignatureAlgorithmAndHashToNumbers)(curve, signatureAlgorithm, hash);
  return Uint8Array.from(
    await (0, import_wasm_loader.create_sign_centralized_party_message_with_centralized_party_dkg_output)(
      protocolPublicParameters,
      centralizedDkgOutput,
      userSecretKeyShare,
      presign,
      message,
      hashNumber,
      signatureAlgorithmNumber,
      curveNumber
    )
  );
}
async function networkDkgPublicOutputToProtocolPublicParameters(curve, network_dkg_public_output) {
  return Uint8Array.from(
    await (0, import_wasm_loader.network_dkg_public_output_to_protocol_pp)(
      (0, import_hash_signature_validation.fromCurveToNumber)(curve),
      network_dkg_public_output
    )
  );
}
async function reconfigurationPublicOutputToProtocolPublicParameters(curve, reconfiguration_public_output, network_dkg_public_output) {
  return Uint8Array.from(
    await (0, import_wasm_loader.reconfiguration_public_output_to_protocol_pp)(
      (0, import_hash_signature_validation.fromCurveToNumber)(curve),
      reconfiguration_public_output,
      network_dkg_public_output
    )
  );
}
async function verifyUserShare(curve, userSecretKeyShare, userDKGOutput, networkDkgPublicOutput) {
  return await (0, import_wasm_loader.verify_user_share)(
    (0, import_hash_signature_validation.fromCurveToNumber)(curve),
    userSecretKeyShare,
    userDKGOutput,
    networkDkgPublicOutput
  );
}
async function verifySecpSignature(publicKey, signature, message, networkDkgPublicOutput, hash, signatureAlgorithm, curve) {
  const { signatureAlgorithmNumber, hashNumber, curveNumber } = (0, import_hash_signature_validation.fromCurveAndSignatureAlgorithmAndHashToNumbers)(curve, signatureAlgorithm, hash);
  return await (0, import_wasm_loader.verify_secp_signature)(
    publicKey,
    signature,
    message,
    networkDkgPublicOutput,
    hashNumber,
    signatureAlgorithmNumber,
    curveNumber
  );
}
async function publicKeyFromDWalletOutput(curve, dWalletOutput) {
  return Uint8Array.from(
    await (0, import_wasm_loader.public_key_from_dwallet_output)((0, import_hash_signature_validation.fromCurveToNumber)(curve), dWalletOutput)
  );
}
async function publicKeyFromCentralizedDKGOutput(curve, centralizedDkgOutput) {
  return Uint8Array.from(
    await (0, import_wasm_loader.public_key_from_centralized_dkg_output)((0, import_hash_signature_validation.fromCurveToNumber)(curve), centralizedDkgOutput)
  );
}
async function verifyAndGetDWalletDKGPublicOutput(dWallet, encryptedUserSecretKeyShare, publicKey) {
  if (import_cryptography.SIGNATURE_FLAG_TO_SCHEME[publicKey.flag()] !== "ED25519") {
    throw new Error("Only ED25519 public keys are supported.");
  }
  if (!dWallet.state.Active?.public_output) {
    throw new Error("DWallet is not in active state");
  }
  if (!encryptedUserSecretKeyShare.state.KeyHolderSigned?.user_output_signature) {
    throw new Error("User output signature is undefined");
  }
  const userPublicOutput = Uint8Array.from(dWallet.state.Active.public_output);
  const userOutputSignature = Uint8Array.from(
    encryptedUserSecretKeyShare.state.KeyHolderSigned?.user_output_signature
  );
  if (!await publicKey.verify(userPublicOutput, userOutputSignature)) {
    throw new Error("Invalid signature");
  }
  if (publicKey.toSuiAddress() !== encryptedUserSecretKeyShare.encryption_key_address) {
    throw new Error(
      "Invalid Sui address. The encryption key address does not match the signing keypair address."
    );
  }
  return Uint8Array.from(dWallet.state.Active.public_output);
}
async function userAndNetworkDKGOutputMatch(curve, userPublicOutput, networkDKGOutput) {
  return await (0, import_wasm_loader.centralized_and_decentralized_parties_dkg_output_match)(
    (0, import_hash_signature_validation.fromCurveToNumber)(curve),
    userPublicOutput,
    networkDKGOutput
  );
}
async function parseSignatureFromSignOutput(curve, signatureAlgorithm, signatureOutput) {
  return Uint8Array.from(
    await (0, import_wasm_loader.parse_signature_from_sign_output)(
      (0, import_hash_signature_validation.fromCurveToNumber)(curve),
      (0, import_hash_signature_validation.fromSignatureAlgorithmToNumber)(curve, signatureAlgorithm),
      signatureOutput
    )
  );
}
function sessionIdentifierDigest(bytesToHash, senderAddressBytes) {
  const preimage = (0, import_sha3.keccak_256)(Uint8Array.from([...senderAddressBytes, ...bytesToHash]));
  const version = 0;
  const data = Uint8Array.from([
    ...(0, import_utils2.u64ToBytesBigEndian)(version),
    ...(0, import_utils2.encodeToASCII)("USER"),
    ...preimage
  ]);
  const digest = (0, import_sha3.keccak_256)(data);
  return Uint8Array.from(digest);
}
function createRandomSessionIdentifier() {
  return Uint8Array.from((0, import_utils.randomBytes)(32));
}
//# sourceMappingURL=cryptography.js.map
