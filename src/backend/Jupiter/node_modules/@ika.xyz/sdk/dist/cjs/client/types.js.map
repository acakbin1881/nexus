{
  "version": 3,
  "sources": ["../../../src/client/types.ts"],
  "sourcesContent": ["// Copyright (c) dWallet Labs, Ltd.\n// SPDX-License-Identifier: BSD-3-Clause-Clear\n\nimport type { BcsType } from '@mysten/sui/bcs';\nimport { bcs, BcsStruct } from '@mysten/sui/bcs';\nimport type { SuiClient } from '@mysten/sui/client';\n\nimport * as CoordinatorInnerModule from '../generated/ika_dwallet_2pc_mpc/coordinator_inner.js';\nimport * as SystemInnerModule from '../generated/ika_system/system_inner.js';\n\nexport interface IkaPackageConfig {\n\tikaPackage: string;\n\tikaCommonPackage: string;\n\tikaSystemOriginalPackage: string;\n\tikaDwallet2pcMpcOriginalPackage: string;\n\tikaDwallet2pcMpcPackage: string;\n\tikaSystemPackage: string;\n}\n\nexport interface IkaObjectsConfig {\n\tikaSystemObject: {\n\t\tobjectID: string;\n\t\tinitialSharedVersion: number;\n\t};\n\tikaDWalletCoordinator: {\n\t\tobjectID: string;\n\t\tinitialSharedVersion: number;\n\t};\n}\n\nexport interface IkaConfig {\n\tpackages: IkaPackageConfig;\n\tobjects: IkaObjectsConfig;\n}\n\nexport type Network = 'testnet' | 'mainnet';\n\n/**\n * Represents a network encryption key with its metadata\n */\nexport interface NetworkEncryptionKey {\n\t/** The unique identifier of the encryption key */\n\tid: string;\n\t/** The epoch when this encryption key was created */\n\tepoch: number;\n\t/** The public output ID for this encryption key */\n\tnetworkDKGOutputID: string;\n\t/** The reconfiguration output ID associated with this encryption key */\n\treconfigurationOutputID: string | undefined;\n}\n\n/**\n * Options for encryption key selection in protocol public parameters\n */\nexport interface EncryptionKeyOptions {\n\t/** Specific encryption key ID to use */\n\tencryptionKeyID?: string;\n\t/** Whether to automatically detect the encryption key from the dWallet */\n\tautoDetect?: boolean;\n}\n\nexport interface IkaClientOptions {\n\tconfig: IkaConfig;\n\tsuiClient: SuiClient;\n\ttimeout?: number;\n\tprotocolPublicParameters?: {\n\t\tnetworkEncryptionKeyPublicOutputID: string;\n\t\tepoch: number;\n\t\tprotocolPublicParameters: Uint8Array;\n\t};\n\tcache?: boolean;\n\t/** Default encryption key options for the client */\n\tencryptionKeyOptions?: EncryptionKeyOptions;\n}\n\nexport type CoordinatorInner = typeof CoordinatorInnerModule.DWalletCoordinatorInner.$inferType;\nexport type SystemInner = typeof SystemInnerModule.SystemInner.$inferType;\n\nexport const DWalletKind = {\n\tZeroTrust: 'zero-trust',\n\tImportedKey: 'imported-key',\n\tImportedKeyShared: 'imported-key-shared',\n\tShared: 'shared',\n} as const;\n\nexport type DWalletKind = (typeof DWalletKind)[keyof typeof DWalletKind];\n\nexport type DWalletInternal = typeof CoordinatorInnerModule.DWallet.$inferType;\n\nexport type ZeroTrustDWallet = DWalletInternal & {\n\tkind: 'zero-trust';\n};\n\nexport type ImportedKeyDWallet = DWalletInternal & {\n\tkind: 'imported-key';\n};\n\nexport type ImportedSharedDWallet = DWalletInternal & {\n\tkind: 'imported-key-shared';\n};\n\nexport type SharedDWallet = DWalletInternal & {\n\tkind: 'shared';\n};\n\nexport type DWallet = ZeroTrustDWallet | ImportedKeyDWallet | ImportedSharedDWallet | SharedDWallet;\n\nexport type DWalletCap = typeof CoordinatorInnerModule.DWalletCap.$inferType;\nexport type Presign = typeof CoordinatorInnerModule.PresignSession.$inferType;\nexport type EncryptedUserSecretKeyShare =\n\ttypeof CoordinatorInnerModule.EncryptedUserSecretKeyShare.$inferType;\nexport type PartialUserSignature = typeof CoordinatorInnerModule.PartialUserSignature.$inferType;\nexport type Sign = typeof CoordinatorInnerModule.SignSession.$inferType;\nexport type EncryptionKey = typeof CoordinatorInnerModule.EncryptionKey.$inferType;\nexport type DWalletState = typeof CoordinatorInnerModule.DWalletState.$inferType.$kind;\nexport type PresignState = typeof CoordinatorInnerModule.PresignState.$inferType.$kind;\nexport type PartialUserSignatureState =\n\ttypeof CoordinatorInnerModule.PartialUserSignatureState.$inferType.$kind;\nexport type EncryptedUserSecretKeyShareState =\n\ttypeof CoordinatorInnerModule.EncryptedUserSecretKeyShareState.$inferType.$kind;\nexport type SignState = typeof CoordinatorInnerModule.SignState.$inferType.$kind;\n\n/**\n * Type utilities to narrow specific state types.\n * These allow for type-safe access to state-specific properties.\n */\n\n/** Narrow DWallet to a specific state */\nexport type DWalletWithState<S extends DWalletState> = Omit<DWalletInternal, 'state' | 'kind'> & {\n\tstate: Extract<typeof CoordinatorInnerModule.DWalletState.$inferType, { $kind: S }>;\n\tkind: DWalletKind;\n};\n\n/** Narrow Presign to a specific state */\nexport type PresignWithState<S extends PresignState> = Omit<Presign, 'state'> & {\n\tstate: Extract<typeof CoordinatorInnerModule.PresignState.$inferType, { $kind: S }>;\n};\n\n/** Narrow EncryptedUserSecretKeyShare to a specific state */\nexport type EncryptedUserSecretKeyShareWithState<S extends EncryptedUserSecretKeyShareState> = Omit<\n\tEncryptedUserSecretKeyShare,\n\t'state'\n> & {\n\tstate: Extract<\n\t\ttypeof CoordinatorInnerModule.EncryptedUserSecretKeyShareState.$inferType,\n\t\t{ $kind: S }\n\t>;\n};\n\n/** Narrow PartialUserSignature to a specific state */\nexport type PartialUserSignatureWithState<S extends PartialUserSignatureState> = Omit<\n\tPartialUserSignature,\n\t'state'\n> & {\n\tstate: Extract<typeof CoordinatorInnerModule.PartialUserSignatureState.$inferType, { $kind: S }>;\n};\n\n/** Narrow Sign to a specific state */\nexport type SignWithState<S extends SignState> = Omit<Sign, 'state'> & {\n\tstate: Extract<typeof CoordinatorInnerModule.SignState.$inferType, { $kind: S }>;\n};\n\n/**\n * Hash algorithms supported by the Ika network.\n *\n * **Valid Combinations:**\n * - `KECCAK256`, `SHA256`, `DoubleSHA256`: Compatible with ECDSASecp256k1\n * - `SHA256`: Compatible with Taproot\n * - `SHA256`, `DoubleSHA256`: Compatible with ECDSASecp256r1\n * - `SHA512`: Compatible with EdDSA\n * - `Merlin`: Compatible with SchnorrkelSubstrate\n */\nexport const Hash = {\n\t/** KECCAK256 (SHA3) - Compatible with: ECDSASecp256k1 */\n\tKECCAK256: 'KECCAK256',\n\t/** SHA256 - Compatible with: ECDSASecp256k1, Taproot, ECDSASecp256r1 */\n\tSHA256: 'SHA256',\n\t/** Double SHA256: h(x) = sha256(sha256(x)) - Compatible with: ECDSASecp256k1, ECDSASecp256r1 */\n\tDoubleSHA256: 'DoubleSHA256',\n\t/** SHA512 - Compatible with: EdDSA only */\n\tSHA512: 'SHA512',\n\t/** Merlin (STROBE-based transcript construction) - Compatible with: SchnorrkelSubstrate only */\n\tMerlin: 'Merlin',\n} as const;\n\nexport type Hash = (typeof Hash)[keyof typeof Hash];\n\n/**\n * Elliptic curves supported by the Ika network.\n * Each curve is associated with specific signature algorithms.\n */\nexport const Curve = {\n\t/** secp256k1 - Used by: ECDSASecp256k1, Taproot */\n\tSECP256K1: 'SECP256K1',\n\t/** Ristretto - Used by: SchnorrkelSubstrate */\n\tRISTRETTO: 'RISTRETTO',\n\t/** Ed25519 - Used by: EdDSA */\n\tED25519: 'ED25519',\n\t/** secp256r1 (P-256) - Used by: ECDSASecp256r1 */\n\tSECP256R1: 'SECP256R1',\n} as const;\n\nexport type Curve = (typeof Curve)[keyof typeof Curve];\n\n/**\n * Signature algorithms supported by the Ika network.\n *\n * **Valid Hash Combinations:**\n * - `ECDSASecp256k1`: KECCAK256, SHA256, DoubleSHA256\n * - `Taproot`: SHA256 only\n * - `ECDSASecp256r1`: SHA256, DoubleSHA256\n * - `EdDSA`: SHA512 only\n * - `SchnorrkelSubstrate`: Merlin only\n */\nexport const SignatureAlgorithm = {\n\t/** ECDSA with secp256k1 curve - Valid hashes: KECCAK256, SHA256, DoubleSHA256 */\n\tECDSASecp256k1: 'ECDSASecp256k1',\n\t/** Taproot (Bitcoin) - Valid hash: SHA256 only */\n\tTaproot: 'Taproot',\n\t/** ECDSA with secp256r1 (P-256) curve - Valid hashes: SHA256, DoubleSHA256 */\n\tECDSASecp256r1: 'ECDSASecp256r1',\n\t/** EdDSA (Ed25519) - Valid hash: SHA512 only */\n\tEdDSA: 'EdDSA',\n\t/** Schnorrkel/Ristretto (Substrate) - Valid hash: Merlin only */\n\tSchnorrkelSubstrate: 'SchnorrkelSubstrate',\n} as const;\n\nexport type SignatureAlgorithm = (typeof SignatureAlgorithm)[keyof typeof SignatureAlgorithm];\n\nexport interface SharedObjectOwner {\n\tShared: {\n\t\tinitial_shared_version: number;\n\t};\n}\n\nexport function DynamicField<E extends BcsType<any>>(...typeParameters: [E]) {\n\treturn new BcsStruct({\n\t\tname: `dynamic_field::Field<u64, ${typeParameters[0].name as E['name']}>`,\n\t\tfields: {\n\t\t\tid: bcs.Address,\n\t\t\tname: bcs.u64(),\n\t\t\tvalue: typeParameters[0],\n\t\t},\n\t});\n}\n\nexport const CoordinatorInnerDynamicField = DynamicField(\n\tCoordinatorInnerModule.DWalletCoordinatorInner,\n);\n\nexport const SystemInnerDynamicField = DynamicField(SystemInnerModule.SystemInner);\n\nexport type UserSignatureInputs = {\n\tactiveDWallet?: DWallet;\n\tpublicOutput?: Uint8Array;\n\tsecretShare?: Uint8Array;\n\tencryptedUserSecretKeyShare?: EncryptedUserSecretKeyShare;\n\tpresign: Presign;\n\tmessage: Uint8Array;\n\thash: Hash;\n\tsignatureScheme: SignatureAlgorithm;\n\tcurve: Curve;\n\tcreateWithCentralizedOutput?: boolean;\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,iBAA+B;AAG/B,6BAAwC;AACxC,wBAAmC;AAsE5B,MAAM,cAAc;AAAA,EAC1B,WAAW;AAAA,EACX,aAAa;AAAA,EACb,mBAAmB;AAAA,EACnB,QAAQ;AACT;AAyFO,MAAM,OAAO;AAAA;AAAA,EAEnB,WAAW;AAAA;AAAA,EAEX,QAAQ;AAAA;AAAA,EAER,cAAc;AAAA;AAAA,EAEd,QAAQ;AAAA;AAAA,EAER,QAAQ;AACT;AAQO,MAAM,QAAQ;AAAA;AAAA,EAEpB,WAAW;AAAA;AAAA,EAEX,WAAW;AAAA;AAAA,EAEX,SAAS;AAAA;AAAA,EAET,WAAW;AACZ;AAcO,MAAM,qBAAqB;AAAA;AAAA,EAEjC,gBAAgB;AAAA;AAAA,EAEhB,SAAS;AAAA;AAAA,EAET,gBAAgB;AAAA;AAAA,EAEhB,OAAO;AAAA;AAAA,EAEP,qBAAqB;AACtB;AAUO,SAAS,gBAAwC,gBAAqB;AAC5E,SAAO,IAAI,qBAAU;AAAA,IACpB,MAAM,6BAA6B,eAAe,CAAC,EAAE,IAAiB;AAAA,IACtE,QAAQ;AAAA,MACP,IAAI,eAAI;AAAA,MACR,MAAM,eAAI,IAAI;AAAA,MACd,OAAO,eAAe,CAAC;AAAA,IACxB;AAAA,EACD,CAAC;AACF;AAEO,MAAM,+BAA+B;AAAA,EAC3C,uBAAuB;AACxB;AAEO,MAAM,0BAA0B,aAAa,kBAAkB,WAAW;",
  "names": []
}
