{
  "version": 3,
  "sources": ["../../../../src/generated/ika_common/extended_field.ts"],
  "sourcesContent": ["/**************************************************************\n * THIS FILE IS GENERATED AND SHOULD NOT BE MANUALLY MODIFIED *\n **************************************************************/\nimport { MoveStruct, MoveTuple, normalizeMoveArguments, type RawTransactionArgument } from '../utils/index.js';\nimport { bcs, type BcsType } from '@mysten/sui/bcs';\nimport { type Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/common::extended_field';\nexport const ExtendedField = new MoveStruct({ name: `${$moduleName}::ExtendedField`, fields: {\n        id: object.UID\n    } });\nexport const Key = new MoveTuple({ name: `${$moduleName}::Key`, fields: [bcs.bool()] });\nexport interface NewArguments<T extends BcsType<any>> {\n    value: RawTransactionArgument<T>;\n}\nexport interface NewOptions<T extends BcsType<any>> {\n    package?: string;\n    arguments: NewArguments<T> | [\n        value: RawTransactionArgument<T>\n    ];\n    typeArguments: [\n        string\n    ];\n}\n/** Creates a new extended field with the given value. */\nexport function _new<T extends BcsType<any>>(options: NewOptions<T>) {\n    const packageAddress = options.package ?? '@local-pkg/common';\n    const argumentsTypes = [\n        `${options.typeArguments[0]}`\n    ] satisfies string[];\n    const parameterNames = [\"value\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'extended_field',\n        function: 'new',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n        typeArguments: options.typeArguments\n    });\n}\nexport interface BorrowArguments {\n    field: RawTransactionArgument<string>;\n}\nexport interface BorrowOptions {\n    package?: string;\n    arguments: BorrowArguments | [\n        field: RawTransactionArgument<string>\n    ];\n    typeArguments: [\n        string\n    ];\n}\n/** Borrows the value stored in the extended field. */\nexport function borrow(options: BorrowOptions) {\n    const packageAddress = options.package ?? '@local-pkg/common';\n    const argumentsTypes = [\n        `${packageAddress}::extended_field::ExtendedField<${options.typeArguments[0]}>`\n    ] satisfies string[];\n    const parameterNames = [\"field\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'extended_field',\n        function: 'borrow',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n        typeArguments: options.typeArguments\n    });\n}\nexport interface BorrowMutArguments {\n    field: RawTransactionArgument<string>;\n}\nexport interface BorrowMutOptions {\n    package?: string;\n    arguments: BorrowMutArguments | [\n        field: RawTransactionArgument<string>\n    ];\n    typeArguments: [\n        string\n    ];\n}\n/** Borrows the value stored in the extended field mutably. */\nexport function borrowMut(options: BorrowMutOptions) {\n    const packageAddress = options.package ?? '@local-pkg/common';\n    const argumentsTypes = [\n        `${packageAddress}::extended_field::ExtendedField<${options.typeArguments[0]}>`\n    ] satisfies string[];\n    const parameterNames = [\"field\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'extended_field',\n        function: 'borrow_mut',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n        typeArguments: options.typeArguments\n    });\n}\nexport interface SwapArguments<T extends BcsType<any>> {\n    field: RawTransactionArgument<string>;\n    value: RawTransactionArgument<T>;\n}\nexport interface SwapOptions<T extends BcsType<any>> {\n    package?: string;\n    arguments: SwapArguments<T> | [\n        field: RawTransactionArgument<string>,\n        value: RawTransactionArgument<T>\n    ];\n    typeArguments: [\n        string\n    ];\n}\n/** Swaps the value stored in the extended field with the given value. */\nexport function swap<T extends BcsType<any>>(options: SwapOptions<T>) {\n    const packageAddress = options.package ?? '@local-pkg/common';\n    const argumentsTypes = [\n        `${packageAddress}::extended_field::ExtendedField<${options.typeArguments[0]}>`,\n        `${options.typeArguments[0]}`\n    ] satisfies string[];\n    const parameterNames = [\"field\", \"value\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'extended_field',\n        function: 'swap',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n        typeArguments: options.typeArguments\n    });\n}\nexport interface DestroyArguments {\n    field: RawTransactionArgument<string>;\n}\nexport interface DestroyOptions {\n    package?: string;\n    arguments: DestroyArguments | [\n        field: RawTransactionArgument<string>\n    ];\n    typeArguments: [\n        string\n    ];\n}\n/** Destroys the extended field and returns the value stored in it. */\nexport function destroy(options: DestroyOptions) {\n    const packageAddress = options.package ?? '@local-pkg/common';\n    const argumentsTypes = [\n        `${packageAddress}::extended_field::ExtendedField<${options.typeArguments[0]}>`\n    ] satisfies string[];\n    const parameterNames = [\"field\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'extended_field',\n        function: 'destroy',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n        typeArguments: options.typeArguments\n    });\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,mBAA2F;AAC3F,iBAAkC;AAElC,aAAwB;AACxB,MAAM,cAAc;AACb,MAAM,gBAAgB,IAAI,wBAAW,EAAE,MAAM,GAAG,WAAW,mBAAmB,QAAQ;AAAA,EACrF,IAAI,OAAO;AACf,EAAE,CAAC;AACA,MAAM,MAAM,IAAI,uBAAU,EAAE,MAAM,GAAG,WAAW,SAAS,QAAQ,CAAC,eAAI,KAAK,CAAC,EAAE,CAAC;AAc/E,SAAS,KAA6B,SAAwB;AACjE,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;AAAA,IACnB,GAAG,QAAQ,cAAc,CAAC,CAAC;AAAA,EAC/B;AACA,QAAM,iBAAiB,CAAC,OAAO;AAC/B,SAAO,CAAC,OAAoB,GAAG,SAAS;AAAA,IACpC,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,eAAW,qCAAuB,QAAQ,WAAW,gBAAgB,cAAc;AAAA,IACnF,eAAe,QAAQ;AAAA,EAC3B,CAAC;AACL;AAcO,SAAS,OAAO,SAAwB;AAC3C,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;AAAA,IACnB,GAAG,cAAc,mCAAmC,QAAQ,cAAc,CAAC,CAAC;AAAA,EAChF;AACA,QAAM,iBAAiB,CAAC,OAAO;AAC/B,SAAO,CAAC,OAAoB,GAAG,SAAS;AAAA,IACpC,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,eAAW,qCAAuB,QAAQ,WAAW,gBAAgB,cAAc;AAAA,IACnF,eAAe,QAAQ;AAAA,EAC3B,CAAC;AACL;AAcO,SAAS,UAAU,SAA2B;AACjD,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;AAAA,IACnB,GAAG,cAAc,mCAAmC,QAAQ,cAAc,CAAC,CAAC;AAAA,EAChF;AACA,QAAM,iBAAiB,CAAC,OAAO;AAC/B,SAAO,CAAC,OAAoB,GAAG,SAAS;AAAA,IACpC,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,eAAW,qCAAuB,QAAQ,WAAW,gBAAgB,cAAc;AAAA,IACnF,eAAe,QAAQ;AAAA,EAC3B,CAAC;AACL;AAgBO,SAAS,KAA6B,SAAyB;AAClE,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;AAAA,IACnB,GAAG,cAAc,mCAAmC,QAAQ,cAAc,CAAC,CAAC;AAAA,IAC5E,GAAG,QAAQ,cAAc,CAAC,CAAC;AAAA,EAC/B;AACA,QAAM,iBAAiB,CAAC,SAAS,OAAO;AACxC,SAAO,CAAC,OAAoB,GAAG,SAAS;AAAA,IACpC,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,eAAW,qCAAuB,QAAQ,WAAW,gBAAgB,cAAc;AAAA,IACnF,eAAe,QAAQ;AAAA,EAC3B,CAAC;AACL;AAcO,SAAS,QAAQ,SAAyB;AAC7C,QAAM,iBAAiB,QAAQ,WAAW;AAC1C,QAAM,iBAAiB;AAAA,IACnB,GAAG,cAAc,mCAAmC,QAAQ,cAAc,CAAC,CAAC;AAAA,EAChF;AACA,QAAM,iBAAiB,CAAC,OAAO;AAC/B,SAAO,CAAC,OAAoB,GAAG,SAAS;AAAA,IACpC,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,eAAW,qCAAuB,QAAQ,WAAW,gBAAgB,cAAc;AAAA,IACnF,eAAe,QAAQ;AAAA,EAC3B,CAAC;AACL;",
  "names": []
}
