"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var user_share_encryption_keys_exports = {};
__export(user_share_encryption_keys_exports, {
  UserShareEncryptionKeys: () => UserShareEncryptionKeys,
  VersionedUserShareEncryptionKeysBcs: () => VersionedUserShareEncryptionKeysBcs
});
module.exports = __toCommonJS(user_share_encryption_keys_exports);
var import_bcs = require("@mysten/bcs");
var import_ed25519 = require("@mysten/sui/keypairs/ed25519");
var import_sha3 = require("@noble/hashes/sha3");
var import_cryptography = require("./cryptography.js");
var import_hash_signature_validation = require("./hash-signature-validation.js");
var import_utils = require("./utils.js");
var import_wasm_loader = require("./wasm-loader.js");
var _encryptedSecretShareSigningKeypair, _UserShareEncryptionKeys_instances, serializeShareEncryptionKeys_fn, _UserShareEncryptionKeys_static, parseShareEncryptionKeys_fn;
const VersionedUserShareEncryptionKeysBcs = import_bcs.bcs.enum("VersionedUserShareEncryptionKeys", {
  V1: import_bcs.bcs.struct("UserShareEncryptionKeysV1", {
    encryptionKey: import_bcs.bcs.vector(import_bcs.bcs.u8()),
    decryptionKey: import_bcs.bcs.vector(import_bcs.bcs.u8()),
    secretShareSigningSecretKey: import_bcs.bcs.string(),
    curve: import_bcs.bcs.u64()
  })
});
const _UserShareEncryptionKeys = class _UserShareEncryptionKeys {
  constructor(encryptionKey, decryptionKey, secretShareSigningSecretKey, curve) {
    __privateAdd(this, _UserShareEncryptionKeys_instances);
    /** The public encryption key used to encrypt secret shares */
    __publicField(this, "encryptionKey");
    /** The private decryption key used to decrypt secret shares */
    __publicField(this, "decryptionKey");
    /** The Ed25519 keypair used for signing encrypted secret share operations */
    __privateAdd(this, _encryptedSecretShareSigningKeypair);
    /** The curve used to generate the encryption/decryption keys */
    __publicField(this, "curve");
    this.encryptionKey = encryptionKey;
    this.decryptionKey = decryptionKey;
    __privateSet(this, _encryptedSecretShareSigningKeypair, secretShareSigningSecretKey);
    this.curve = curve;
  }
  /**
   * Creates UserShareEncryptionKeys from a root seed key (Uint8Array).
   *
   * @param rootSeedKey - The root seed key to generate keys from
   * @param curve - The curve to use for key generation
   * @returns A new UserShareEncryptionKeys instance
   */
  static async fromRootSeedKey(rootSeedKey, curve) {
    const classGroupsSeed = _UserShareEncryptionKeys.hash(
      _UserShareEncryptionKeys.domainSeparators.classGroups,
      rootSeedKey,
      curve
    );
    const encryptionSignerKeySeed = _UserShareEncryptionKeys.hash(
      _UserShareEncryptionKeys.domainSeparators.encryptionSignerKey,
      rootSeedKey,
      curve
    );
    const classGroupsKeypair = await (0, import_cryptography.createClassGroupsKeypair)(classGroupsSeed, curve);
    const encryptionSignerKey = import_ed25519.Ed25519Keypair.deriveKeypairFromSeed(
      (0, import_bcs.toHex)(encryptionSignerKeySeed)
    );
    return new _UserShareEncryptionKeys(
      new Uint8Array(classGroupsKeypair.encryptionKey),
      new Uint8Array(classGroupsKeypair.decryptionKey),
      encryptionSignerKey,
      curve
    );
  }
  static fromShareEncryptionKeysBytes(shareEncryptionKeysBytes) {
    const { encryptionKey, decryptionKey, secretShareSigningSecretKey, curve } = __privateMethod(this, _UserShareEncryptionKeys_static, parseShareEncryptionKeys_fn).call(this, shareEncryptionKeysBytes);
    const secretShareSigningKeypair = import_ed25519.Ed25519Keypair.fromSecretKey(secretShareSigningSecretKey);
    return new _UserShareEncryptionKeys(
      encryptionKey,
      decryptionKey,
      secretShareSigningKeypair,
      curve
    );
  }
  toShareEncryptionKeysBytes() {
    return __privateMethod(this, _UserShareEncryptionKeys_instances, serializeShareEncryptionKeys_fn).call(this);
  }
  /**
   * Gets the public key of the encrypted secret share signing keypair.
   *
   * @returns The Ed25519 public key used for signature verification
   */
  getPublicKey() {
    return __privateGet(this, _encryptedSecretShareSigningKeypair).getPublicKey();
  }
  /**
   * Gets the Sui address derived from the encrypted secret share signing keypair.
   *
   * @returns The Sui address as a string
   */
  getSuiAddress() {
    return __privateGet(this, _encryptedSecretShareSigningKeypair).getPublicKey().toSuiAddress();
  }
  /**
   * Gets the raw bytes of the public key.
   *
   * @returns The raw bytes of the Ed25519 public key
   */
  getSigningPublicKeyBytes() {
    return __privateGet(this, _encryptedSecretShareSigningKeypair).getPublicKey().toRawBytes();
  }
  /**
   * Verifies a signature over a message.
   *
   * @param message - The message to verify
   * @param signature - The signature to verify
   * @returns Promise resolving to the verification result
   */
  async verifySignature(message, signature) {
    return await __privateGet(this, _encryptedSecretShareSigningKeypair).getPublicKey().verify(message, signature);
  }
  /**
   * Creates a signature over the encryption key using the signing keypair.
   * This signature proves ownership of the encryption key.
   *
   * @returns Promise resolving to the signature bytes
   */
  async getEncryptionKeySignature() {
    return await __privateGet(this, _encryptedSecretShareSigningKeypair).sign(this.encryptionKey);
  }
  /**
   * Creates a signature over the DWallet's public output.
   * This signature proves authorization to use the DWallet's encrypted share.
   *
   * @param dWallet - The DWallet to create a signature for
   * @param userPublicOutput - The user's public output from the DKG process, this is used to verify the user's public output signature.
   * @returns Promise resolving to the signature bytes
   * @throws {Error} If the DWallet is not in awaiting key holder signature state or public output is missing or the user public output does not match the DWallet public output
   */
  async getUserOutputSignature(dWallet, userPublicOutput) {
    if (!dWallet.state.AwaitingKeyHolderSignature?.public_output) {
      throw new Error("DWallet is not in awaiting key holder signature state");
    }
    const dWalletPublicOutput = Uint8Array.from(
      dWallet.state.AwaitingKeyHolderSignature?.public_output
    );
    const isOutputMatch = await (0, import_cryptography.userAndNetworkDKGOutputMatch)(
      (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve),
      userPublicOutput,
      dWalletPublicOutput
    ).catch(() => false);
    if (!isOutputMatch) {
      throw new Error("User public output does not match the DWallet public output");
    }
    return await __privateGet(this, _encryptedSecretShareSigningKeypair).sign(dWalletPublicOutput);
  }
  /**
   * Creates a signature over the DWallet's public output for a transferred or shared DWallet.
   * This signature is later used as a fast verification method over the dWallet data (i.e. public output, against which the secret share is also verified.)
   * We do this at the time of accepting the dWallet, when we know the sender and their public key/address, against which their own signature on the public output is first verified.
   *
   * SECURITY WARNING: `sourceEncryptionKey` shouldn't be fetched from the network;
   * the public key of the sender (or its address) should be known to the receiver,
   * so that the verification here would be impactful.
   *
   * @param dWallet - The DWallet to create a signature for
   * @param sourceEncryptedUserSecretKeyShare - The encrypted user secret key share.
   * @param sourceEncryptionKey - The encryption key used to encrypt the user's secret share.
   * @returns Promise resolving to the signature bytes
   * @throws {Error} If the DWallet is not in awaiting key holder signature state or public output is missing or the user public output does not match the DWallet public output
   */
  async getUserOutputSignatureForTransferredDWallet(dWallet, sourceEncryptedUserSecretKeyShare, sourceEncryptionKey) {
    const dWalletPublicOutput = await (0, import_cryptography.verifyAndGetDWalletDKGPublicOutput)(
      dWallet,
      sourceEncryptedUserSecretKeyShare,
      new import_ed25519.Ed25519PublicKey(sourceEncryptionKey.signer_public_key)
    );
    return await __privateGet(this, _encryptedSecretShareSigningKeypair).sign(dWalletPublicOutput);
  }
  /**
   * Decrypt an encrypted user secret key share for a specific DWallet.
   * This method uses the user's decryption key to recover the secret share.
   *
   * @param dWallet - The DWallet that the encrypted share belongs to
   * @param encryptedUserSecretKeyShare - The encrypted secret key share to decrypt
   * @param protocolPublicParameters - The protocol public parameters for decryption
   * @returns Promise resolving to the decrypted secret share bytes
   * @throws {Error} If decryption fails, the DWallet is not active, or verification fails
   */
  async decryptUserShare(dWallet, encryptedUserSecretKeyShare, protocolPublicParameters) {
    const dWalletPublicOutput = await (0, import_cryptography.verifyAndGetDWalletDKGPublicOutput)(
      dWallet,
      encryptedUserSecretKeyShare,
      __privateGet(this, _encryptedSecretShareSigningKeypair).getPublicKey()
    );
    return {
      verifiedPublicOutput: dWalletPublicOutput,
      secretShare: Uint8Array.from(
        await (0, import_wasm_loader.decrypt_user_share)(
          (0, import_hash_signature_validation.fromCurveToNumber)(this.curve),
          this.decryptionKey,
          dWalletPublicOutput,
          Uint8Array.from(encryptedUserSecretKeyShare.encrypted_centralized_secret_share_and_proof),
          protocolPublicParameters
        )
      )
    };
  }
  /**
   * Hashes a domain separator and root seed to produce a seed for a keypair.
   *
   * @param domainSeparator - The domain separator to use
   * @param rootSeed - The root seed to use
   * @returns The hashed seed as a Uint8Array
   */
  static hash(domainSeparator, rootSeed, curve) {
    return new Uint8Array(
      (0, import_sha3.keccak_256)(Uint8Array.from([...(0, import_utils.encodeToASCII)(domainSeparator), curve, ...rootSeed]))
    );
  }
};
_encryptedSecretShareSigningKeypair = new WeakMap();
_UserShareEncryptionKeys_instances = new WeakSet();
serializeShareEncryptionKeys_fn = function() {
  return VersionedUserShareEncryptionKeysBcs.serialize({
    V1: {
      encryptionKey: this.encryptionKey,
      decryptionKey: this.decryptionKey,
      secretShareSigningSecretKey: __privateGet(this, _encryptedSecretShareSigningKeypair).getSecretKey(),
      curve: (0, import_hash_signature_validation.fromCurveToNumber)(this.curve)
    }
  }).toBytes();
};
_UserShareEncryptionKeys_static = new WeakSet();
parseShareEncryptionKeys_fn = function(shareEncryptionKeysBytes) {
  const {
    V1: { encryptionKey, decryptionKey, secretShareSigningSecretKey, curve }
  } = VersionedUserShareEncryptionKeysBcs.parse(shareEncryptionKeysBytes);
  return {
    encryptionKey: new Uint8Array(encryptionKey),
    decryptionKey: new Uint8Array(decryptionKey),
    secretShareSigningSecretKey,
    curve: (0, import_hash_signature_validation.fromNumberToCurve)(Number(curve))
  };
};
__privateAdd(_UserShareEncryptionKeys, _UserShareEncryptionKeys_static);
__publicField(_UserShareEncryptionKeys, "domainSeparators", {
  classGroups: "CLASS_GROUPS_DECRYPTION_KEY_V1",
  encryptionSignerKey: "ED25519_SIGNING_KEY_V1"
});
let UserShareEncryptionKeys = _UserShareEncryptionKeys;
//# sourceMappingURL=user-share-encryption-keys.js.map
