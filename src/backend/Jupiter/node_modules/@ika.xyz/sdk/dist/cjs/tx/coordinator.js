"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var coordinator_exports = {};
__export(coordinator_exports, {
  acceptEncryptedUserShare: () => acceptEncryptedUserShare,
  advanceEpoch: () => advanceEpoch,
  approveImportedKeyMessage: () => approveImportedKeyMessage,
  approveMessage: () => approveMessage,
  calculatePricingVotes: () => calculatePricingVotes,
  commitUpgrade: () => commitUpgrade,
  currentPricing: () => currentPricing,
  getActiveEncryptionKey: () => getActiveEncryptionKey,
  getDWallet: () => getDWallet,
  hasDWallet: () => hasDWallet,
  initiateMidEpochReconfiguration: () => initiateMidEpochReconfiguration,
  isPartialUserSignatureValid: () => isPartialUserSignatureValid,
  isPresignValid: () => isPresignValid,
  matchPartialUserSignatureWithImportedKeyMessageApproval: () => matchPartialUserSignatureWithImportedKeyMessageApproval,
  matchPartialUserSignatureWithMessageApproval: () => matchPartialUserSignatureWithMessageApproval,
  processCheckpointMessageByCap: () => processCheckpointMessageByCap,
  processCheckpointMessageByQuorum: () => processCheckpointMessageByQuorum,
  registerEncryptionKeyTx: () => registerEncryptionKeyTx,
  registerSessionIdentifier: () => registerSessionIdentifier,
  requestDWalletDKG: () => requestDWalletDKG,
  requestDWalletDKGFirstRound: () => requestDWalletDKGFirstRound,
  requestDWalletDKGSecondRound: () => requestDWalletDKGSecondRound,
  requestDWalletDKGWithPublicUserSecretKeyShare: () => requestDWalletDKGWithPublicUserSecretKeyShare,
  requestDwalletNetworkEncryptionKeyDkgByCap: () => requestDwalletNetworkEncryptionKeyDkgByCap,
  requestFutureSign: () => requestFutureSign,
  requestGlobalPresign: () => requestGlobalPresign,
  requestImportedKeyDwalletVerification: () => requestImportedKeyDwalletVerification,
  requestImportedKeySign: () => requestImportedKeySign,
  requestImportedKeySignAndReturnId: () => requestImportedKeySignAndReturnId,
  requestImportedKeySignWithPartialUserSignature: () => requestImportedKeySignWithPartialUserSignature,
  requestImportedKeySignWithPartialUserSignatureAndReturnId: () => requestImportedKeySignWithPartialUserSignatureAndReturnId,
  requestLockEpochSessions: () => requestLockEpochSessions,
  requestMakeDwalletUserSecretKeySharesPublic: () => requestMakeDwalletUserSecretKeySharesPublic,
  requestNetworkEncryptionKeyMidEpochReconfiguration: () => requestNetworkEncryptionKeyMidEpochReconfiguration,
  requestPresign: () => requestPresign,
  requestReEncryptUserShareFor: () => requestReEncryptUserShareFor,
  requestSign: () => requestSign,
  requestSignAndReturnId: () => requestSignAndReturnId,
  requestSignWithPartialUserSignature: () => requestSignWithPartialUserSignature,
  requestSignWithPartialUserSignatureAndReturnId: () => requestSignWithPartialUserSignatureAndReturnId,
  setGasFeeReimbursementSuiSystemCallValueByCap: () => setGasFeeReimbursementSuiSystemCallValueByCap,
  setGlobalPresignConfig: () => setGlobalPresignConfig,
  setPausedCurvesAndSignatureAlgorithms: () => setPausedCurvesAndSignatureAlgorithms,
  setPricingVote: () => setPricingVote,
  setSupportedAndPricing: () => setSupportedAndPricing,
  signDuringDKGRequest: () => signDuringDKGRequest,
  subsidizeCoordinatorWithIka: () => subsidizeCoordinatorWithIka,
  subsidizeCoordinatorWithSui: () => subsidizeCoordinatorWithSui,
  tryMigrate: () => tryMigrate,
  tryMigrateByCap: () => tryMigrateByCap,
  verifyPartialUserSignatureCap: () => verifyPartialUserSignatureCap,
  verifyPresignCap: () => verifyPresignCap,
  version: () => version
});
module.exports = __toCommonJS(coordinator_exports);
var import_bcs = require("@mysten/sui/bcs");
function registerEncryptionKeyTx(ikaConfig, coordinatorObjectRef, curve, encryptionKey, encryptionKeySignature, signerPublicKey, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::register_encryption_key`,
    arguments: [
      coordinatorObjectRef,
      tx.pure.u32(curve),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(encryptionKey)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(encryptionKeySignature)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(signerPublicKey))
    ]
  });
}
function registerSessionIdentifier(ikaConfig, coordinatorObjectRef, sessionIdentifier, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::register_session_identifier`,
    arguments: [coordinatorObjectRef, tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(sessionIdentifier))]
  });
}
function getActiveEncryptionKey(ikaConfig, coordinatorObjectRef, address, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::get_active_encryption_key`,
    arguments: [coordinatorObjectRef, tx.pure.address(address)]
  });
}
function approveMessage(ikaConfig, coordinatorObjectRef, dwalletCap, signatureAlgorithm, hashScheme, message, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::approve_message`,
    arguments: [
      coordinatorObjectRef,
      dwalletCap,
      tx.pure.u32(signatureAlgorithm),
      tx.pure.u32(hashScheme),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(message))
    ]
  });
}
function approveImportedKeyMessage(ikaConfig, coordinatorObjectRef, importedKeyDWalletCap, signatureAlgorithm, hashScheme, message, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::approve_imported_key_message`,
    arguments: [
      coordinatorObjectRef,
      importedKeyDWalletCap,
      tx.pure.u32(signatureAlgorithm),
      tx.pure.u32(hashScheme),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(message))
    ]
  });
}
function requestDWalletDKGFirstRound(ikaConfig, coordinatorObjectRef, dwalletNetworkEncryptionKeyID, curve, sessionIdentifier, ikaCoin, suiCoin, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_dwallet_dkg_first_round`,
    arguments: [
      coordinatorObjectRef,
      tx.pure.id(dwalletNetworkEncryptionKeyID),
      tx.pure.u32(curve),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function requestDWalletDKGSecondRound(ikaConfig, coordinatorObjectRef, dwalletCap, userPublicKeyShareAndProof, encryptedUserShareAndProof, encryptionKeyAddress, userPublicOutput, signerPublicKey, sessionIdentifier, ikaCoin, suiCoin, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_dwallet_dkg_second_round`,
    arguments: [
      coordinatorObjectRef,
      dwalletCap,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(userPublicKeyShareAndProof)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(encryptedUserShareAndProof)),
      tx.pure.address(encryptionKeyAddress),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(userPublicOutput)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(signerPublicKey)),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function requestDWalletDKG(ikaConfig, coordinatorObjectRef, dwalletNetworkEncryptionKeyId, curve, userPublicKeyShareAndProof, encryptedUserShareAndProof, encryptionKeyAddress, userPublicOutput, signerPublicKey, sessionIdentifier, signDuringDKGRequest2, ikaCoin, suiCoin, tx) {
  const signDuringDKGRequestSerialized = tx.object.option({
    type: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator_inner::SignDuringDKGRequest`,
    value: signDuringDKGRequest2
  })(tx);
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_dwallet_dkg`,
    arguments: [
      coordinatorObjectRef,
      tx.pure.id(dwalletNetworkEncryptionKeyId),
      tx.pure.u32(curve),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(userPublicKeyShareAndProof)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(encryptedUserShareAndProof)),
      tx.pure.address(encryptionKeyAddress),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(userPublicOutput)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(signerPublicKey)),
      signDuringDKGRequestSerialized,
      tx.object(sessionIdentifier),
      ikaCoin,
      suiCoin
    ]
  });
}
function requestDWalletDKGWithPublicUserSecretKeyShare(ikaConfig, coordinatorObjectRef, dwalletNetworkEncryptionKeyId, curve, userPublicKeyShareAndProof, publicUserSecretKeyShare, userPublicOutput, sessionIdentifier, signDuringDKGRequest2, ikaCoin, suiCoin, tx) {
  const signDuringDKGRequestSerialized = tx.object.option({
    type: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator_inner::SignDuringDKGRequest`,
    value: signDuringDKGRequest2
  })(tx);
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_dwallet_dkg_with_public_user_secret_key_share`,
    arguments: [
      coordinatorObjectRef,
      tx.pure.id(dwalletNetworkEncryptionKeyId),
      tx.pure.u32(curve),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(userPublicKeyShareAndProof)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(userPublicOutput)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(publicUserSecretKeyShare)),
      signDuringDKGRequestSerialized,
      tx.object(sessionIdentifier),
      ikaCoin,
      suiCoin
    ]
  });
}
function signDuringDKGRequest(ikaConfig, coordinatorObjectRef, presignCap, hashScheme, message, messageCentralizedSignature, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::sign_during_dkg_request`,
    arguments: [
      coordinatorObjectRef,
      presignCap,
      tx.pure.u32(hashScheme),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(message)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(messageCentralizedSignature))
    ]
  });
}
function processCheckpointMessageByQuorum(ikaConfig, coordinatorObjectRef, signature, signersBitmap, message, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::process_checkpoint_message_by_quorum`,
    arguments: [
      coordinatorObjectRef,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(signature)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(signersBitmap)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(message))
    ]
  });
}
function initiateMidEpochReconfiguration(ikaConfig, coordinatorObjectRef, systemCurrentStatusInfo, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::initiate_mid_epoch_reconfiguration`,
    arguments: [coordinatorObjectRef, tx.object(systemCurrentStatusInfo)]
  });
}
function requestNetworkEncryptionKeyMidEpochReconfiguration(ikaConfig, coordinatorObjectRef, dwalletNetworkEncryptionKeyId, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_network_encryption_key_mid_epoch_reconfiguration`,
    arguments: [coordinatorObjectRef, tx.pure.id(dwalletNetworkEncryptionKeyId)]
  });
}
function advanceEpoch(ikaConfig, coordinatorObjectRef, advanceEpochApprover, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::advance_epoch`,
    arguments: [coordinatorObjectRef, tx.object(advanceEpochApprover)]
  });
}
function requestDwalletNetworkEncryptionKeyDkgByCap(ikaConfig, coordinatorObjectRef, paramsForNetwork, verifiedProtocolCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_dwallet_network_encryption_key_dkg_by_cap`,
    arguments: [
      coordinatorObjectRef,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(paramsForNetwork)),
      verifiedProtocolCap
    ]
  });
}
function processCheckpointMessageByCap(ikaConfig, coordinatorObjectRef, message, verifiedProtocolCap, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::process_checkpoint_message_by_cap`,
    arguments: [
      coordinatorObjectRef,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(message)),
      tx.object(verifiedProtocolCap)
    ]
  });
}
function setGasFeeReimbursementSuiSystemCallValueByCap(ikaConfig, coordinatorObjectRef, gasFeeReimbursementSuiSystemCallValue, verifiedProtocolCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::set_gas_fee_reimbursement_sui_system_call_value_by_cap`,
    arguments: [
      coordinatorObjectRef,
      tx.pure.u64(gasFeeReimbursementSuiSystemCallValue),
      tx.object(verifiedProtocolCap)
    ]
  });
}
function setSupportedAndPricing(ikaConfig, coordinatorObjectRef, defaultPricing, supportedCurvesToSignatureAlgorithmsToHashSchemes, verifiedProtocolCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::set_supported_and_pricing`,
    arguments: [
      coordinatorObjectRef,
      defaultPricing,
      supportedCurvesToSignatureAlgorithmsToHashSchemes,
      tx.object(verifiedProtocolCap)
    ]
  });
}
function setPausedCurvesAndSignatureAlgorithms(ikaConfig, coordinatorObjectRef, pausedCurves, pausedSignatureAlgorithms, pausedHashSchemes, verifiedProtocolCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::set_paused_curves_and_signature_algorithms`,
    arguments: [
      coordinatorObjectRef,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u32()).serialize(pausedCurves)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u32()).serialize(pausedSignatureAlgorithms)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u32()).serialize(pausedHashSchemes)),
      tx.object(verifiedProtocolCap)
    ]
  });
}
function setGlobalPresignConfig(ikaConfig, coordinatorObjectRef, curveToSignatureAlgorithmsForDkg, curveToSignatureAlgorithmsForImportedKey, verifiedProtocolCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::set_global_presign_config`,
    arguments: [
      coordinatorObjectRef,
      curveToSignatureAlgorithmsForDkg,
      curveToSignatureAlgorithmsForImportedKey,
      tx.object(verifiedProtocolCap)
    ]
  });
}
function requestLockEpochSessions(ikaConfig, coordinatorObjectRef, systemCurrentStatusInfo, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_lock_epoch_sessions`,
    arguments: [coordinatorObjectRef, tx.object(systemCurrentStatusInfo)]
  });
}
function setPricingVote(ikaConfig, coordinatorObjectRef, pricing, verifiedValidatorOperationCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::set_pricing_vote`,
    arguments: [coordinatorObjectRef, pricing, tx.object(verifiedValidatorOperationCap)]
  });
}
function calculatePricingVotes(ikaConfig, coordinatorObjectRef, curve, signatureAlgorithm, protocol, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::calculate_pricing_votes`,
    arguments: [
      coordinatorObjectRef,
      tx.pure.u32(curve),
      signatureAlgorithm,
      tx.pure.u32(protocol)
    ]
  });
}
function requestImportedKeyDwalletVerification(ikaConfig, coordinatorObjectRef, dwalletNetworkEncryptionKeyId, curve, userOutgoingMessage, encryptedUserShareAndProof, encryptionKeyAddress, userPublicOutput, signerPublicKey, sessionIdentifier, ikaCoin, suiCoin, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_imported_key_dwallet_verification`,
    arguments: [
      coordinatorObjectRef,
      tx.pure.id(dwalletNetworkEncryptionKeyId),
      tx.pure.u32(curve),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(userOutgoingMessage)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(encryptedUserShareAndProof)),
      tx.pure.address(encryptionKeyAddress),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(userPublicOutput)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(signerPublicKey)),
      tx.object(sessionIdentifier),
      ikaCoin,
      suiCoin
    ]
  });
}
function requestMakeDwalletUserSecretKeySharesPublic(ikaConfig, coordinatorObjectRef, dwalletId, publicUserSecretKeyShare, sessionIdentifier, ikaCoin, suiCoin, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_make_dwallet_user_secret_key_shares_public`,
    arguments: [
      coordinatorObjectRef,
      tx.pure.id(dwalletId),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(publicUserSecretKeyShare)),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function requestReEncryptUserShareFor(ikaConfig, coordinatorObjectRef, dwalletId, destinationEncryptionKeyAddress, encryptedUserShareAndProof, sourceEncryptedUserSecretKeyShareId, sessionIdentifier, ikaCoin, suiCoin, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_re_encrypt_user_share_for`,
    arguments: [
      coordinatorObjectRef,
      tx.pure.id(dwalletId),
      tx.pure.address(destinationEncryptionKeyAddress),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(encryptedUserShareAndProof)),
      tx.pure.id(sourceEncryptedUserSecretKeyShareId),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function acceptEncryptedUserShare(ikaConfig, coordinatorObjectRef, dwalletId, encryptedUserSecretKeyShareId, userOutputSignature, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::accept_encrypted_user_share`,
    arguments: [
      coordinatorObjectRef,
      tx.pure.id(dwalletId),
      tx.pure.id(encryptedUserSecretKeyShareId),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(userOutputSignature))
    ]
  });
}
function requestPresign(ikaConfig, coordinatorObjectRef, dwalletId, signatureAlgorithm, sessionIdentifier, ikaCoin, suiCoin, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_presign`,
    arguments: [
      coordinatorObjectRef,
      tx.pure.id(dwalletId),
      tx.pure.u32(signatureAlgorithm),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function requestGlobalPresign(ikaConfig, coordinatorObjectRef, dwalletNetworkEncryptionKeyId, curve, signatureAlgorithm, sessionIdentifier, ikaCoin, suiCoin, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_global_presign`,
    arguments: [
      coordinatorObjectRef,
      tx.pure.id(dwalletNetworkEncryptionKeyId),
      tx.pure.u32(curve),
      tx.pure.u32(signatureAlgorithm),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function isPresignValid(ikaConfig, coordinatorObjectRef, presignCap, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::is_presign_valid`,
    arguments: [coordinatorObjectRef, tx.object(presignCap)]
  });
}
function verifyPresignCap(ikaConfig, coordinatorObjectRef, unverifiedPresignCap, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::verify_presign_cap`,
    arguments: [coordinatorObjectRef, tx.object(unverifiedPresignCap)]
  });
}
function requestSign(ikaConfig, coordinatorObjectRef, verifiedPresignCap, messageApproval, messageUserSignature, sessionIdentifier, ikaCoin, suiCoin, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_sign`,
    arguments: [
      coordinatorObjectRef,
      verifiedPresignCap,
      messageApproval,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(messageUserSignature)),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function requestSignAndReturnId(ikaConfig, coordinatorObjectRef, verifiedPresignCap, messageApproval, messageUserSignature, sessionIdentifier, ikaCoin, suiCoin, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_sign_and_return_id`,
    arguments: [
      coordinatorObjectRef,
      verifiedPresignCap,
      messageApproval,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(messageUserSignature)),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function requestImportedKeySign(ikaConfig, coordinatorObjectRef, verifiedPresignCap, importedKeyMessageApproval, messageUserSignature, sessionIdentifier, ikaCoin, suiCoin, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_imported_key_sign`,
    arguments: [
      coordinatorObjectRef,
      verifiedPresignCap,
      importedKeyMessageApproval,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(messageUserSignature)),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function requestImportedKeySignAndReturnId(ikaConfig, coordinatorObjectRef, verifiedPresignCap, importedKeyMessageApproval, messageUserSignature, sessionIdentifier, ikaCoin, suiCoin, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_imported_key_sign_and_return_id`,
    arguments: [
      coordinatorObjectRef,
      verifiedPresignCap,
      importedKeyMessageApproval,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(messageUserSignature)),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function requestFutureSign(ikaConfig, coordinatorObjectRef, dwalletId, verifiedPresignCap, message, hashScheme, messageUserSignature, sessionIdentifier, ikaCoin, suiCoin, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_future_sign`,
    arguments: [
      coordinatorObjectRef,
      tx.pure.id(dwalletId),
      verifiedPresignCap,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(message)),
      tx.pure.u32(hashScheme),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(messageUserSignature)),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function isPartialUserSignatureValid(ikaConfig, coordinatorObjectRef, unverifiedPartialUserSignatureCap, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::is_partial_user_signature_valid`,
    arguments: [coordinatorObjectRef, tx.object(unverifiedPartialUserSignatureCap)]
  });
}
function verifyPartialUserSignatureCap(ikaConfig, coordinatorObjectRef, unverifiedPartialUserSignatureCap, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::verify_partial_user_signature_cap`,
    arguments: [coordinatorObjectRef, tx.object(unverifiedPartialUserSignatureCap)]
  });
}
function requestSignWithPartialUserSignature(ikaConfig, coordinatorObjectRef, verifiedPartialUserSignatureCap, messageApproval, sessionIdentifier, ikaCoin, suiCoin, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_sign_with_partial_user_signature`,
    arguments: [
      coordinatorObjectRef,
      tx.object(verifiedPartialUserSignatureCap),
      tx.object(messageApproval),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function requestSignWithPartialUserSignatureAndReturnId(ikaConfig, coordinatorObjectRef, verifiedPartialUserSignatureCap, messageApproval, sessionIdentifier, ikaCoin, suiCoin, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_sign_with_partial_user_signature_and_return_id`,
    arguments: [
      coordinatorObjectRef,
      tx.object(verifiedPartialUserSignatureCap),
      tx.object(messageApproval),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function requestImportedKeySignWithPartialUserSignature(ikaConfig, coordinatorObjectRef, verifiedPartialUserSignatureCap, importedKeyMessageApproval, sessionIdentifier, ikaCoin, suiCoin, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_imported_key_sign_with_partial_user_signature`,
    arguments: [
      coordinatorObjectRef,
      tx.object(verifiedPartialUserSignatureCap),
      tx.object(importedKeyMessageApproval),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function requestImportedKeySignWithPartialUserSignatureAndReturnId(ikaConfig, coordinatorObjectRef, verifiedPartialUserSignatureCap, importedKeyMessageApproval, sessionIdentifier, ikaCoin, suiCoin, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::request_imported_key_sign_with_partial_user_signature_and_return_id`,
    arguments: [
      coordinatorObjectRef,
      tx.object(verifiedPartialUserSignatureCap),
      tx.object(importedKeyMessageApproval),
      sessionIdentifier,
      ikaCoin,
      suiCoin
    ]
  });
}
function matchPartialUserSignatureWithMessageApproval(ikaConfig, coordinatorObjectRef, verifiedPartialUserSignatureCap, messageApproval, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::match_partial_user_signature_with_message_approval`,
    arguments: [
      coordinatorObjectRef,
      tx.object(verifiedPartialUserSignatureCap),
      tx.object(messageApproval)
    ]
  });
}
function matchPartialUserSignatureWithImportedKeyMessageApproval(ikaConfig, coordinatorObjectRef, verifiedPartialUserSignatureCap, importedKeyMessageApproval, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::match_partial_user_signature_with_imported_key_message_approval`,
    arguments: [
      coordinatorObjectRef,
      tx.object(verifiedPartialUserSignatureCap),
      tx.object(importedKeyMessageApproval)
    ]
  });
}
function hasDWallet(ikaConfig, coordinatorObjectRef, dwalletId, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::has_dwallet`,
    arguments: [coordinatorObjectRef, tx.pure.id(dwalletId)]
  });
}
function getDWallet(ikaConfig, coordinatorObjectRef, dwalletId, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::get_dwallet`,
    arguments: [coordinatorObjectRef, tx.pure.id(dwalletId)]
  });
}
function currentPricing(ikaConfig, coordinatorObjectRef, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::current_pricing`,
    arguments: [coordinatorObjectRef]
  });
}
function subsidizeCoordinatorWithSui(ikaConfig, coordinatorObjectRef, suiCoin, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::subsidize_coordinator_with_sui`,
    arguments: [coordinatorObjectRef, suiCoin]
  });
}
function subsidizeCoordinatorWithIka(ikaConfig, coordinatorObjectRef, ikaCoin, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::subsidize_coordinator_with_ika`,
    arguments: [coordinatorObjectRef, ikaCoin]
  });
}
function commitUpgrade(ikaConfig, coordinatorObjectRef, upgradePackageApprover, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::commit_upgrade`,
    arguments: [coordinatorObjectRef, tx.object(upgradePackageApprover)]
  });
}
function tryMigrateByCap(ikaConfig, coordinatorObjectRef, verifiedProtocolCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::try_migrate_by_cap`,
    arguments: [coordinatorObjectRef, tx.object(verifiedProtocolCap)]
  });
}
function tryMigrate(ikaConfig, coordinatorObjectRef, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::try_migrate`,
    arguments: [coordinatorObjectRef]
  });
}
function version(ikaConfig, coordinatorObjectRef, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaDwallet2pcMpcPackage}::coordinator::version`,
    arguments: [coordinatorObjectRef]
  });
}
//# sourceMappingURL=coordinator.js.map
