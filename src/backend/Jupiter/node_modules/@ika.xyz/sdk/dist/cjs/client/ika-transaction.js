"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var ika_transaction_exports = {};
__export(ika_transaction_exports, {
  IkaTransaction: () => IkaTransaction
});
module.exports = __toCommonJS(ika_transaction_exports);
var import_ed25519 = require("@mysten/sui/keypairs/ed25519");
var coordinatorTx = __toESM(require("../tx/coordinator.js"));
var import_cryptography = require("./cryptography.js");
var import_hash_signature_validation = require("./hash-signature-validation.js");
var import_types = require("./types.js");
var import_wasm_loader = require("./wasm-loader.js");
var _ikaClient, _transaction, _userShareEncryptionKeys, _coordinatorObjectRef, _systemObjectRef, _IkaTransaction_instances, getCoordinatorObjectRef_fn, getSystemObjectRef_fn, assertDWalletPublicOutputSet_fn, assertDWalletPublicUserSecretKeyShareSet_fn, assertPresignCompleted_fn, verifySecretShare_fn, decryptAndVerifySecretShare_fn, requestPresign_fn, requestGlobalPresign_fn, getUserSignMessage_fn, requestSign_fn, requestFutureSign_fn, requestImportedKeySign_fn, getUserSecretKeyShare_fn, requestReEncryptUserShareFor_fn, requestImportedKeyDwalletVerification_fn, createUserSignMessageWithPublicOutput_fn, assertCanRunNormalPresign_fn;
class IkaTransaction {
  /**
   * Creates a new IkaTransaction instance
   * @param params.ikaClient - The IkaClient instance for network operations
   * @param params.transaction - The Sui transaction builder to wrap
   * @param params.userShareEncryptionKeys - Optional encryption keys for user share operations
   */
  constructor({ ikaClient, transaction, userShareEncryptionKeys }) {
    __privateAdd(this, _IkaTransaction_instances);
    /** The IkaClient instance for blockchain interactions */
    __privateAdd(this, _ikaClient);
    /** The underlying Sui transaction */
    __privateAdd(this, _transaction);
    /** Optional user share encryption keys for cryptographic operations */
    __privateAdd(this, _userShareEncryptionKeys);
    /** The shared object ref for the coordinator */
    __privateAdd(this, _coordinatorObjectRef);
    /** The shared object ref for the system */
    __privateAdd(this, _systemObjectRef);
    __privateSet(this, _ikaClient, ikaClient);
    __privateSet(this, _transaction, transaction);
    __privateSet(this, _userShareEncryptionKeys, userShareEncryptionKeys);
  }
  /**
   * @deprecated This method is deprecated. Use `requestDWalletDKG` or `requestDWalletDKGWithPublicUserShare` instead.
   *
   * Request the DKG (Distributed Key Generation) first round with automatic decryption key ID fetching.
   * This initiates the creation of a new DWallet through a distributed key generation process.
   *
   * @param params.curve - The elliptic curve identifier to use for key generation
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns Promise resolving to a DWallet capability
   * @throws {Error} If the decryption key ID cannot be fetched
   */
  async requestDWalletDKGFirstRoundAsync(_params) {
    throw new Error(
      "requestDWalletDKGFirstRoundAsync is deprecated. Use requestDWalletDKGFirstRound instead"
    );
  }
  /**
   * @deprecated This method is deprecated. Use `requestDWalletDKG` or `requestDWalletDKGWithPublicUserShare` instead.
   *
   * Request the DKG (Distributed Key Generation) first round with explicit decryption key ID.
   * This initiates the creation of a new DWallet through a distributed key generation process.
   *
   * @param params.curve - The elliptic curve identifier to use for key generation
   * @param params.networkEncryptionKeyID - The specific network encryption key ID to use
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns DWallet capability
   */
  requestDWalletDKGFirstRound(_params) {
    throw new Error("requestDWalletDKGFirstRound is deprecated. Use requestDWalletDKG instead");
  }
  /**
   * @deprecated This method is deprecated. Use `requestDWalletDKG` or `requestDWalletDKGWithPublicUserShare` instead.
   *
   * Request the DKG (Distributed Key Generation) second round to complete DWallet creation.
   * This finalizes the distributed key generation process started in the first round.
   *
   * @param params.dWalletCap - The dWalletCap object from the first round, created for dWallet
   * @param params.dkgSecondRoundRequestInput - Cryptographic data prepared for the second round
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns The updated IkaTransaction instance
   * @throws {Error} If user share encryption keys are not set
   */
  requestDWalletDKGSecondRound(_params) {
    throw new Error("requestDWalletDKGSecondRound is deprecated. Use requestDWalletDKG instead");
  }
  /**
   * Request the DKG (Distributed Key Generation) to create a dWallet.
   *
   * @param params.dkgRequestInput - Cryptographic data prepared for the DKG
   * @param params.sessionIdentifier - The session identifier object
   * @param params.dwalletNetworkEncryptionKeyId - The dWallet network encryption key ID
   * @param params.signDuringDKGRequest - The sign during DKG request (hash must be valid for signature algorithm)
   * @param params.curve - The curve
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   *
   * @returns The DWallet capability and sign id if signDuringDKGRequest is provided
   * @throws {Error} If user share encryption keys are not set
   */
  async requestDWalletDKG({
    dkgRequestInput,
    ikaCoin,
    suiCoin,
    sessionIdentifier,
    dwalletNetworkEncryptionKeyId,
    signDuringDKGRequest,
    curve
  }) {
    if (!__privateGet(this, _userShareEncryptionKeys)) {
      throw new Error("User share encryption keys are not set");
    }
    if (signDuringDKGRequest) {
      (0, import_hash_signature_validation.validateHashSignatureCombination)(
        signDuringDKGRequest.hashScheme,
        signDuringDKGRequest.signatureAlgorithm
      );
      (0, import_hash_signature_validation.validateCurveSignatureAlgorithm)(curve, signDuringDKGRequest.signatureAlgorithm);
    }
    return coordinatorTx.requestDWalletDKG(
      __privateGet(this, _ikaClient).ikaConfig,
      __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
      dwalletNetworkEncryptionKeyId,
      (0, import_hash_signature_validation.fromCurveToNumber)(curve),
      dkgRequestInput.userDKGMessage,
      dkgRequestInput.encryptedUserShareAndProof,
      __privateGet(this, _userShareEncryptionKeys).getSuiAddress(),
      dkgRequestInput.userPublicOutput,
      __privateGet(this, _userShareEncryptionKeys).getSigningPublicKeyBytes(),
      sessionIdentifier,
      signDuringDKGRequest ? coordinatorTx.signDuringDKGRequest(
        __privateGet(this, _ikaClient).ikaConfig,
        __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
        signDuringDKGRequest.verifiedPresignCap,
        (0, import_hash_signature_validation.fromHashToNumber)(
          curve,
          signDuringDKGRequest.signatureAlgorithm,
          signDuringDKGRequest.hashScheme
        ),
        signDuringDKGRequest.message,
        await __privateMethod(this, _IkaTransaction_instances, getUserSignMessage_fn).call(this, {
          userSignatureInputs: {
            secretShare: dkgRequestInput.userSecretKeyShare,
            publicOutput: dkgRequestInput.userPublicOutput,
            hash: signDuringDKGRequest.hashScheme,
            message: signDuringDKGRequest.message,
            signatureScheme: signDuringDKGRequest.signatureAlgorithm,
            presign: signDuringDKGRequest.presign,
            curve,
            createWithCentralizedOutput: true
          },
          signDuringDKG: signDuringDKGRequest ? true : false
        }),
        __privateGet(this, _transaction)
      ) : null,
      ikaCoin,
      suiCoin,
      __privateGet(this, _transaction)
    );
  }
  /**
   * Request the DKG (Distributed Key Generation) with public user share to create a dWallet.
   *
   * @param params.sessionIdentifier - The session identifier object ID
   * @param params.dwalletNetworkEncryptionKeyId - The dWallet network encryption key ID
   * @param params.curve - The curve
   * @param params.publicKeyShareAndProof - The public key share and proof
   * @param params.publicUserSecretKeyShare - The public user secret key share
   * @param params.signDuringDKGRequest - The sign during DKG request (hash must be valid for signature algorithm)
   * @param params.userPublicOutput - The user's public output from the DKG process
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   *
   * @returns The DWallet capability and sign id if signDuringDKGRequest is provided
   * @throws {Error} If user share encryption keys are not set
   */
  async requestDWalletDKGWithPublicUserShare({
    sessionIdentifier,
    dwalletNetworkEncryptionKeyId,
    curve,
    publicKeyShareAndProof,
    publicUserSecretKeyShare,
    signDuringDKGRequest,
    userPublicOutput,
    ikaCoin,
    suiCoin
  }) {
    if (!__privateGet(this, _userShareEncryptionKeys)) {
      throw new Error("User share encryption keys are not set");
    }
    if (signDuringDKGRequest) {
      (0, import_hash_signature_validation.validateHashSignatureCombination)(
        signDuringDKGRequest.hashScheme,
        signDuringDKGRequest.signatureAlgorithm
      );
      (0, import_hash_signature_validation.validateCurveSignatureAlgorithm)(curve, signDuringDKGRequest.signatureAlgorithm);
    }
    return coordinatorTx.requestDWalletDKGWithPublicUserSecretKeyShare(
      __privateGet(this, _ikaClient).ikaConfig,
      __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
      dwalletNetworkEncryptionKeyId,
      (0, import_hash_signature_validation.fromCurveToNumber)(curve),
      publicKeyShareAndProof,
      publicUserSecretKeyShare,
      userPublicOutput,
      sessionIdentifier,
      signDuringDKGRequest ? coordinatorTx.signDuringDKGRequest(
        __privateGet(this, _ikaClient).ikaConfig,
        __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
        signDuringDKGRequest.verifiedPresignCap,
        (0, import_hash_signature_validation.fromHashToNumber)(
          curve,
          signDuringDKGRequest.signatureAlgorithm,
          signDuringDKGRequest.hashScheme
        ),
        signDuringDKGRequest.message,
        await __privateMethod(this, _IkaTransaction_instances, getUserSignMessage_fn).call(this, {
          userSignatureInputs: {
            hash: signDuringDKGRequest.hashScheme,
            message: signDuringDKGRequest.message,
            signatureScheme: signDuringDKGRequest.signatureAlgorithm,
            presign: signDuringDKGRequest.presign,
            curve,
            publicOutput: userPublicOutput,
            secretShare: publicUserSecretKeyShare,
            createWithCentralizedOutput: true
          },
          signDuringDKG: signDuringDKGRequest ? true : false
        }),
        __privateGet(this, _transaction)
      ) : null,
      ikaCoin,
      suiCoin,
      __privateGet(this, _transaction)
    );
  }
  async acceptEncryptedUserShare({
    dWallet,
    userPublicOutput,
    encryptedUserSecretKeyShareId,
    sourceEncryptionKey,
    sourceEncryptedUserSecretKeyShare,
    destinationEncryptedUserSecretKeyShare
  }) {
    if (!__privateGet(this, _userShareEncryptionKeys)) {
      throw new Error("User share encryption keys are not set");
    }
    if (userPublicOutput && encryptedUserSecretKeyShareId) {
      coordinatorTx.acceptEncryptedUserShare(
        __privateGet(this, _ikaClient).ikaConfig,
        __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
        dWallet.id.id,
        encryptedUserSecretKeyShareId,
        await __privateGet(this, _userShareEncryptionKeys).getUserOutputSignature(dWallet, userPublicOutput),
        __privateGet(this, _transaction)
      );
      return this;
    }
    if (sourceEncryptionKey && sourceEncryptedUserSecretKeyShare && destinationEncryptedUserSecretKeyShare) {
      coordinatorTx.acceptEncryptedUserShare(
        __privateGet(this, _ikaClient).ikaConfig,
        __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
        dWallet.id.id,
        destinationEncryptedUserSecretKeyShare.id.id,
        await __privateGet(this, _userShareEncryptionKeys).getUserOutputSignatureForTransferredDWallet(
          dWallet,
          sourceEncryptedUserSecretKeyShare,
          sourceEncryptionKey
        ),
        __privateGet(this, _transaction)
      );
      return this;
    }
    throw new Error(
      "Invalid parameters: must provide either (userPublicOutput, encryptedUserSecretKeyShareId) for regular DWallet or (sourceEncryptionKey, sourceEncryptedUserSecretKeyShare, destinationEncryptedUserSecretKeyShare) for transferred DWallet"
    );
  }
  /**
   * Register an encryption key for the current user on the specified curve.
   * This allows the user to participate in encrypted operations on the network.
   *
   * @param params.curve - The elliptic curve identifier to register the key for
   * @returns Promise resolving to the updated IkaTransaction instance
   * @throws {Error} If user share encryption keys are not set
   */
  async registerEncryptionKey({ curve }) {
    if (!__privateGet(this, _userShareEncryptionKeys)) {
      throw new Error("User share encryption keys are not set");
    }
    coordinatorTx.registerEncryptionKeyTx(
      __privateGet(this, _ikaClient).ikaConfig,
      __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
      (0, import_hash_signature_validation.fromCurveToNumber)(curve),
      __privateGet(this, _userShareEncryptionKeys).encryptionKey,
      await __privateGet(this, _userShareEncryptionKeys).getEncryptionKeySignature(),
      __privateGet(this, _userShareEncryptionKeys).getSigningPublicKeyBytes(),
      __privateGet(this, _transaction)
    );
    return this;
  }
  /**
   * Make the DWallet user secret key shares public, allowing them to be used without decryption.
   * This is useful for scenarios where the secret share can be publicly accessible.
   *
   * @param params.dWallet - The DWallet to make the shares public for
   * @param params.secretShare - The secret share data to make public
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns The updated IkaTransaction instance
   */
  makeDWalletUserSecretKeySharesPublic({
    dWallet,
    secretShare,
    ikaCoin,
    suiCoin
  }) {
    coordinatorTx.requestMakeDwalletUserSecretKeySharesPublic(
      __privateGet(this, _ikaClient).ikaConfig,
      __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
      dWallet.id.id,
      secretShare,
      this.createSessionIdentifier(),
      ikaCoin,
      suiCoin,
      __privateGet(this, _transaction)
    );
    return this;
  }
  /**
   * Request a presign operation for a DWallet.
   * Presigning allows for faster signature generation by pre-computing part of the signature.
   *
   * If you are using ecdsa(k1,r1) and imported key dwallet, you must call this function always
   * If you are using schnor, schnorrkell, eddsa, taproot, call requestGlobalPresign instead
   *
   * @param params.dWallet - The DWallet to create the presign for
   * @param params.signatureAlgorithm - The signature algorithm identifier to use
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns Unverified presign capability
   */
  requestPresign({
    dWallet,
    signatureAlgorithm,
    ikaCoin,
    suiCoin
  }) {
    __privateMethod(this, _IkaTransaction_instances, assertDWalletPublicOutputSet_fn).call(this, dWallet);
    __privateMethod(this, _IkaTransaction_instances, assertCanRunNormalPresign_fn).call(this, dWallet, signatureAlgorithm);
    (0, import_hash_signature_validation.validateCurveSignatureAlgorithm)((0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve), signatureAlgorithm);
    const unverifiedPresignCap = __privateMethod(this, _IkaTransaction_instances, requestPresign_fn).call(this, {
      dWallet,
      signatureAlgorithm,
      ikaCoin,
      suiCoin
    });
    return unverifiedPresignCap;
  }
  /**
   * Request a global presign operation.
   * If you are using ecdsa(k1,r1) and imported key dwallet, instead call requestPresign
   * If you are using schnor, schnorrkell, eddsa, taproot, call this function always
   *
   * @param params.dwalletNetworkEncryptionKeyId - The network encryption key ID to use for the presign
   * @param params.curve - The curve to use for the presign
   * @param params.signatureAlgorithm - The signature algorithm to use (must be valid for the curve)
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns Unverified presign capability
   */
  requestGlobalPresign({
    dwalletNetworkEncryptionKeyId,
    curve,
    signatureAlgorithm,
    ikaCoin,
    suiCoin
  }) {
    (0, import_hash_signature_validation.validateCurveSignatureAlgorithm)(curve, signatureAlgorithm);
    const unverifiedPresignCap = __privateMethod(this, _IkaTransaction_instances, requestGlobalPresign_fn).call(this, {
      dwalletNetworkEncryptionKeyId,
      curve,
      signatureAlgorithm,
      ikaCoin,
      suiCoin
    });
    return unverifiedPresignCap;
  }
  /**
   * Approve a message for signing with a DWallet.
   * This creates an approval object that can be used in subsequent signing operations.
   *
   * @param params.dWalletCap - The dWalletCap object, that owns the dWallet
   * @param params.curve - The curve to use for the approval
   * @param params.signatureAlgorithm - The signature algorithm to use (must be valid for the curve)
   * @param params.hashScheme - The hash scheme to apply to the message (must be valid for the signature algorithm)
   * @param params.message - The message bytes to approve for signing
   * @returns Message approval
   */
  approveMessage({
    dWalletCap,
    curve,
    signatureAlgorithm,
    hashScheme,
    message
  }) {
    (0, import_hash_signature_validation.validateCurveSignatureAlgorithm)(curve, signatureAlgorithm);
    (0, import_hash_signature_validation.validateHashSignatureCombination)(hashScheme, signatureAlgorithm);
    const { signatureAlgorithmNumber, hashNumber } = (0, import_hash_signature_validation.fromCurveAndSignatureAlgorithmAndHashToNumbers)(
      curve,
      signatureAlgorithm,
      hashScheme
    );
    const messageApproval = coordinatorTx.approveMessage(
      __privateGet(this, _ikaClient).ikaConfig,
      __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
      __privateGet(this, _transaction).object(dWalletCap),
      signatureAlgorithmNumber,
      hashNumber,
      message,
      __privateGet(this, _transaction)
    );
    return messageApproval;
  }
  verifyPresignCap({
    presign,
    unverifiedPresignCap
  }) {
    let capId;
    if (unverifiedPresignCap) {
      capId = unverifiedPresignCap;
    } else if (presign?.cap_id) {
      capId = presign.cap_id;
    } else {
      throw new Error("Either presign or unverifiedPresignCap must be provided");
    }
    const verifiedPresignCap = coordinatorTx.verifyPresignCap(
      __privateGet(this, _ikaClient).ikaConfig,
      __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
      __privateGet(this, _transaction).object(capId),
      __privateGet(this, _transaction)
    );
    return verifiedPresignCap;
  }
  /**
   * Approve a message for signing with an imported key DWallet.
   * This is similar to approveMessage but specifically for DWallets created with imported keys.
   *
   * @param params.dWalletCap - The dWalletCap object, that owns the dWallet
   * @param params.curve - The curve to use for the approval
   * @param params.signatureAlgorithm - The signature algorithm to use (must be valid for the curve)
   * @param params.hashScheme - The hash scheme to apply to the message (must be valid for the signature algorithm)
   * @param params.message - The message bytes to approve for signing
   * @returns Imported key message approval
   */
  approveImportedKeyMessage({
    dWalletCap,
    curve,
    signatureAlgorithm,
    hashScheme,
    message
  }) {
    (0, import_hash_signature_validation.validateCurveSignatureAlgorithm)(curve, signatureAlgorithm);
    (0, import_hash_signature_validation.validateHashSignatureCombination)(hashScheme, signatureAlgorithm);
    const { signatureAlgorithmNumber, hashNumber } = (0, import_hash_signature_validation.fromCurveAndSignatureAlgorithmAndHashToNumbers)(
      curve,
      signatureAlgorithm,
      hashScheme
    );
    const importedKeyMessageApproval = coordinatorTx.approveImportedKeyMessage(
      __privateGet(this, _ikaClient).ikaConfig,
      __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
      __privateGet(this, _transaction).object(dWalletCap),
      signatureAlgorithmNumber,
      hashNumber,
      message,
      __privateGet(this, _transaction)
    );
    return importedKeyMessageApproval;
  }
  /**
   * Sign a message using a DWallet.
   * This performs the actual signing operation using the presign and user's share (encrypted, secret, or public).
   * Only supports ZeroTrust and Shared DWallets. For Imported Key DWallets, use requestSignWithImportedKey instead.
   *
   * SECURITY WARNING: When using unencrypted shares, this method does not verify `secretShare` and `publicOutput`,
   * which must be verified by the caller in order to guarantee zero-trust security.
   *
   * @param params.dWallet - The DWallet to sign with (ZeroTrust or Shared DWallet)
   * @param params.messageApproval - Message approval
   * @param params.hashScheme - The hash scheme used for the message (must be valid for the signature algorithm)
   * @param params.verifiedPresignCap - The verified presign capability
   * @param params.presign - The completed presign object
   * @param params.encryptedUserSecretKeyShare - Optional: encrypted user secret key share (for ZeroTrust DWallets)
   * @param params.secretShare - Optional: unencrypted secret share (requires publicOutput, for ZeroTrust DWallets)
   * @param params.publicOutput - Optional: public output (required when using secretShare, for ZeroTrust DWallets)
   * @param params.message - The message bytes to sign
   * @param params.signatureScheme - The signature algorithm to use
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns Promise resolving to the signature ID
   *
   * @example
   * // ZeroTrust DWallet - Zero-trust signing (encrypted shares)
   * const signatureId = await tx.requestSign({
   *   dWallet, // ZeroTrustDWallet
   *   messageApproval,
   *   encryptedUserSecretKeyShare,
   *   // ... other params
   * });
   *
   * @example
   * // ZeroTrust DWallet - Secret share signing
   * const signatureId = await tx.requestSign({
   *   dWallet, // ZeroTrustDWallet
   *   messageApproval,
   *   secretShare,
   *   publicOutput,
   *   // ... other params
   * });
   *
   * @example
   * // Shared DWallet - Public share signing (no secret params needed)
   * const signatureId = await tx.requestSign({
   *   dWallet, // SharedDWallet
   *   messageApproval,
   *   // ... other params (no secretShare/publicOutput needed)
   * });
   */
  async requestSign({
    dWallet,
    messageApproval,
    hashScheme,
    verifiedPresignCap,
    presign,
    encryptedUserSecretKeyShare,
    secretShare,
    publicOutput,
    message,
    signatureScheme,
    ikaCoin,
    suiCoin
  }) {
    (0, import_hash_signature_validation.validateHashSignatureCombination)(hashScheme, signatureScheme);
    (0, import_hash_signature_validation.validateCurveSignatureAlgorithm)((0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve), signatureScheme);
    const hasPublicShares = !!dWallet.public_user_secret_key_share;
    if (encryptedUserSecretKeyShare) {
      return __privateMethod(this, _IkaTransaction_instances, requestSign_fn).call(this, {
        verifiedPresignCap,
        messageApproval,
        userSignatureInputs: {
          activeDWallet: dWallet,
          presign,
          encryptedUserSecretKeyShare,
          message,
          hash: hashScheme,
          signatureScheme,
          curve: (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve)
        },
        ikaCoin,
        suiCoin
      });
    } else if (secretShare && publicOutput) {
      return __privateMethod(this, _IkaTransaction_instances, requestSign_fn).call(this, {
        verifiedPresignCap,
        messageApproval,
        userSignatureInputs: {
          activeDWallet: dWallet,
          presign,
          secretShare,
          publicOutput,
          message,
          hash: hashScheme,
          signatureScheme,
          curve: (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve)
        },
        ikaCoin,
        suiCoin
      });
    } else if (hasPublicShares) {
      __privateMethod(this, _IkaTransaction_instances, assertDWalletPublicUserSecretKeyShareSet_fn).call(this, dWallet);
      __privateMethod(this, _IkaTransaction_instances, assertDWalletPublicOutputSet_fn).call(this, dWallet);
      return __privateMethod(this, _IkaTransaction_instances, requestSign_fn).call(this, {
        verifiedPresignCap,
        messageApproval,
        userSignatureInputs: {
          activeDWallet: dWallet,
          presign,
          // No need to verify public output in public user-share flows, as there is no zero-trust security in this model.
          publicOutput: Uint8Array.from(dWallet.state.Active?.public_output),
          secretShare: Uint8Array.from(dWallet.public_user_secret_key_share),
          message,
          hash: hashScheme,
          signatureScheme,
          curve: (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve)
        },
        ikaCoin,
        suiCoin
      });
    } else {
      throw new Error(
        "DWallet signing requires either encryptedUserSecretKeyShare, (secretShare + publicOutput), or public_user_secret_key_share on the DWallet"
      );
    }
  }
  /**
   * Sign a message using an Imported Key DWallet.
   * This performs the actual signing operation using the presign and user's share (encrypted, secret, or public).
   *
   * SECURITY WARNING: When using unencrypted shares, this method does not verify `secretShare` and `publicOutput`,
   * which must be verified by the caller in order to guarantee zero-trust security.
   *
   * @param params.dWallet - The Imported Key DWallet to sign with (type and share availability auto-detected)
   * @param params.importedKeyMessageApproval - Imported key message approval
   * @param params.hashScheme - The hash scheme used for the message (must be valid for the signature algorithm)
   * @param params.verifiedPresignCap - The verified presign capability
   * @param params.presign - The completed presign object
   * @param params.encryptedUserSecretKeyShare - Optional: encrypted user secret key share (for ImportedKeyDWallet)
   * @param params.secretShare - Optional: unencrypted secret share (requires publicOutput, for ImportedKeyDWallet)
   * @param params.publicOutput - Optional: public output (required when using secretShare, for ImportedKeyDWallet)
   * @param params.message - The message bytes to sign
   * @param params.signatureScheme - Optional: signature algorithm (defaults to ECDSASecp256k1)
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns Promise resolving to the signature ID
   *
   * @example
   * // ImportedKeyDWallet - Zero-trust signing (encrypted shares)
   * const signatureId = await tx.requestSignWithImportedKey({
   *   dWallet, // ImportedKeyDWallet
   *   importedKeyMessageApproval,
   *   encryptedUserSecretKeyShare,
   *   // ... other params
   * });
   *
   * @example
   * // ImportedKeyDWallet - Secret share signing
   * const signatureId = await tx.requestSignWithImportedKey({
   *   dWallet, // ImportedKeyDWallet
   *   importedKeyMessageApproval,
   *   secretShare,
   *   publicOutput,
   *   // ... other params
   * });
   *
   * @example
   * // ImportedSharedDWallet - Public share signing (no secret params needed)
   * const signatureId = await tx.requestSignWithImportedKey({
   *   dWallet, // ImportedSharedDWallet
   *   importedKeyMessageApproval,
   *   // ... other params (no secretShare/publicOutput needed)
   * });
   */
  async requestSignWithImportedKey({
    dWallet,
    importedKeyMessageApproval,
    hashScheme,
    verifiedPresignCap,
    presign,
    encryptedUserSecretKeyShare,
    secretShare,
    publicOutput,
    message,
    signatureScheme,
    ikaCoin,
    suiCoin
  }) {
    if (!dWallet.is_imported_key_dwallet) {
      throw new Error("dWallet must be an ImportedKeyDWallet");
    }
    const actualSignatureScheme = signatureScheme || import_types.SignatureAlgorithm.ECDSASecp256k1;
    (0, import_hash_signature_validation.validateHashSignatureCombination)(hashScheme, actualSignatureScheme);
    (0, import_hash_signature_validation.validateCurveSignatureAlgorithm)((0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve), actualSignatureScheme);
    const hasPublicShares = !!dWallet.public_user_secret_key_share;
    if (encryptedUserSecretKeyShare) {
      return __privateMethod(this, _IkaTransaction_instances, requestImportedKeySign_fn).call(this, {
        verifiedPresignCap,
        importedKeyMessageApproval,
        userSignatureInputs: {
          activeDWallet: dWallet,
          encryptedUserSecretKeyShare,
          presign,
          message,
          hash: hashScheme,
          signatureScheme: actualSignatureScheme,
          curve: (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve)
        },
        ikaCoin,
        suiCoin
      });
    } else if (secretShare && publicOutput) {
      return __privateMethod(this, _IkaTransaction_instances, requestImportedKeySign_fn).call(this, {
        verifiedPresignCap,
        importedKeyMessageApproval,
        userSignatureInputs: {
          activeDWallet: dWallet,
          secretShare,
          publicOutput,
          presign,
          message,
          hash: hashScheme,
          signatureScheme: actualSignatureScheme,
          curve: (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve)
        },
        ikaCoin,
        suiCoin
      });
    } else if (hasPublicShares) {
      __privateMethod(this, _IkaTransaction_instances, assertDWalletPublicUserSecretKeyShareSet_fn).call(this, dWallet);
      return __privateMethod(this, _IkaTransaction_instances, requestImportedKeySign_fn).call(this, {
        verifiedPresignCap,
        importedKeyMessageApproval,
        userSignatureInputs: {
          activeDWallet: dWallet,
          presign,
          message,
          hash: hashScheme,
          signatureScheme: actualSignatureScheme,
          curve: (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve)
        },
        ikaCoin,
        suiCoin
      });
    } else {
      throw new Error(
        "Imported Key DWallet signing requires either encryptedUserSecretKeyShare, (secretShare + publicOutput), or public_user_secret_key_share on the DWallet"
      );
    }
  }
  /**
   * Universal requestFutureSign method implementation that automatically detects DWallet type and share availability.
   * This method intelligently routes to the appropriate future signing implementation.
   * Only supports ZeroTrust and Shared DWallets. For Imported Key DWallets, use requestFutureSignWithImportedKey instead.
   *
   * @param params.dWallet - The DWallet to create the future sign for (ZeroTrust or Shared DWallet)
   * @param params.verifiedPresignCap - The verified presign capability
   * @param params.presign - The completed presign object
   * @param params.encryptedUserSecretKeyShare - Optional: encrypted user secret key share (for ZeroTrust DWallets)
   * @param params.secretShare - Optional: unencrypted secret share (requires publicOutput, for ZeroTrust DWallets)
   * @param params.publicOutput - Optional: public output (required when using secretShare, for ZeroTrust DWallets)
   * @param params.message - The message bytes to pre-sign
   * @param params.hashScheme - The hash scheme to use for the message
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns Promise resolving to unverified partial user signature capability
   *
   * @example
   * // ZeroTrust DWallet - Keep capability (encrypted shares)
   * const unverifiedPartialUserSignatureCap = await tx.requestFutureSign({
   *   dWallet, // ZeroTrustDWallet
   *   encryptedUserSecretKeyShare,
   *   // ... other params
   * });
   *
   * @example
   * // ZeroTrust DWallet
   * const unverifiedPartialUserSignatureCap = await tx.requestFutureSign({
   *   dWallet, // ZeroTrustDWallet
   *   secretShare,
   *   publicOutput,
   *   // ... other params
   * });
   *
   * @example
   * // Shared DWallet - Public share signing (no secret params needed)
   * const unverifiedPartialUserSignatureCap = await tx.requestFutureSign({
   *   dWallet, // SharedDWallet
   *   // ... other params (no secretShare/publicOutput needed)
   * });
   */
  async requestFutureSign({
    dWallet,
    verifiedPresignCap,
    presign,
    encryptedUserSecretKeyShare,
    secretShare,
    publicOutput,
    message,
    hashScheme,
    signatureScheme,
    ikaCoin,
    suiCoin
  }) {
    (0, import_hash_signature_validation.validateHashSignatureCombination)(hashScheme, signatureScheme);
    (0, import_hash_signature_validation.validateCurveSignatureAlgorithm)((0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve), signatureScheme);
    const hasPublicShares = !!dWallet.public_user_secret_key_share;
    let unverifiedPartialUserSignatureCap;
    if (encryptedUserSecretKeyShare) {
      unverifiedPartialUserSignatureCap = await __privateMethod(this, _IkaTransaction_instances, requestFutureSign_fn).call(this, {
        verifiedPresignCap,
        userSignatureInputs: {
          activeDWallet: dWallet,
          presign,
          encryptedUserSecretKeyShare,
          message,
          hash: hashScheme,
          signatureScheme,
          curve: (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve)
        },
        ikaCoin,
        suiCoin
      });
    } else if (secretShare && publicOutput) {
      unverifiedPartialUserSignatureCap = await __privateMethod(this, _IkaTransaction_instances, requestFutureSign_fn).call(this, {
        verifiedPresignCap,
        userSignatureInputs: {
          activeDWallet: dWallet,
          presign,
          secretShare,
          publicOutput,
          message,
          hash: hashScheme,
          signatureScheme,
          curve: (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve)
        },
        ikaCoin,
        suiCoin
      });
    } else if (hasPublicShares) {
      __privateMethod(this, _IkaTransaction_instances, assertDWalletPublicUserSecretKeyShareSet_fn).call(this, dWallet);
      __privateMethod(this, _IkaTransaction_instances, assertDWalletPublicOutputSet_fn).call(this, dWallet);
      unverifiedPartialUserSignatureCap = await __privateMethod(this, _IkaTransaction_instances, requestFutureSign_fn).call(this, {
        verifiedPresignCap,
        userSignatureInputs: {
          activeDWallet: dWallet,
          presign,
          // No need to verify public output in public user-share flows, as there is no zero-trust security in this model.
          publicOutput: Uint8Array.from(dWallet.state.Active?.public_output),
          secretShare: Uint8Array.from(dWallet.public_user_secret_key_share),
          message,
          hash: hashScheme,
          signatureScheme,
          curve: (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve)
        },
        ikaCoin,
        suiCoin
      });
    } else {
      throw new Error(
        "DWallet future signing requires either encryptedUserSecretKeyShare, (secretShare + publicOutput), or public_user_secret_key_share on the DWallet"
      );
    }
    return unverifiedPartialUserSignatureCap;
  }
  /**
   * Universal requestFutureSignWithImportedKey method implementation that automatically detects the Imported Key DWallet type and signing method.
   * This method intelligently routes to the appropriate future signing implementation for Imported Key DWallets.
   *
   * @param params.dWallet - The Imported Key DWallet to create the future sign for (type and share availability auto-detected)
   * @param params.verifiedPresignCap - The verified presign capability
   * @param params.presign - The completed presign object
   * @param params.encryptedUserSecretKeyShare - Optional: encrypted user secret key share (for ImportedKeyDWallet)
   * @param params.secretShare - Optional: unencrypted secret share (requires publicOutput, for ImportedKeyDWallet)
   * @param params.publicOutput - Optional: public output (required when using secretShare, for ImportedKeyDWallet)
   * @param params.message - The message bytes to pre-sign
   * @param params.hashScheme - The hash scheme to use for the message
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns Promise resolving to unverified partial user signature capability
   *
   * @example
   * // ImportedKeyDWallet - Keep capability (encrypted shares)
   * const unverifiedPartialUserSignatureCap = await tx.requestFutureSignWithImportedKey({
   *   dWallet, // ImportedKeyDWallet
   *   encryptedUserSecretKeyShare,
   *   // ... other params
   * });
   *
   * @example
   * // ImportedKeyDWallet
   * const unverifiedPartialUserSignatureCap = await tx.requestFutureSignWithImportedKey({
   *   dWallet, // ImportedKeyDWallet
   *   secretShare,
   *   publicOutput,
   *   // ... other params
   * });
   *
   * @example
   * // ImportedSharedDWallet - Public share signing (no secret params needed)
   * const unverifiedPartialUserSignatureCap = await tx.requestFutureSignWithImportedKey({
   *   dWallet, // ImportedSharedDWallet
   *   // ... other params (no secretShare/publicOutput needed)
   * });
   */
  async requestFutureSignWithImportedKey({
    dWallet,
    verifiedPresignCap,
    presign,
    encryptedUserSecretKeyShare,
    secretShare,
    publicOutput,
    message,
    hashScheme,
    signatureScheme,
    ikaCoin,
    suiCoin
  }) {
    (0, import_hash_signature_validation.validateHashSignatureCombination)(hashScheme, signatureScheme);
    (0, import_hash_signature_validation.validateCurveSignatureAlgorithm)((0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve), signatureScheme);
    const hasPublicShares = !!dWallet.public_user_secret_key_share;
    let unverifiedPartialUserSignatureCap;
    if (encryptedUserSecretKeyShare) {
      unverifiedPartialUserSignatureCap = await __privateMethod(this, _IkaTransaction_instances, requestFutureSign_fn).call(this, {
        verifiedPresignCap,
        userSignatureInputs: {
          activeDWallet: dWallet,
          presign,
          encryptedUserSecretKeyShare,
          message,
          hash: hashScheme,
          signatureScheme,
          curve: (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve)
        },
        ikaCoin,
        suiCoin
      });
    } else if (secretShare && publicOutput) {
      unverifiedPartialUserSignatureCap = await __privateMethod(this, _IkaTransaction_instances, requestFutureSign_fn).call(this, {
        verifiedPresignCap,
        userSignatureInputs: {
          activeDWallet: dWallet,
          presign,
          secretShare,
          publicOutput,
          message,
          hash: hashScheme,
          signatureScheme,
          curve: (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve)
        },
        ikaCoin,
        suiCoin
      });
    } else if (hasPublicShares) {
      __privateMethod(this, _IkaTransaction_instances, assertDWalletPublicUserSecretKeyShareSet_fn).call(this, dWallet);
      __privateMethod(this, _IkaTransaction_instances, assertDWalletPublicOutputSet_fn).call(this, dWallet);
      unverifiedPartialUserSignatureCap = await __privateMethod(this, _IkaTransaction_instances, requestFutureSign_fn).call(this, {
        verifiedPresignCap,
        userSignatureInputs: {
          activeDWallet: dWallet,
          presign,
          // No need to verify public output in public user-share flows, as there is no zero-trust security in this model.
          publicOutput: Uint8Array.from(dWallet.state.Active?.public_output),
          secretShare: Uint8Array.from(dWallet.public_user_secret_key_share),
          message,
          hash: hashScheme,
          signatureScheme,
          curve: (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve)
        },
        ikaCoin,
        suiCoin
      });
    } else {
      throw new Error(
        "Imported Key DWallet future signing requires either encryptedUserSecretKeyShare, (secretShare + publicOutput), or public_user_secret_key_share on the DWallet"
      );
    }
    return unverifiedPartialUserSignatureCap;
  }
  /**
   * Complete a future sign operation using a previously created partial user signature.
   * This method takes a partial signature created earlier and combines it with message approval to create a full signature.
   *
   * @param params.partialUserSignatureCap - The partial user signature capability created by requestFutureSign
   * @param params.messageApproval - The message approval from approveMessage
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns The signature ID
   */
  futureSign({
    partialUserSignatureCap,
    messageApproval,
    ikaCoin,
    suiCoin
  }) {
    return coordinatorTx.requestSignWithPartialUserSignatureAndReturnId(
      __privateGet(this, _ikaClient).ikaConfig,
      __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
      coordinatorTx.verifyPartialUserSignatureCap(
        __privateGet(this, _ikaClient).ikaConfig,
        __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
        __privateGet(this, _transaction).object(partialUserSignatureCap),
        __privateGet(this, _transaction)
      ),
      messageApproval,
      this.createSessionIdentifier(),
      ikaCoin,
      suiCoin,
      __privateGet(this, _transaction)
    );
  }
  /**
   * Complete a future sign operation for imported key using a previously created partial user signature.
   * This method takes a partial signature created earlier and combines it with imported key message approval to create a full signature.
   *
   * @param params.partialUserSignatureCap - The partial user signature capability created by requestFutureSignWithImportedKey
   * @param params.importedKeyMessageApproval - The imported key message approval from approveImportedKeyMessage
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns The signature ID
   */
  futureSignWithImportedKey({
    partialUserSignatureCap,
    importedKeyMessageApproval,
    ikaCoin,
    suiCoin
  }) {
    return coordinatorTx.requestImportedKeySignWithPartialUserSignatureAndReturnId(
      __privateGet(this, _ikaClient).ikaConfig,
      __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
      coordinatorTx.verifyPartialUserSignatureCap(
        __privateGet(this, _ikaClient).ikaConfig,
        __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
        __privateGet(this, _transaction).object(partialUserSignatureCap),
        __privateGet(this, _transaction)
      ),
      importedKeyMessageApproval,
      this.createSessionIdentifier(),
      ikaCoin,
      suiCoin,
      __privateGet(this, _transaction)
    );
  }
  /**
   * Request verification for an Imported Key DWallet key and keep the capability.
   * This method creates a DWallet from an existing cryptographic key that was generated outside the network.
   *
   * @param params.importDWalletVerificationRequestInput - The prepared verification data from prepareImportedKeyDWalletVerification
   * @param params.curve - The elliptic curve identifier used for the imported key
   * @param params.signerPublicKey - The public key of the transaction signer
   * @param params.sessionIdentifier - Unique session identifier for this operation
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns Promise resolving to imported key DWallet capability
   */
  async requestImportedKeyDWalletVerification({
    importDWalletVerificationRequestInput,
    curve,
    signerPublicKey,
    sessionIdentifier,
    ikaCoin,
    suiCoin
  }) {
    const importedKeyDWalletVerificationCap = await __privateMethod(this, _IkaTransaction_instances, requestImportedKeyDwalletVerification_fn).call(this, {
      importDWalletVerificationRequestInput,
      curve,
      signerPublicKey,
      sessionIdentifier,
      ikaCoin,
      suiCoin
    });
    return importedKeyDWalletVerificationCap;
  }
  /**
   * Universal transferUserShare method implementation.
   * This re-encrypts the user's share with the destination address's encryption key.
   * When sourceSecretShare is provided, it's used directly; otherwise, the encrypted share is decrypted automatically.
   *
   * @param params.dWallet - The DWallet whose user share is being transferred
   * @param params.destinationEncryptionKeyAddress - The Sui address that will receive the re-encrypted share
   * @param params.sourceEncryptedUserSecretKeyShare - The current user's encrypted secret key share
   * @param params.sourceSecretShare - Optional: The current user's unencrypted secret share
   * @param params.ikaCoin - The IKA coin object to use for transaction fees
   * @param params.suiCoin - The SUI coin object to use for gas fees
   * @returns Promise resolving to the updated IkaTransaction instance
   * @throws {Error} If user share encryption keys are not set
   */
  async requestReEncryptUserShareFor({
    dWallet,
    destinationEncryptionKeyAddress,
    sourceEncryptedUserSecretKeyShare,
    sourceSecretShare,
    ikaCoin,
    suiCoin
  }) {
    let finalSourceSecretShare;
    if (sourceSecretShare) {
      finalSourceSecretShare = sourceSecretShare;
    } else {
      if (!__privateGet(this, _userShareEncryptionKeys)) {
        throw new Error("User share encryption keys are not set");
      }
      const { secretShare: decryptedSecretShare } = await __privateGet(this, _userShareEncryptionKeys).decryptUserShare(
        dWallet,
        sourceEncryptedUserSecretKeyShare,
        await __privateGet(this, _ikaClient).getProtocolPublicParameters(dWallet)
      );
      finalSourceSecretShare = decryptedSecretShare;
    }
    await __privateMethod(this, _IkaTransaction_instances, requestReEncryptUserShareFor_fn).call(this, {
      dWallet,
      destinationEncryptionKeyAddress,
      sourceEncryptedUserSecretKeyShare,
      sourceSecretShare: finalSourceSecretShare,
      ikaCoin,
      suiCoin
    });
    return this;
  }
  /**
   * Create a unique session identifier for the current transaction and register it with the coordinator.
   *
   * @returns The session identifier transaction object argument
   */
  createSessionIdentifier() {
    return this.registerSessionIdentifier((0, import_cryptography.createRandomSessionIdentifier)());
  }
  /**
   * Register a unique session identifier for the current transaction.
   *
   * @returns The session identifier transaction object argument
   */
  registerSessionIdentifier(sessionIdentifier) {
    return coordinatorTx.registerSessionIdentifier(
      __privateGet(this, _ikaClient).ikaConfig,
      __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
      sessionIdentifier,
      __privateGet(this, _transaction)
    );
  }
  /**
   * Check if a DWallet with the specified ID exists in the coordinator.
   * This is useful for validating DWallet existence before performing operations.
   *
   * @param params.dwalletId - The ID of the DWallet to check
   * @returns Transaction result indicating whether the DWallet exists (returns a boolean)
   */
  hasDWallet({ dwalletId }) {
    return coordinatorTx.hasDWallet(
      __privateGet(this, _ikaClient).ikaConfig,
      __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
      dwalletId,
      __privateGet(this, _transaction)
    );
  }
  /**
   * Get a reference to a DWallet object from the coordinator.
   * This returns an immutable reference to the DWallet that can be used in the same transaction.
   *
   * @param params.dwalletId - The ID of the DWallet to retrieve
   * @returns Transaction result containing a reference to the DWallet object
   */
  getDWallet({ dwalletId }) {
    return coordinatorTx.getDWallet(
      __privateGet(this, _ikaClient).ikaConfig,
      __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
      dwalletId,
      __privateGet(this, _transaction)
    );
  }
}
_ikaClient = new WeakMap();
_transaction = new WeakMap();
_userShareEncryptionKeys = new WeakMap();
_coordinatorObjectRef = new WeakMap();
_systemObjectRef = new WeakMap();
_IkaTransaction_instances = new WeakSet();
getCoordinatorObjectRef_fn = function() {
  if (!__privateGet(this, _coordinatorObjectRef)) {
    __privateSet(this, _coordinatorObjectRef, __privateGet(this, _transaction).sharedObjectRef({
      objectId: __privateGet(this, _ikaClient).ikaConfig.objects.ikaDWalletCoordinator.objectID,
      initialSharedVersion: __privateGet(this, _ikaClient).ikaConfig.objects.ikaDWalletCoordinator.initialSharedVersion,
      mutable: true
    }));
  }
  return __privateGet(this, _coordinatorObjectRef);
};
// @ts-expect-error - TODO: Add system functions
getSystemObjectRef_fn = function() {
  if (!__privateGet(this, _systemObjectRef)) {
    __privateSet(this, _systemObjectRef, __privateGet(this, _transaction).sharedObjectRef({
      objectId: __privateGet(this, _ikaClient).ikaConfig.objects.ikaSystemObject.objectID,
      initialSharedVersion: __privateGet(this, _ikaClient).ikaConfig.objects.ikaSystemObject.initialSharedVersion,
      mutable: true
    }));
  }
  return __privateGet(this, _systemObjectRef);
};
assertDWalletPublicOutputSet_fn = function(dWallet) {
  if (!dWallet.state.Active?.public_output) {
    throw new Error("DWallet public output is not set");
  }
};
assertDWalletPublicUserSecretKeyShareSet_fn = function(dWallet) {
  if (!dWallet.public_user_secret_key_share) {
    throw new Error("DWallet public user secret key share is not set");
  }
};
assertPresignCompleted_fn = function(presign) {
  if (!presign.state.Completed?.presign) {
    throw new Error("Presign is not completed");
  }
};
verifySecretShare_fn = async function({
  curve,
  verifiedPublicOutput,
  secretShare,
  publicParameters
}) {
  const userShareVerified = (0, import_cryptography.verifyUserShare)(
    curve,
    secretShare,
    verifiedPublicOutput,
    publicParameters
  );
  if (!userShareVerified) {
    throw new Error("User share verification failed");
  }
};
decryptAndVerifySecretShare_fn = async function({
  dWallet,
  encryptedUserSecretKeyShare,
  publicParameters: publicParametersFromParam
}) {
  if (!__privateGet(this, _userShareEncryptionKeys)) {
    throw new Error("User share encryption keys are not set");
  }
  const publicParameters = publicParametersFromParam ?? await __privateGet(this, _ikaClient).getProtocolPublicParameters(dWallet);
  const { secretShare, verifiedPublicOutput } = await __privateGet(this, _userShareEncryptionKeys).decryptUserShare(
    dWallet,
    encryptedUserSecretKeyShare,
    publicParameters
  );
  await __privateMethod(this, _IkaTransaction_instances, verifySecretShare_fn).call(this, {
    curve: (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve),
    verifiedPublicOutput,
    secretShare,
    publicParameters
  });
  return { publicParameters, secretShare, verifiedPublicOutput };
};
requestPresign_fn = function({
  dWallet,
  signatureAlgorithm,
  ikaCoin,
  suiCoin
}) {
  const { signatureAlgorithmNumber } = (0, import_hash_signature_validation.fromCurveAndSignatureAlgorithmToNumbers)(
    (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve),
    signatureAlgorithm
  );
  return coordinatorTx.requestPresign(
    __privateGet(this, _ikaClient).ikaConfig,
    __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
    dWallet.id.id,
    signatureAlgorithmNumber,
    this.createSessionIdentifier(),
    ikaCoin,
    suiCoin,
    __privateGet(this, _transaction)
  );
};
requestGlobalPresign_fn = function({
  dwalletNetworkEncryptionKeyId,
  curve,
  signatureAlgorithm,
  ikaCoin,
  suiCoin
}) {
  const { curveNumber, signatureAlgorithmNumber } = (0, import_hash_signature_validation.fromCurveAndSignatureAlgorithmToNumbers)(
    curve,
    signatureAlgorithm
  );
  return coordinatorTx.requestGlobalPresign(
    __privateGet(this, _ikaClient).ikaConfig,
    __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
    dwalletNetworkEncryptionKeyId,
    curveNumber,
    signatureAlgorithmNumber,
    this.createSessionIdentifier(),
    ikaCoin,
    suiCoin,
    __privateGet(this, _transaction)
  );
};
getUserSignMessage_fn = async function({
  userSignatureInputs,
  signDuringDKG = false
}) {
  __privateMethod(this, _IkaTransaction_instances, assertPresignCompleted_fn).call(this, userSignatureInputs.presign);
  const publicParameters = await __privateGet(this, _ikaClient).getProtocolPublicParameters(
    userSignatureInputs.activeDWallet,
    userSignatureInputs.curve
  );
  let secretShare, publicOutput;
  if (userSignatureInputs.activeDWallet) {
    if (userSignatureInputs.activeDWallet.public_user_secret_key_share && userSignatureInputs.activeDWallet.state.Active?.public_output) {
      secretShare = Uint8Array.from(
        userSignatureInputs.activeDWallet.public_user_secret_key_share
      );
      publicOutput = Uint8Array.from(
        userSignatureInputs.activeDWallet.state.Active?.public_output
      );
    } else {
      const userSecretKeyShareResponse = await __privateMethod(this, _IkaTransaction_instances, getUserSecretKeyShare_fn).call(this, {
        secretShare: userSignatureInputs.secretShare,
        encryptedUserSecretKeyShare: userSignatureInputs.encryptedUserSecretKeyShare,
        activeDWallet: userSignatureInputs.activeDWallet,
        publicParameters,
        publicOutput: userSignatureInputs.publicOutput
      });
      secretShare = userSecretKeyShareResponse.secretShare;
      publicOutput = userSecretKeyShareResponse.verifiedPublicOutput;
    }
  } else {
    if (!userSignatureInputs.secretShare || !userSignatureInputs.publicOutput) {
      throw new Error(
        "Secret share and public output are required when activeDWallet is not set"
      );
    }
    secretShare = userSignatureInputs.secretShare;
    publicOutput = userSignatureInputs.publicOutput;
    if (!signDuringDKG) {
      if (!userSignatureInputs.curve) {
        throw new Error(
          "Curve is required when providing explicit secret share and public output without activeDWallet"
        );
      }
      await __privateMethod(this, _IkaTransaction_instances, verifySecretShare_fn).call(this, {
        curve: userSignatureInputs.curve,
        verifiedPublicOutput: publicOutput,
        secretShare,
        publicParameters
      });
    }
  }
  return __privateMethod(this, _IkaTransaction_instances, createUserSignMessageWithPublicOutput_fn).call(this, {
    protocolPublicParameters: publicParameters,
    publicOutput,
    userSecretKeyShare: secretShare,
    presign: userSignatureInputs.presign.state.Completed?.presign,
    message: userSignatureInputs.message,
    hash: userSignatureInputs.hash,
    signatureScheme: userSignatureInputs.signatureScheme,
    curve: userSignatureInputs.curve,
    createWithCentralizedOutput: userSignatureInputs.createWithCentralizedOutput
  });
};
requestSign_fn = async function({
  verifiedPresignCap,
  messageApproval,
  userSignatureInputs,
  ikaCoin,
  suiCoin
}) {
  const userSignMessage = await __privateMethod(this, _IkaTransaction_instances, getUserSignMessage_fn).call(this, {
    userSignatureInputs
  });
  return coordinatorTx.requestSignAndReturnId(
    __privateGet(this, _ikaClient).ikaConfig,
    __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
    verifiedPresignCap,
    messageApproval,
    userSignMessage,
    this.createSessionIdentifier(),
    ikaCoin,
    suiCoin,
    __privateGet(this, _transaction)
  );
};
requestFutureSign_fn = async function({
  verifiedPresignCap,
  userSignatureInputs,
  ikaCoin,
  suiCoin
}) {
  if (!userSignatureInputs.activeDWallet) {
    throw new Error("Active DWallet is required");
  }
  const userSignMessage = await __privateMethod(this, _IkaTransaction_instances, getUserSignMessage_fn).call(this, {
    userSignatureInputs
  });
  const { hashNumber } = (0, import_hash_signature_validation.fromCurveAndSignatureAlgorithmAndHashToNumbers)(
    userSignatureInputs.curve,
    userSignatureInputs.signatureScheme,
    userSignatureInputs.hash
  );
  return coordinatorTx.requestFutureSign(
    __privateGet(this, _ikaClient).ikaConfig,
    __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
    userSignatureInputs.activeDWallet.id.id,
    verifiedPresignCap,
    userSignatureInputs.message,
    hashNumber,
    userSignMessage,
    this.createSessionIdentifier(),
    ikaCoin,
    suiCoin,
    __privateGet(this, _transaction)
  );
};
requestImportedKeySign_fn = async function({
  verifiedPresignCap,
  importedKeyMessageApproval,
  userSignatureInputs,
  ikaCoin,
  suiCoin
}) {
  const userSignMessage = await __privateMethod(this, _IkaTransaction_instances, getUserSignMessage_fn).call(this, {
    userSignatureInputs
  });
  return coordinatorTx.requestImportedKeySignAndReturnId(
    __privateGet(this, _ikaClient).ikaConfig,
    __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
    verifiedPresignCap,
    importedKeyMessageApproval,
    userSignMessage,
    this.createSessionIdentifier(),
    ikaCoin,
    suiCoin,
    __privateGet(this, _transaction)
  );
};
getUserSecretKeyShare_fn = async function({
  secretShare,
  encryptedUserSecretKeyShare,
  activeDWallet,
  publicParameters,
  publicOutput
}) {
  if (secretShare) {
    if (!publicOutput) {
      throw new Error("Public output is required when providing secret share directly");
    }
    return { secretShare, verifiedPublicOutput: publicOutput };
  }
  if (!encryptedUserSecretKeyShare) {
    throw new Error("Encrypted user secret key share is not set");
  }
  if (!__privateGet(this, _userShareEncryptionKeys)) {
    throw new Error("User share encryption keys are not set");
  }
  return __privateMethod(this, _IkaTransaction_instances, decryptAndVerifySecretShare_fn).call(this, {
    dWallet: activeDWallet,
    encryptedUserSecretKeyShare,
    publicParameters
  });
};
requestReEncryptUserShareFor_fn = async function({
  dWallet,
  destinationEncryptionKeyAddress,
  sourceEncryptedUserSecretKeyShare,
  sourceSecretShare,
  ikaCoin,
  suiCoin
}) {
  if (!sourceEncryptedUserSecretKeyShare.state.KeyHolderSigned?.user_output_signature) {
    throw new Error("User output signature is not set");
  }
  const publicParameters = await __privateGet(this, _ikaClient).getProtocolPublicParameters(dWallet);
  const destinationEncryptionKeyObj = await __privateGet(this, _ikaClient).getActiveEncryptionKey(
    destinationEncryptionKeyAddress
  );
  const publicKey = new import_ed25519.Ed25519PublicKey(
    new Uint8Array(destinationEncryptionKeyObj.signer_public_key)
  );
  if (!await publicKey.verify(
    Uint8Array.from(destinationEncryptionKeyObj.encryption_key),
    Uint8Array.from(destinationEncryptionKeyObj.encryption_key_signature)
  )) {
    throw new Error("Destination encryption key signature is not valid");
  }
  if (publicKey.toSuiAddress() !== destinationEncryptionKeyObj.signer_address) {
    throw new Error("Destination encryption key address does not match the public key");
  }
  return coordinatorTx.requestReEncryptUserShareFor(
    __privateGet(this, _ikaClient).ikaConfig,
    __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
    dWallet.id.id,
    destinationEncryptionKeyAddress,
    await (0, import_cryptography.encryptSecretShare)(
      (0, import_hash_signature_validation.fromNumberToCurve)(destinationEncryptionKeyObj.curve),
      sourceSecretShare,
      new Uint8Array(destinationEncryptionKeyObj.encryption_key),
      publicParameters
    ),
    sourceEncryptedUserSecretKeyShare.id.id,
    this.createSessionIdentifier(),
    ikaCoin,
    suiCoin,
    __privateGet(this, _transaction)
  );
};
requestImportedKeyDwalletVerification_fn = async function({
  importDWalletVerificationRequestInput,
  curve,
  signerPublicKey,
  sessionIdentifier,
  ikaCoin,
  suiCoin
}) {
  if (!__privateGet(this, _userShareEncryptionKeys)) {
    throw new Error("User share encryption keys are not set");
  }
  return coordinatorTx.requestImportedKeyDwalletVerification(
    __privateGet(this, _ikaClient).ikaConfig,
    __privateMethod(this, _IkaTransaction_instances, getCoordinatorObjectRef_fn).call(this),
    (await __privateGet(this, _ikaClient).getConfiguredNetworkEncryptionKey()).id,
    (0, import_hash_signature_validation.fromCurveToNumber)(curve),
    importDWalletVerificationRequestInput.userMessage,
    importDWalletVerificationRequestInput.encryptedUserShareAndProof,
    __privateGet(this, _userShareEncryptionKeys).getSuiAddress(),
    importDWalletVerificationRequestInput.userPublicOutput,
    signerPublicKey,
    sessionIdentifier,
    ikaCoin,
    suiCoin,
    __privateGet(this, _transaction)
  );
};
createUserSignMessageWithPublicOutput_fn = async function({
  protocolPublicParameters,
  publicOutput,
  userSecretKeyShare,
  presign,
  message,
  hash,
  signatureScheme,
  curve,
  createWithCentralizedOutput
}) {
  const { curveNumber, signatureAlgorithmNumber, hashNumber } = (0, import_hash_signature_validation.fromCurveAndSignatureAlgorithmAndHashToNumbers)(curve, signatureScheme, hash);
  if (createWithCentralizedOutput) {
    return new Uint8Array(
      await (0, import_wasm_loader.create_sign_centralized_party_message_with_centralized_party_dkg_output)(
        protocolPublicParameters,
        publicOutput,
        userSecretKeyShare,
        presign,
        message,
        hashNumber,
        signatureAlgorithmNumber,
        curveNumber
      )
    );
  } else {
    return new Uint8Array(
      await (0, import_wasm_loader.create_sign_centralized_party_message)(
        protocolPublicParameters,
        publicOutput,
        userSecretKeyShare,
        presign,
        message,
        hashNumber,
        signatureAlgorithmNumber,
        curveNumber
      )
    );
  }
};
assertCanRunNormalPresign_fn = function(dWallet, signatureAlgorithm) {
  if (dWallet.is_imported_key_dwallet && (signatureAlgorithm === import_types.SignatureAlgorithm.ECDSASecp256k1 || signatureAlgorithm === import_types.SignatureAlgorithm.ECDSASecp256r1)) {
    return;
  }
  const dWalletVersion = dWallet.state.Active?.public_output?.[0] ?? 0 + 1;
  if (!dWallet.is_imported_key_dwallet && dWallet.state.Active?.public_output && dWalletVersion === 1 && // v1 dwallet
  signatureAlgorithm === import_types.SignatureAlgorithm.ECDSASecp256k1) {
    return;
  }
  throw new Error(
    "You can call this function for ecdsa signatures only, and if this is imported key dwallet, or the version is 1"
  );
};
//# sourceMappingURL=ika-transaction.js.map
