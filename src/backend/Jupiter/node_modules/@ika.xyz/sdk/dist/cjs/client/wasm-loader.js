"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var wasm_loader_exports = {};
__export(wasm_loader_exports, {
  centralized_and_decentralized_parties_dkg_output_match: () => centralized_and_decentralized_parties_dkg_output_match,
  create_dkg_centralized_output_v1: () => create_dkg_centralized_output_v1,
  create_dkg_centralized_output_v2: () => create_dkg_centralized_output_v2,
  create_imported_dwallet_centralized_step: () => create_imported_dwallet_centralized_step,
  create_sign_centralized_party_message: () => create_sign_centralized_party_message,
  create_sign_centralized_party_message_with_centralized_party_dkg_output: () => create_sign_centralized_party_message_with_centralized_party_dkg_output,
  decrypt_user_share: () => decrypt_user_share,
  encrypt_secret_share: () => encrypt_secret_share,
  ensureWasmInitialized: () => ensureWasmInitialized,
  generate_secp_cg_keypair_from_seed: () => generate_secp_cg_keypair_from_seed,
  initializeWasm: () => initializeWasm,
  network_dkg_public_output_to_protocol_pp: () => network_dkg_public_output_to_protocol_pp,
  parse_signature_from_sign_output: () => parse_signature_from_sign_output,
  public_key_from_centralized_dkg_output: () => public_key_from_centralized_dkg_output,
  public_key_from_dwallet_output: () => public_key_from_dwallet_output,
  reconfiguration_public_output_to_protocol_pp: () => reconfiguration_public_output_to_protocol_pp,
  verify_secp_signature: () => verify_secp_signature,
  verify_user_share: () => verify_user_share
});
module.exports = __toCommonJS(wasm_loader_exports);
let wasmModule = null;
let initPromise = null;
const isNode = typeof process !== "undefined" && !!process.versions?.node;
async function ensureWasmInitialized() {
  if (wasmModule) return;
  if (!initPromise) initPromise = init();
  await initPromise;
}
async function init() {
  const mod = await import("@ika.xyz/ika-wasm");
  if (isNode) {
    const normalized = mod && typeof mod === "object" && "default" in mod ? mod.default : mod;
    if (typeof normalized.generate_secp_cg_keypair_from_seed !== "function") {
      throw new Error("ika-wasm node glue not initialized (wrong target?)");
    }
    wasmModule = normalized;
    return;
  }
  const initFn = mod.default ?? mod.init;
  if (typeof initFn !== "function") throw new Error("ika-wasm web glue missing init()");
  await initFn();
  wasmModule = mod;
}
async function getWasmModule() {
  await ensureWasmInitialized();
  return wasmModule;
}
async function encrypt_secret_share(curve, userSecretKeyShare, encryptionKey, protocolPublicParameters) {
  const wasm = await getWasmModule();
  return wasm.encrypt_secret_share(
    curve,
    userSecretKeyShare,
    encryptionKey,
    protocolPublicParameters
  );
}
async function verify_user_share(curve, userSecretKeyShare, userDKGOutput, networkDkgPublicOutput) {
  const wasm = await getWasmModule();
  return wasm.verify_user_share(curve, userSecretKeyShare, userDKGOutput, networkDkgPublicOutput);
}
async function generate_secp_cg_keypair_from_seed(curve, seed) {
  const wasm = await getWasmModule();
  return wasm.generate_secp_cg_keypair_from_seed(curve, seed);
}
async function create_dkg_centralized_output_v1(protocolPublicParameters, networkFirstRoundOutput) {
  const wasm = await getWasmModule();
  return wasm.create_dkg_centralized_output_v1(protocolPublicParameters, networkFirstRoundOutput);
}
async function create_dkg_centralized_output_v2(curve, protocolPublicParameters, session_id) {
  const wasm = await getWasmModule();
  return wasm.create_dkg_centralized_output_v2(curve, protocolPublicParameters, session_id);
}
async function create_sign_centralized_party_message(protocolPublicParameters, publicOutput, userSecretKeyShare, presign, message, hash, signatureScheme, curve) {
  const wasm = await getWasmModule();
  return wasm.create_sign_centralized_party_message(
    protocolPublicParameters,
    publicOutput,
    userSecretKeyShare,
    presign,
    message,
    curve,
    signatureScheme,
    hash
  );
}
async function create_sign_centralized_party_message_with_centralized_party_dkg_output(protocolPublicParameters, centralizedDkgOutput, userSecretKeyShare, presign, message, hash, signatureScheme, curve) {
  const wasm = await getWasmModule();
  return wasm.create_sign_centralized_party_message_with_centralized_party_dkg_output(
    protocolPublicParameters,
    centralizedDkgOutput,
    userSecretKeyShare,
    presign,
    message,
    hash,
    signatureScheme,
    curve
  );
}
async function network_dkg_public_output_to_protocol_pp(curve, networkDkgPublicOutput) {
  const wasm = await getWasmModule();
  return wasm.network_dkg_public_output_to_protocol_pp(curve, networkDkgPublicOutput);
}
async function verify_secp_signature(publicKey, signature, message, networkDkgPublicOutput, hash, signatureAlgorithm, curve) {
  const wasm = await getWasmModule();
  return wasm.verify_secp_signature(
    publicKey,
    signature,
    message,
    networkDkgPublicOutput,
    curve,
    signatureAlgorithm,
    hash
  );
}
async function public_key_from_dwallet_output(curve, dWalletOutput) {
  const wasm = await getWasmModule();
  return wasm.public_key_from_dwallet_output(curve, dWalletOutput);
}
async function public_key_from_centralized_dkg_output(curve, centralizedDkgOutput) {
  const wasm = await getWasmModule();
  return wasm.public_key_from_centralized_dkg_output(curve, centralizedDkgOutput);
}
async function reconfiguration_public_output_to_protocol_pp(curve, reconfig_public_output, network_dkg_public_output) {
  const wasm = await getWasmModule();
  return wasm.reconfiguration_public_output_to_protocol_pp(
    curve,
    reconfig_public_output,
    network_dkg_public_output
  );
}
async function centralized_and_decentralized_parties_dkg_output_match(curve, userPublicOutput, networkDKGOutput) {
  const wasm = await getWasmModule();
  return wasm.centralized_and_decentralized_parties_dkg_output_match(
    curve,
    userPublicOutput,
    networkDKGOutput
  );
}
async function create_imported_dwallet_centralized_step(curve, protocolPublicParameters, sessionIdentifier, secretKey) {
  const wasm = await getWasmModule();
  return wasm.create_imported_dwallet_centralized_step(
    curve,
    protocolPublicParameters,
    sessionIdentifier,
    secretKey
  );
}
async function decrypt_user_share(curve, decryptionKey, dWalletPublicOutput, encryptedShare, protocolPublicParameters) {
  const wasm = await getWasmModule();
  return wasm.decrypt_user_share(
    curve,
    decryptionKey,
    dWalletPublicOutput,
    encryptedShare,
    protocolPublicParameters
  );
}
async function parse_signature_from_sign_output(curve, signatureAlgorithm, signatureOutput) {
  const wasm = await getWasmModule();
  return wasm.parse_signature_from_sign_output(curve, signatureAlgorithm, signatureOutput);
}
async function initializeWasm() {
  await ensureWasmInitialized();
}
//# sourceMappingURL=wasm-loader.js.map
