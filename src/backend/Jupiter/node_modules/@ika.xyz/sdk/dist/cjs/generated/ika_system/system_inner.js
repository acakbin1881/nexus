"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var system_inner_exports = {};
__export(system_inner_exports, {
  EndOfPublishEvent: () => EndOfPublishEvent,
  SetApprovedUpgradeEvent: () => SetApprovedUpgradeEvent,
  SetEpochDurationMsEvent: () => SetEpochDurationMsEvent,
  SetMaxValidatorChangeCountEvent: () => SetMaxValidatorChangeCountEvent,
  SetMaxValidatorCountEvent: () => SetMaxValidatorCountEvent,
  SetMinValidatorCountEvent: () => SetMinValidatorCountEvent,
  SetMinValidatorJoiningStakeEvent: () => SetMinValidatorJoiningStakeEvent,
  SetNextProtocolVersionEvent: () => SetNextProtocolVersionEvent,
  SetOrRemoveWitnessApprovingAdvanceEpochEvent: () => SetOrRemoveWitnessApprovingAdvanceEpochEvent,
  SetRewardSlashingRateEvent: () => SetRewardSlashingRateEvent,
  SetStakeSubsidyPeriodLengthEvent: () => SetStakeSubsidyPeriodLengthEvent,
  SetStakeSubsidyRateEvent: () => SetStakeSubsidyRateEvent,
  SetStakeSubsidyStartEpochEvent: () => SetStakeSubsidyStartEpochEvent,
  SystemCheckpointInfoEvent: () => SystemCheckpointInfoEvent,
  SystemEpochInfoEvent: () => SystemEpochInfoEvent,
  SystemInner: () => SystemInner
});
module.exports = __toCommonJS(system_inner_exports);
var import_utils = require("../utils/index.js");
var import_bcs = require("@mysten/sui/bcs");
var system_object_cap = __toESM(require("./deps/ika_common/system_object_cap.js"));
var _package = __toESM(require("./deps/sui/package.js"));
var vec_map = __toESM(require("./deps/sui/vec_map.js"));
var validator_set = __toESM(require("./validator_set.js"));
var protocol_treasury = __toESM(require("./protocol_treasury.js"));
var balance = __toESM(require("./deps/sui/balance.js"));
var bag = __toESM(require("./deps/sui/bag.js"));
const $moduleName = "@local-pkg/system::system_inner";
const SystemInner = new import_utils.MoveStruct({ name: `${$moduleName}::SystemInner`, fields: {
  /** The current epoch ID, starting from 0. */
  epoch: import_bcs.bcs.u64(),
  epoch_start_tx_digest: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** The system object cap for common modules. */
  system_object_cap: system_object_cap.SystemObjectCap,
  /** The current protocol version, starting from 1. */
  protocol_version: import_bcs.bcs.u64(),
  next_protocol_version: import_bcs.bcs.option(import_bcs.bcs.u64()),
  /** Upgrade caps for this package and others like ika coin of the ika protocol. */
  upgrade_caps: import_bcs.bcs.vector(_package.UpgradeCap),
  /** Approved upgrade for package id to its approved digest. */
  approved_upgrades: vec_map.VecMap(import_bcs.bcs.Address, import_bcs.bcs.vector(import_bcs.bcs.u8())),
  /** Contains all information about the validators. */
  validator_set: validator_set.ValidatorSet,
  /** The duration of an epoch, in milliseconds. */
  epoch_duration_ms: import_bcs.bcs.u64(),
  /** The starting epoch in which stake subsidies start being paid out */
  stake_subsidy_start_epoch: import_bcs.bcs.u64(),
  /** Schedule of stake subsidies given out each epoch. */
  protocol_treasury: protocol_treasury.ProtocolTreasury,
  /** Unix timestamp of the current epoch start. */
  epoch_start_timestamp_ms: import_bcs.bcs.u64(),
  /** The last processed checkpoint sequence number. */
  last_processed_checkpoint_sequence_number: import_bcs.bcs.u64(),
  /** The last checkpoint sequence number of the previous epoch. */
  previous_epoch_last_checkpoint_sequence_number: import_bcs.bcs.u64(),
  /** The total messages processed. */
  total_messages_processed: import_bcs.bcs.u64(),
  /** The fees paid for computation. */
  remaining_rewards: balance.Balance,
  /** List of authorized protocol cap ids. */
  authorized_protocol_cap_ids: import_bcs.bcs.vector(import_bcs.bcs.Address),
  /**
   * List of witnesses approving advance epoch. as part of the epoch advancement, we
   * have to collect approval from all witnesses.
   */
  witnesses_approving_advance_epoch: import_bcs.bcs.vector(import_bcs.bcs.string()),
  /** Whether the system has received the end of publish message. */
  received_end_of_publish: import_bcs.bcs.bool(),
  /** Any extra fields that's not defined statically. */
  extra_fields: bag.Bag
} });
const SystemEpochInfoEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SystemEpochInfoEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  protocol_version: import_bcs.bcs.u64(),
  total_stake: import_bcs.bcs.u64(),
  stake_subsidy_amount: import_bcs.bcs.u64(),
  total_computation_fees: import_bcs.bcs.u64(),
  total_stake_rewards_distributed: import_bcs.bcs.u64()
} });
const SystemCheckpointInfoEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SystemCheckpointInfoEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  sequence_number: import_bcs.bcs.u64()
} });
const SetNextProtocolVersionEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetNextProtocolVersionEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  next_protocol_version: import_bcs.bcs.u64()
} });
const SetEpochDurationMsEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetEpochDurationMsEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  epoch_duration_ms: import_bcs.bcs.u64()
} });
const SetStakeSubsidyStartEpochEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetStakeSubsidyStartEpochEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  stake_subsidy_start_epoch: import_bcs.bcs.u64()
} });
const SetStakeSubsidyRateEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetStakeSubsidyRateEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  stake_subsidy_rate: import_bcs.bcs.u16()
} });
const SetStakeSubsidyPeriodLengthEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetStakeSubsidyPeriodLengthEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  stake_subsidy_period_length: import_bcs.bcs.u64()
} });
const SetMinValidatorCountEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetMinValidatorCountEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  min_validator_count: import_bcs.bcs.u64()
} });
const SetMaxValidatorCountEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetMaxValidatorCountEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  max_validator_count: import_bcs.bcs.u64()
} });
const SetMinValidatorJoiningStakeEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetMinValidatorJoiningStakeEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  min_validator_joining_stake: import_bcs.bcs.u64()
} });
const SetMaxValidatorChangeCountEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetMaxValidatorChangeCountEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  max_validator_change_count: import_bcs.bcs.u64()
} });
const SetRewardSlashingRateEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetRewardSlashingRateEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  reward_slashing_rate: import_bcs.bcs.u16()
} });
const SetApprovedUpgradeEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetApprovedUpgradeEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  package_id: import_bcs.bcs.Address,
  digest: import_bcs.bcs.option(import_bcs.bcs.vector(import_bcs.bcs.u8()))
} });
const EndOfPublishEvent = new import_utils.MoveStruct({ name: `${$moduleName}::EndOfPublishEvent`, fields: {
  epoch: import_bcs.bcs.u64()
} });
const SetOrRemoveWitnessApprovingAdvanceEpochEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetOrRemoveWitnessApprovingAdvanceEpochEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  witness_type: import_bcs.bcs.string(),
  remove: import_bcs.bcs.bool()
} });
//# sourceMappingURL=system_inner.js.map
