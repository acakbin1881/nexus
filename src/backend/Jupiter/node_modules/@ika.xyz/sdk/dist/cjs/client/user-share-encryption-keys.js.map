{
  "version": 3,
  "sources": ["../../../src/client/user-share-encryption-keys.ts"],
  "sourcesContent": ["// Copyright (c) dWallet Labs, Ltd.\n// SPDX-License-Identifier: BSD-3-Clause-Clear\n\nimport { bcs, toHex } from '@mysten/bcs';\nimport { Ed25519Keypair, Ed25519PublicKey } from '@mysten/sui/keypairs/ed25519';\nimport { keccak_256 } from '@noble/hashes/sha3';\n\nimport {\n\tcreateClassGroupsKeypair,\n\tuserAndNetworkDKGOutputMatch,\n\tverifyAndGetDWalletDKGPublicOutput,\n} from './cryptography.js';\nimport { fromCurveToNumber, fromNumberToCurve } from './hash-signature-validation.js';\nimport type { Curve, DWallet, EncryptedUserSecretKeyShare, EncryptionKey } from './types.js';\nimport { encodeToASCII } from './utils.js';\nimport { decrypt_user_share } from './wasm-loader.js';\n\n/**\n * BCS enum for UserShareEncryptionKeys.\n *\n * @see UserShareEncryptionKeys\n */\nexport const VersionedUserShareEncryptionKeysBcs = bcs.enum('VersionedUserShareEncryptionKeys', {\n\tV1: bcs.struct('UserShareEncryptionKeysV1', {\n\t\tencryptionKey: bcs.vector(bcs.u8()),\n\t\tdecryptionKey: bcs.vector(bcs.u8()),\n\t\tsecretShareSigningSecretKey: bcs.string(),\n\t\tcurve: bcs.u64(),\n\t}),\n});\n\n/**\n * UserShareEncryptionKeys manages encryption/decryption keys and signing keypairs for user shares.\n * This class handles the creation and management of cryptographic keys needed for secure\n * user share operations in the DWallet network.\n */\nexport class UserShareEncryptionKeys {\n\t/** The public encryption key used to encrypt secret shares */\n\tencryptionKey: Uint8Array;\n\t/** The private decryption key used to decrypt secret shares */\n\tdecryptionKey: Uint8Array;\n\t/** The Ed25519 keypair used for signing encrypted secret share operations */\n\t#encryptedSecretShareSigningKeypair: Ed25519Keypair;\n\t/** The curve used to generate the encryption/decryption keys */\n\tcurve: Curve;\n\n\tstatic domainSeparators = {\n\t\tclassGroups: 'CLASS_GROUPS_DECRYPTION_KEY_V1',\n\t\tencryptionSignerKey: 'ED25519_SIGNING_KEY_V1',\n\t};\n\n\tprivate constructor(\n\t\tencryptionKey: Uint8Array,\n\t\tdecryptionKey: Uint8Array,\n\t\tsecretShareSigningSecretKey: Ed25519Keypair,\n\t\tcurve: Curve,\n\t) {\n\t\tthis.encryptionKey = encryptionKey;\n\t\tthis.decryptionKey = decryptionKey;\n\t\tthis.#encryptedSecretShareSigningKeypair = secretShareSigningSecretKey;\n\t\tthis.curve = curve;\n\t}\n\n\t/**\n\t * Creates UserShareEncryptionKeys from a root seed key (Uint8Array).\n\t *\n\t * @param rootSeedKey - The root seed key to generate keys from\n\t * @param curve - The curve to use for key generation\n\t * @returns A new UserShareEncryptionKeys instance\n\t */\n\tstatic async fromRootSeedKey(\n\t\trootSeedKey: Uint8Array,\n\t\tcurve: Curve,\n\t): Promise<UserShareEncryptionKeys> {\n\t\tconst classGroupsSeed = UserShareEncryptionKeys.hash(\n\t\t\tUserShareEncryptionKeys.domainSeparators.classGroups,\n\t\t\trootSeedKey,\n\t\t\tcurve,\n\t\t);\n\n\t\tconst encryptionSignerKeySeed = UserShareEncryptionKeys.hash(\n\t\t\tUserShareEncryptionKeys.domainSeparators.encryptionSignerKey,\n\t\t\trootSeedKey,\n\t\t\tcurve,\n\t\t);\n\n\t\tconst classGroupsKeypair = await createClassGroupsKeypair(classGroupsSeed, curve);\n\t\tconst encryptionSignerKey = Ed25519Keypair.deriveKeypairFromSeed(\n\t\t\ttoHex(encryptionSignerKeySeed),\n\t\t);\n\n\t\treturn new UserShareEncryptionKeys(\n\t\t\tnew Uint8Array(classGroupsKeypair.encryptionKey),\n\t\t\tnew Uint8Array(classGroupsKeypair.decryptionKey),\n\t\t\tencryptionSignerKey,\n\t\t\tcurve,\n\t\t);\n\t}\n\n\tstatic fromShareEncryptionKeysBytes(\n\t\tshareEncryptionKeysBytes: Uint8Array,\n\t): UserShareEncryptionKeys {\n\t\tconst { encryptionKey, decryptionKey, secretShareSigningSecretKey, curve } =\n\t\t\tthis.#parseShareEncryptionKeys(shareEncryptionKeysBytes);\n\n\t\tconst secretShareSigningKeypair = Ed25519Keypair.fromSecretKey(secretShareSigningSecretKey);\n\n\t\treturn new UserShareEncryptionKeys(\n\t\t\tencryptionKey,\n\t\t\tdecryptionKey,\n\t\t\tsecretShareSigningKeypair,\n\t\t\tcurve,\n\t\t);\n\t}\n\n\ttoShareEncryptionKeysBytes(): Uint8Array {\n\t\treturn this.#serializeShareEncryptionKeys();\n\t}\n\n\t/**\n\t * Gets the public key of the encrypted secret share signing keypair.\n\t *\n\t * @returns The Ed25519 public key used for signature verification\n\t */\n\tgetPublicKey() {\n\t\treturn this.#encryptedSecretShareSigningKeypair.getPublicKey();\n\t}\n\n\t/**\n\t * Gets the Sui address derived from the encrypted secret share signing keypair.\n\t *\n\t * @returns The Sui address as a string\n\t */\n\tgetSuiAddress(): string {\n\t\treturn this.#encryptedSecretShareSigningKeypair.getPublicKey().toSuiAddress();\n\t}\n\n\t/**\n\t * Gets the raw bytes of the public key.\n\t *\n\t * @returns The raw bytes of the Ed25519 public key\n\t */\n\tgetSigningPublicKeyBytes(): Uint8Array {\n\t\treturn this.#encryptedSecretShareSigningKeypair.getPublicKey().toRawBytes();\n\t}\n\n\t/**\n\t * Verifies a signature over a message.\n\t *\n\t * @param message - The message to verify\n\t * @param signature - The signature to verify\n\t * @returns Promise resolving to the verification result\n\t */\n\tasync verifySignature(message: Uint8Array, signature: Uint8Array): Promise<boolean> {\n\t\treturn await this.#encryptedSecretShareSigningKeypair.getPublicKey().verify(message, signature);\n\t}\n\n\t/**\n\t * Creates a signature over the encryption key using the signing keypair.\n\t * This signature proves ownership of the encryption key.\n\t *\n\t * @returns Promise resolving to the signature bytes\n\t */\n\tasync getEncryptionKeySignature(): Promise<Uint8Array> {\n\t\treturn await this.#encryptedSecretShareSigningKeypair.sign(this.encryptionKey);\n\t}\n\n\t/**\n\t * Creates a signature over the DWallet's public output.\n\t * This signature proves authorization to use the DWallet's encrypted share.\n\t *\n\t * @param dWallet - The DWallet to create a signature for\n\t * @param userPublicOutput - The user's public output from the DKG process, this is used to verify the user's public output signature.\n\t * @returns Promise resolving to the signature bytes\n\t * @throws {Error} If the DWallet is not in awaiting key holder signature state or public output is missing or the user public output does not match the DWallet public output\n\t */\n\tasync getUserOutputSignature(\n\t\tdWallet: DWallet,\n\t\tuserPublicOutput: Uint8Array,\n\t): Promise<Uint8Array> {\n\t\tif (!dWallet.state.AwaitingKeyHolderSignature?.public_output) {\n\t\t\tthrow new Error('DWallet is not in awaiting key holder signature state');\n\t\t}\n\n\t\tconst dWalletPublicOutput = Uint8Array.from(\n\t\t\tdWallet.state.AwaitingKeyHolderSignature?.public_output,\n\t\t);\n\n\t\tconst isOutputMatch = await userAndNetworkDKGOutputMatch(\n\t\t\tfromNumberToCurve(dWallet.curve),\n\t\t\tuserPublicOutput,\n\t\t\tdWalletPublicOutput,\n\t\t).catch(() => false);\n\n\t\tif (!isOutputMatch) {\n\t\t\tthrow new Error('User public output does not match the DWallet public output');\n\t\t}\n\n\t\treturn await this.#encryptedSecretShareSigningKeypair.sign(dWalletPublicOutput);\n\t}\n\n\t/**\n\t * Creates a signature over the DWallet's public output for a transferred or shared DWallet.\n\t * This signature is later used as a fast verification method over the dWallet data (i.e. public output, against which the secret share is also verified.)\n\t * We do this at the time of accepting the dWallet, when we know the sender and their public key/address, against which their own signature on the public output is first verified.\n\t *\n\t * SECURITY WARNING: `sourceEncryptionKey` shouldn't be fetched from the network;\n\t * the public key of the sender (or its address) should be known to the receiver,\n\t * so that the verification here would be impactful.\n\t *\n\t * @param dWallet - The DWallet to create a signature for\n\t * @param sourceEncryptedUserSecretKeyShare - The encrypted user secret key share.\n\t * @param sourceEncryptionKey - The encryption key used to encrypt the user's secret share.\n\t * @returns Promise resolving to the signature bytes\n\t * @throws {Error} If the DWallet is not in awaiting key holder signature state or public output is missing or the user public output does not match the DWallet public output\n\t */\n\tasync getUserOutputSignatureForTransferredDWallet(\n\t\tdWallet: DWallet,\n\t\tsourceEncryptedUserSecretKeyShare: EncryptedUserSecretKeyShare,\n\t\tsourceEncryptionKey: EncryptionKey,\n\t): Promise<Uint8Array> {\n\t\tconst dWalletPublicOutput = await verifyAndGetDWalletDKGPublicOutput(\n\t\t\tdWallet,\n\t\t\tsourceEncryptedUserSecretKeyShare,\n\t\t\tnew Ed25519PublicKey(sourceEncryptionKey.signer_public_key),\n\t\t);\n\n\t\treturn await this.#encryptedSecretShareSigningKeypair.sign(dWalletPublicOutput);\n\t}\n\n\t/**\n\t * Decrypt an encrypted user secret key share for a specific DWallet.\n\t * This method uses the user's decryption key to recover the secret share.\n\t *\n\t * @param dWallet - The DWallet that the encrypted share belongs to\n\t * @param encryptedUserSecretKeyShare - The encrypted secret key share to decrypt\n\t * @param protocolPublicParameters - The protocol public parameters for decryption\n\t * @returns Promise resolving to the decrypted secret share bytes\n\t * @throws {Error} If decryption fails, the DWallet is not active, or verification fails\n\t */\n\tasync decryptUserShare(\n\t\tdWallet: DWallet,\n\t\tencryptedUserSecretKeyShare: EncryptedUserSecretKeyShare,\n\t\tprotocolPublicParameters: Uint8Array,\n\t): Promise<{\n\t\tverifiedPublicOutput: Uint8Array;\n\t\tsecretShare: Uint8Array;\n\t}> {\n\t\tconst dWalletPublicOutput = await verifyAndGetDWalletDKGPublicOutput(\n\t\t\tdWallet,\n\t\t\tencryptedUserSecretKeyShare,\n\t\t\tthis.#encryptedSecretShareSigningKeypair.getPublicKey(),\n\t\t);\n\n\t\treturn {\n\t\t\tverifiedPublicOutput: dWalletPublicOutput,\n\t\t\tsecretShare: Uint8Array.from(\n\t\t\t\tawait decrypt_user_share(\n\t\t\t\t\tfromCurveToNumber(this.curve),\n\t\t\t\t\tthis.decryptionKey,\n\t\t\t\t\tdWalletPublicOutput,\n\t\t\t\t\tUint8Array.from(encryptedUserSecretKeyShare.encrypted_centralized_secret_share_and_proof),\n\t\t\t\t\tprotocolPublicParameters,\n\t\t\t\t),\n\t\t\t),\n\t\t};\n\t}\n\n\t/**\n\t * Hashes a domain separator and root seed to produce a seed for a keypair.\n\t *\n\t * @param domainSeparator - The domain separator to use\n\t * @param rootSeed - The root seed to use\n\t * @returns The hashed seed as a Uint8Array\n\t */\n\tstatic hash(domainSeparator: string, rootSeed: Uint8Array, curve: Curve): Uint8Array {\n\t\treturn new Uint8Array(\n\t\t\tkeccak_256(Uint8Array.from([...encodeToASCII(domainSeparator), curve, ...rootSeed])),\n\t\t);\n\t}\n\n\t#serializeShareEncryptionKeys() {\n\t\treturn VersionedUserShareEncryptionKeysBcs.serialize({\n\t\t\tV1: {\n\t\t\t\tencryptionKey: this.encryptionKey,\n\t\t\t\tdecryptionKey: this.decryptionKey,\n\t\t\t\tsecretShareSigningSecretKey: this.#encryptedSecretShareSigningKeypair.getSecretKey(),\n\t\t\t\tcurve: fromCurveToNumber(this.curve),\n\t\t\t},\n\t\t}).toBytes();\n\t}\n\n\tstatic #parseShareEncryptionKeys(shareEncryptionKeysBytes: Uint8Array) {\n\t\tconst {\n\t\t\tV1: { encryptionKey, decryptionKey, secretShareSigningSecretKey, curve },\n\t\t} = VersionedUserShareEncryptionKeysBcs.parse(shareEncryptionKeysBytes);\n\n\t\treturn {\n\t\t\tencryptionKey: new Uint8Array(encryptionKey),\n\t\t\tdecryptionKey: new Uint8Array(decryptionKey),\n\t\t\tsecretShareSigningSecretKey,\n\t\t\tcurve: fromNumberToCurve(Number(curve)),\n\t\t};\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
