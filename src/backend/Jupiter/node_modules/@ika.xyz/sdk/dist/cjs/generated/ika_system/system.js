"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var system_exports = {};
__export(system_exports, {
  System: () => System,
  activeCommittee: () => activeCommittee,
  addUpgradeCapByCap: () => addUpgradeCapByCap,
  advanceEpoch: () => advanceEpoch,
  authorizeUpgrade: () => authorizeUpgrade,
  calculateRewards: () => calculateRewards,
  canWithdrawStakedIkaEarly: () => canWithdrawStakedIkaEarly,
  claimMetadataCap: () => claimMetadataCap,
  collectCommission: () => collectCommission,
  commitUpgrade: () => commitUpgrade,
  createSystemCurrentStatusInfo: () => createSystemCurrentStatusInfo,
  epoch: () => epoch,
  finalizeUpgrade: () => finalizeUpgrade,
  initialize: () => initialize,
  initiateAdvanceEpoch: () => initiateAdvanceEpoch,
  initiateMidEpochReconfiguration: () => initiateMidEpochReconfiguration,
  nextEpochActiveCommittee: () => nextEpochActiveCommittee,
  processCheckpointMessageByCap: () => processCheckpointMessageByCap,
  processCheckpointMessageByQuorum: () => processCheckpointMessageByQuorum,
  reportValidator: () => reportValidator,
  requestAddStake: () => requestAddStake,
  requestAddValidator: () => requestAddValidator,
  requestAddValidatorCandidate: () => requestAddValidatorCandidate,
  requestRemoveValidator: () => requestRemoveValidator,
  requestRemoveValidatorCandidate: () => requestRemoveValidatorCandidate,
  requestWithdrawStake: () => requestWithdrawStake,
  rotateCommissionCap: () => rotateCommissionCap,
  rotateOperationCap: () => rotateOperationCap,
  setApprovedUpgradeByCap: () => setApprovedUpgradeByCap,
  setNextCommission: () => setNextCommission,
  setNextEpochConsensusAddress: () => setNextEpochConsensusAddress,
  setNextEpochConsensusPubkeyBytes: () => setNextEpochConsensusPubkeyBytes,
  setNextEpochMpcDataBytes: () => setNextEpochMpcDataBytes,
  setNextEpochNetworkAddress: () => setNextEpochNetworkAddress,
  setNextEpochNetworkPubkeyBytes: () => setNextEpochNetworkPubkeyBytes,
  setNextEpochP2pAddress: () => setNextEpochP2pAddress,
  setNextEpochProtocolPubkeyBytes: () => setNextEpochProtocolPubkeyBytes,
  setOrRemoveWitnessApprovingAdvanceEpochByCap: () => setOrRemoveWitnessApprovingAdvanceEpochByCap,
  setValidatorMetadata: () => setValidatorMetadata,
  setValidatorName: () => setValidatorName,
  tokenExchangeRates: () => tokenExchangeRates,
  tryMigrate: () => tryMigrate,
  tryMigrateByCap: () => tryMigrateByCap,
  undoReportValidator: () => undoReportValidator,
  validatorMetadata: () => validatorMetadata,
  validatorStakeAmount: () => validatorStakeAmount,
  verifyCommissionCap: () => verifyCommissionCap,
  verifyOperationCap: () => verifyOperationCap,
  verifyProtocolCap: () => verifyProtocolCap,
  verifyValidatorCap: () => verifyValidatorCap,
  version: () => version,
  withdrawStake: () => withdrawStake
});
module.exports = __toCommonJS(system_exports);
var import_utils = require("../utils/index.js");
var import_bcs = require("@mysten/sui/bcs");
var object = __toESM(require("./deps/sui/object.js"));
const $moduleName = "@local-pkg/system::system";
const System = new import_utils.MoveStruct({ name: `${$moduleName}::System`, fields: {
  id: object.UID,
  version: import_bcs.bcs.u64(),
  package_id: import_bcs.bcs.Address,
  new_package_id: import_bcs.bcs.option(import_bcs.bcs.Address),
  migration_epoch: import_bcs.bcs.option(import_bcs.bcs.u64())
} });
function initialize(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "u64",
    `${packageAddress}::protocol_cap::ProtocolCap`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "maxValidatorChangeCount", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "initialize",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function requestAddValidatorCandidate(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    "vector<u8>",
    "vector<u8>",
    "vector<u8>",
    "0x0000000000000000000000000000000000000000000000000000000000000002::table_vec::TableVec<vector<u8>>",
    "vector<u8>",
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    "u16",
    `${packageAddress}::validator_metadata::ValidatorMetadata`
  ];
  const parameterNames = ["self", "name", "protocolPubkeyBytes", "networkPubkeyBytes", "consensusPubkeyBytes", "mpcDataBytes", "proofOfPossessionBytes", "networkAddress", "p2pAddress", "consensusAddress", "commissionRate", "metadata"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "request_add_validator_candidate",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function requestRemoveValidatorCandidate(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "request_remove_validator_candidate",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function requestAddValidator(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "request_add_validator",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function requestRemoveValidator(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "request_remove_validator",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextCommission(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "u16",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "newCommissionRate", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_commission",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function requestAddStake(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::ika::IKA>`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "stake", "validatorId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "request_add_stake",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function requestWithdrawStake(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::staked_ika::StakedIka`
  ];
  const parameterNames = ["self", "stakedIka"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "request_withdraw_stake",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function withdrawStake(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::staked_ika::StakedIka`
  ];
  const parameterNames = ["self", "stakedIka"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "withdraw_stake",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function reportValidator(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorOperationCap`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "cap", "reporteeId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "report_validator",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function undoReportValidator(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorOperationCap`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "cap", "reporteeId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "undo_report_validator",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function rotateOperationCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "rotate_operation_cap",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function rotateCommissionCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "rotate_commission_cap",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function collectCommission(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCommissionCap`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::option::Option<u64>"
  ];
  const parameterNames = ["self", "cap", "amount"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "collect_commission",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function setValidatorName(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "name", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_validator_name",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function validatorMetadata(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "validatorId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "validator_metadata",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function setValidatorMetadata(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_metadata::ValidatorMetadata`,
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "metadata", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_validator_metadata",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochNetworkAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "networkAddress", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_network_address",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochP2pAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "p2pAddress", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_p2p_address",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochConsensusAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "consensusAddress", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_consensus_address",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochProtocolPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "vector<u8>",
    "vector<u8>",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "protocolPubkey", "proofOfPossessionBytes", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_protocol_pubkey_bytes",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochNetworkPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "vector<u8>",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "networkPubkey", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_network_pubkey_bytes",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochConsensusPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "vector<u8>",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "consensusPubkeyBytes", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_consensus_pubkey_bytes",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function setNextEpochMpcDataBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::table_vec::TableVec<vector<u8>>",
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "mpcData", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_next_epoch_mpc_data_bytes",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function tokenExchangeRates(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "validatorId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "token_exchange_rates",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function activeCommittee(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "active_committee",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochActiveCommittee(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "next_epoch_active_committee",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function initiateMidEpochReconfiguration(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "initiate_mid_epoch_reconfiguration",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function createSystemCurrentStatusInfo(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "create_system_current_status_info",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function initiateAdvanceEpoch(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "initiate_advance_epoch",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function advanceEpoch(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::advance_epoch_approver::AdvanceEpochApprover`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "advanceEpochApprover"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "advance_epoch",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function verifyValidatorCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "verify_validator_cap",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function verifyOperationCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorOperationCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "verify_operation_cap",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function verifyCommissionCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::validator_cap::ValidatorCommissionCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "verify_commission_cap",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function authorizeUpgrade(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "packageId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "authorize_upgrade",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function commitUpgrade(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::package::UpgradeReceipt",
    `${packageAddress}::upgrade_package_approver::UpgradePackageApprover`
  ];
  const parameterNames = ["self", "receipt", "upgradePackageApprover"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "commit_upgrade",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function finalizeUpgrade(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::upgrade_package_approver::UpgradePackageApprover`
  ];
  const parameterNames = ["self", "upgradePackageApprover"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "finalize_upgrade",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function processCheckpointMessageByQuorum(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "vector<u8>",
    "vector<u8>",
    "vector<u8>"
  ];
  const parameterNames = ["self", "signature", "signersBitmap", "message"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "process_checkpoint_message_by_quorum",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function addUpgradeCapByCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::package::UpgradeCap",
    `${packageAddress}::protocol_cap::ProtocolCap`
  ];
  const parameterNames = ["self", "upgradeCap", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "add_upgrade_cap_by_cap",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function verifyProtocolCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::protocol_cap::ProtocolCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "verify_protocol_cap",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function processCheckpointMessageByCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "vector<u8>",
    `${packageAddress}::protocol_cap::ProtocolCap`
  ];
  const parameterNames = ["self", "message", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "process_checkpoint_message_by_cap",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function setApprovedUpgradeByCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID",
    "0x0000000000000000000000000000000000000000000000000000000000000001::option::Option<vector<u8>>",
    `${packageAddress}::protocol_cap::ProtocolCap`
  ];
  const parameterNames = ["self", "packageId", "digest", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_approved_upgrade_by_cap",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function setOrRemoveWitnessApprovingAdvanceEpochByCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    "bool",
    `${packageAddress}::protocol_cap::ProtocolCap`
  ];
  const parameterNames = ["self", "witnessType", "remove", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "set_or_remove_witness_approving_advance_epoch_by_cap",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function tryMigrateByCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::protocol_cap::ProtocolCap`
  ];
  const parameterNames = ["self", "cap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "try_migrate_by_cap",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function tryMigrate(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "try_migrate",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function version(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "version",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function calculateRewards(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID",
    "u64",
    "u64",
    "u64"
  ];
  const parameterNames = ["self", "validatorId", "stakedPrincipal", "activationEpoch", "withdrawEpoch"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "calculate_rewards",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function canWithdrawStakedIkaEarly(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `${packageAddress}::staked_ika::StakedIka`
  ];
  const parameterNames = ["self", "stakedIka"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "can_withdraw_staked_ika_early",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function epoch(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "epoch",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function validatorStakeAmount(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "validatorId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "validator_stake_amount",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function claimMetadataCap(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::system::System`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin_registry::Currency<${packageAddress}::ika::IKA>`
  ];
  const parameterNames = ["self", "currency"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "system",
    function: "claim_metadata_cap",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
//# sourceMappingURL=system.js.map
