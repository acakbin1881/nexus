"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var validator_exports = {};
__export(validator_exports, {
  Validator: () => Validator,
  ValidatorState: () => ValidatorState
});
module.exports = __toCommonJS(validator_exports);
var import_utils = require("../utils/index.js");
var import_bcs = require("@mysten/sui/bcs");
var object = __toESM(require("./deps/sui/object.js"));
var validator_info = __toESM(require("./validator_info.js"));
var pending_values = __toESM(require("./pending_values.js"));
var table = __toESM(require("./deps/sui/table.js"));
var balance = __toESM(require("./deps/sui/balance.js"));
var bag = __toESM(require("./deps/sui/bag.js"));
const $moduleName = "@local-pkg/system::validator";
const ValidatorState = new import_utils.MoveEnum({ name: `${$moduleName}::ValidatorState`, fields: {
  /** The validator is not active yet but can accept stakes. */
  PreActive: null,
  /** The validator is active and can accept stakes. */
  Active: null,
  /**
   * The validator awaits the stake to be withdrawn. The value inside the variant is
   * the epoch in which the validator will be withdrawn.
   */
  Withdrawing: import_bcs.bcs.u64()
} });
const Validator = new import_utils.MoveStruct({ name: `${$moduleName}::Validator`, fields: {
  id: object.UID,
  /** The validator info for the validator. */
  validator_info: validator_info.ValidatorInfo,
  /** The current state of the validator. */
  state: ValidatorState,
  /**
   * The epoch when the validator is / will be activated. Serves information purposes
   * only, the checks are performed in the `state` property.
   */
  activation_epoch: import_bcs.bcs.option(import_bcs.bcs.u64()),
  /** Epoch when the validator was last updated. */
  latest_epoch: import_bcs.bcs.u64(),
  /** Currently staked IKA in the validator + rewards validator. */
  ika_balance: import_bcs.bcs.u64(),
  /** The total number of shares in the current epoch. */
  num_shares: import_bcs.bcs.u64(),
  /**
   * The amount of the shares that will be withdrawn in E+1 or E+2. We use this
   * amount to calculate the IKA withdrawal in the `process_pending_stake`.
   */
  pending_shares_withdraw: pending_values.PendingValues,
  /**
   * The amount of the stake requested for withdrawal for a node that may part of the
   * next committee. Stores principals of not yet active stakes. In practice, those
   * tokens are staked for exactly one epoch.
   */
  pre_active_withdrawals: pending_values.PendingValues,
  /**
   * The pending commission rate for the validator. Commission rate is applied in
   * E+2, so we store the value for the matching epoch and apply it in the
   * `advance_epoch` function.
   */
  pending_commission_rate: pending_values.PendingValues,
  /** The commission rate for the validator, in basis points. */
  commission_rate: import_bcs.bcs.u16(),
  /**
   * Historical exchange rates for the validator. The key is the epoch when the
   * exchange rate was set, and the value is the exchange rate (the ratio of the
   * amount of IKA tokens for the validator shares).
   */
  exchange_rates: table.Table,
  /**
   * The amount of stake that will be added to the `ika_balance`. Can hold up to two
   * keys: E+1 and E+2, due to the differences in the activation epoch.
   *
   * ```
   * E+1 -> Balance
   * E+2 -> Balance
   * ```
   *
   * Single key is cleared in the `advance_epoch` function, leaving only the next
   * epoch's stake.
   */
  pending_stake: pending_values.PendingValues,
  /** The rewards that the validator has received from being in the committee. */
  rewards_pool: balance.Balance,
  /** The commission that the validator has received from the rewards. */
  commission: balance.Balance,
  /** The ID of this validator's `ValidatorCap` */
  validator_cap_id: import_bcs.bcs.Address,
  /** The ID of this validator's current valid `ValidatorOperationCap` */
  operation_cap_id: import_bcs.bcs.Address,
  /** The ID of this validator's current valid `ValidatorCommissionCap` */
  commission_cap_id: import_bcs.bcs.Address,
  /** Reserved for future use and migrations. */
  extra_fields: bag.Bag
} });
//# sourceMappingURL=validator.js.map
