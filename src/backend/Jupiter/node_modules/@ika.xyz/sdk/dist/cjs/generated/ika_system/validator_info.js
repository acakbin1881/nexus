"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var validator_info_exports = {};
__export(validator_info_exports, {
  ValidatorInfo: () => ValidatorInfo,
  consensusAddress: () => consensusAddress,
  consensusPubkeyBytes: () => consensusPubkeyBytes,
  mpcDataBytes: () => mpcDataBytes,
  networkAddress: () => networkAddress,
  networkPubkeyBytes: () => networkPubkeyBytes,
  nextEpochConsensusAddress: () => nextEpochConsensusAddress,
  nextEpochConsensusPubkeyBytes: () => nextEpochConsensusPubkeyBytes,
  nextEpochMpcDataBytes: () => nextEpochMpcDataBytes,
  nextEpochNetworkAddress: () => nextEpochNetworkAddress,
  nextEpochNetworkPubkeyBytes: () => nextEpochNetworkPubkeyBytes,
  nextEpochP2pAddress: () => nextEpochP2pAddress,
  nextEpochProtocolPubkeyBytes: () => nextEpochProtocolPubkeyBytes,
  p2pAddress: () => p2pAddress,
  previousMpcDataBytes: () => previousMpcDataBytes,
  protocolPubkey: () => protocolPubkey,
  protocolPubkeyBytes: () => protocolPubkeyBytes,
  validatorId: () => validatorId
});
module.exports = __toCommonJS(validator_info_exports);
var import_utils = require("../utils/index.js");
var import_bcs = require("@mysten/sui/bcs");
var group_ops = __toESM(require("./deps/sui/group_ops.js"));
var table_vec = __toESM(require("./deps/sui/table_vec.js"));
var extended_field = __toESM(require("./deps/ika_common/extended_field.js"));
const $moduleName = "@local-pkg/system::validator_info";
const ValidatorInfo = new import_utils.MoveStruct({ name: `${$moduleName}::ValidatorInfo`, fields: {
  /** Human-readable name of the validator */
  name: import_bcs.bcs.string(),
  /** Unique identifier for this validator */
  validator_id: import_bcs.bcs.Address,
  /**
   * The network address of the validator (could also contain extra info such as
   * port, DNS and etc.)
   */
  network_address: import_bcs.bcs.string(),
  /**
   * The address of the validator used for p2p activities such as state sync (could
   * also contain extra info such as port, DNS and etc.)
   */
  p2p_address: import_bcs.bcs.string(),
  /** The address of the consensus */
  consensus_address: import_bcs.bcs.string(),
  /**
   * Current epoch public keys The public key bytes corresponding to the private key
   * that the validator holds to sign checkpoint messages
   */
  protocol_pubkey_bytes: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** The protocol public key element for cryptographic operations */
  protocol_pubkey: group_ops.Element,
  /**
   * The public key bytes corresponding to the private key that the validator uses to
   * establish TLS connections
   */
  network_pubkey_bytes: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** The public key bytes corresponding to the consensus */
  consensus_pubkey_bytes: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /**
   * The validator's MPC public data. This key is used for the network DKG process
   * and for resharing the network MPC key Must always contain value
   */
  mpc_data_bytes: import_bcs.bcs.option(table_vec.TableVec),
  /**
   * Next epoch configurations - only take effect in the next epoch If none, current
   * value will stay unchanged.
   */
  next_epoch_protocol_pubkey_bytes: import_bcs.bcs.option(import_bcs.bcs.vector(import_bcs.bcs.u8())),
  next_epoch_network_pubkey_bytes: import_bcs.bcs.option(import_bcs.bcs.vector(import_bcs.bcs.u8())),
  next_epoch_consensus_pubkey_bytes: import_bcs.bcs.option(import_bcs.bcs.vector(import_bcs.bcs.u8())),
  next_epoch_mpc_data_bytes: import_bcs.bcs.option(table_vec.TableVec),
  next_epoch_network_address: import_bcs.bcs.option(import_bcs.bcs.string()),
  next_epoch_p2p_address: import_bcs.bcs.option(import_bcs.bcs.string()),
  next_epoch_consensus_address: import_bcs.bcs.option(import_bcs.bcs.string()),
  previous_mpc_data_bytes: import_bcs.bcs.option(table_vec.TableVec),
  /** Extended metadata field for additional validator information */
  metadata: extended_field.ExtendedField
} });
function validatorId(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "validator_id",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function networkAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "network_address",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function p2pAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "p2p_address",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function consensusAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "consensus_address",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function protocolPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "protocol_pubkey_bytes",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function protocolPubkey(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "protocol_pubkey",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function networkPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "network_pubkey_bytes",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function consensusPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "consensus_pubkey_bytes",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function mpcDataBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "mpc_data_bytes",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochNetworkAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_network_address",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochP2pAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_p2p_address",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochConsensusAddress(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_consensus_address",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochProtocolPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_protocol_pubkey_bytes",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochNetworkPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_network_pubkey_bytes",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochConsensusPubkeyBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_consensus_pubkey_bytes",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function nextEpochMpcDataBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "next_epoch_mpc_data_bytes",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function previousMpcDataBytes(options) {
  const packageAddress = options.package ?? "@local-pkg/system";
  const argumentsTypes = [
    `${packageAddress}::validator_info::ValidatorInfo`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "validator_info",
    function: "previous_mpc_data_bytes",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
//# sourceMappingURL=validator_info.js.map
