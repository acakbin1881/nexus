"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var coordinator_inner_exports = {};
__export(coordinator_inner_exports, {
  AcceptEncryptedUserShareEvent: () => AcceptEncryptedUserShareEvent,
  CompletedDWalletDKGEvent: () => CompletedDWalletDKGEvent,
  CompletedDWalletDKGFirstRoundEvent: () => CompletedDWalletDKGFirstRoundEvent,
  CompletedDWalletDKGSecondRoundEvent: () => CompletedDWalletDKGSecondRoundEvent,
  CompletedDWalletEncryptionKeyReconfigurationEvent: () => CompletedDWalletEncryptionKeyReconfigurationEvent,
  CompletedDWalletImportedKeyVerificationEvent: () => CompletedDWalletImportedKeyVerificationEvent,
  CompletedDWalletNetworkDKGEncryptionKeyEvent: () => CompletedDWalletNetworkDKGEncryptionKeyEvent,
  CompletedEncryptedShareVerificationEvent: () => CompletedEncryptedShareVerificationEvent,
  CompletedFutureSignEvent: () => CompletedFutureSignEvent,
  CompletedMakeDWalletUserSecretKeySharePublicEvent: () => CompletedMakeDWalletUserSecretKeySharePublicEvent,
  CompletedPresignEvent: () => CompletedPresignEvent,
  CompletedSignEvent: () => CompletedSignEvent,
  CreatedEncryptionKeyEvent: () => CreatedEncryptionKeyEvent,
  DWallet: () => DWallet,
  DWalletCap: () => DWalletCap,
  DWalletCheckpointInfoEvent: () => DWalletCheckpointInfoEvent,
  DWalletCoordinatorInner: () => DWalletCoordinatorInner,
  DWalletCoordinatorWitness: () => DWalletCoordinatorWitness,
  DWalletDKGFirstRoundRequestEvent: () => DWalletDKGFirstRoundRequestEvent,
  DWalletDKGRequestEvent: () => DWalletDKGRequestEvent,
  DWalletDKGSecondRoundRequestEvent: () => DWalletDKGSecondRoundRequestEvent,
  DWalletEncryptionKeyReconfigurationRequestEvent: () => DWalletEncryptionKeyReconfigurationRequestEvent,
  DWalletImportedKeyVerificationRequestEvent: () => DWalletImportedKeyVerificationRequestEvent,
  DWalletNetworkDKGEncryptionKeyRequestEvent: () => DWalletNetworkDKGEncryptionKeyRequestEvent,
  DWalletNetworkEncryptionKey: () => DWalletNetworkEncryptionKey,
  DWalletNetworkEncryptionKeyState: () => DWalletNetworkEncryptionKeyState,
  DWalletState: () => DWalletState,
  EncryptedShareVerificationRequestEvent: () => EncryptedShareVerificationRequestEvent,
  EncryptedUserSecretKeyShare: () => EncryptedUserSecretKeyShare,
  EncryptedUserSecretKeyShareState: () => EncryptedUserSecretKeyShareState,
  EncryptionKey: () => EncryptionKey,
  EndOfEpochEvent: () => EndOfEpochEvent,
  FutureSignRequestEvent: () => FutureSignRequestEvent,
  ImportedKeyDWalletCap: () => ImportedKeyDWalletCap,
  ImportedKeyMessageApproval: () => ImportedKeyMessageApproval,
  MakeDWalletUserSecretKeySharePublicRequestEvent: () => MakeDWalletUserSecretKeySharePublicRequestEvent,
  MessageApproval: () => MessageApproval,
  PartialUserSignature: () => PartialUserSignature,
  PartialUserSignatureState: () => PartialUserSignatureState,
  PresignRequestEvent: () => PresignRequestEvent,
  PresignSession: () => PresignSession,
  PresignState: () => PresignState,
  RejectedDWalletDKGEvent: () => RejectedDWalletDKGEvent,
  RejectedDWalletDKGFirstRoundEvent: () => RejectedDWalletDKGFirstRoundEvent,
  RejectedDWalletDKGSecondRoundEvent: () => RejectedDWalletDKGSecondRoundEvent,
  RejectedDWalletEncryptionKeyReconfigurationEvent: () => RejectedDWalletEncryptionKeyReconfigurationEvent,
  RejectedDWalletImportedKeyVerificationEvent: () => RejectedDWalletImportedKeyVerificationEvent,
  RejectedDWalletNetworkDKGEncryptionKeyEvent: () => RejectedDWalletNetworkDKGEncryptionKeyEvent,
  RejectedEncryptedShareVerificationEvent: () => RejectedEncryptedShareVerificationEvent,
  RejectedFutureSignEvent: () => RejectedFutureSignEvent,
  RejectedMakeDWalletUserSecretKeySharePublicEvent: () => RejectedMakeDWalletUserSecretKeySharePublicEvent,
  RejectedPresignEvent: () => RejectedPresignEvent,
  RejectedSignEvent: () => RejectedSignEvent,
  SetGasFeeReimbursementSuiSystemCallValueEvent: () => SetGasFeeReimbursementSuiSystemCallValueEvent,
  SetMaxActiveSessionsBufferEvent: () => SetMaxActiveSessionsBufferEvent,
  SignDuringDKGRequest: () => SignDuringDKGRequest,
  SignDuringDKGRequestEvent: () => SignDuringDKGRequestEvent,
  SignRequestEvent: () => SignRequestEvent,
  SignSession: () => SignSession,
  SignState: () => SignState,
  UnverifiedPartialUserSignatureCap: () => UnverifiedPartialUserSignatureCap,
  UnverifiedPresignCap: () => UnverifiedPresignCap,
  UserSecretKeyShareEventType: () => UserSecretKeyShareEventType,
  VerifiedPartialUserSignatureCap: () => VerifiedPartialUserSignatureCap,
  VerifiedPresignCap: () => VerifiedPresignCap,
  curve: () => curve,
  dwalletId: () => dwalletId,
  dwalletNetworkEncryptionKeyId: () => dwalletNetworkEncryptionKeyId,
  getSignSession: () => getSignSession,
  getSignSignature: () => getSignSignature,
  hasSignSession: () => hasSignSession,
  importedKeyDwalletId: () => importedKeyDwalletId,
  isDwalletActive: () => isDwalletActive,
  isImportedKeyDwallet: () => isImportedKeyDwallet,
  requestDwalletDkgImpl: () => requestDwalletDkgImpl,
  validateActiveAndGetPublicOutput: () => validateActiveAndGetPublicOutput
});
module.exports = __toCommonJS(coordinator_inner_exports);
var import_utils = require("../utils/index.js");
var import_bcs = require("@mysten/sui/bcs");
var sessions_manager = __toESM(require("./sessions_manager.js"));
var object_table = __toESM(require("./deps/sui/object_table.js"));
var pricing_and_fee_manager = __toESM(require("./pricing_and_fee_manager.js"));
var bls_committee = __toESM(require("./deps/ika_common/bls_committee.js"));
var support_config = __toESM(require("./support_config.js"));
var bag = __toESM(require("./deps/sui/bag.js"));
var object = __toESM(require("./deps/sui/object.js"));
var table_vec = __toESM(require("./deps/sui/table_vec.js"));
var table = __toESM(require("./deps/sui/table.js"));
const $moduleName = "@local-pkg/2pc-mpc::coordinator_inner";
const DWalletCoordinatorWitness = new import_utils.MoveStruct({ name: `${$moduleName}::DWalletCoordinatorWitness`, fields: {
  dummy_field: import_bcs.bcs.bool()
} });
const DWalletCoordinatorInner = new import_utils.MoveStruct({ name: `${$moduleName}::DWalletCoordinatorInner`, fields: {
  /** Current epoch number */
  current_epoch: import_bcs.bcs.u64(),
  /** Session management and coordination */
  sessions_manager: sessions_manager.SessionsManager,
  /** All dWallet instances (DWallet ID -> DWallet) */
  dwallets: object_table.ObjectTable,
  /**
   * Network encryption keys (Network encryption key ID ->
   * DWalletNetworkEncryptionKey)
   */
  dwallet_network_encryption_keys: object_table.ObjectTable,
  /**
   * Number of network encryption keys reconfiguration have been completed for the
   * current epoch
   */
  epoch_dwallet_network_encryption_keys_reconfiguration_completed: import_bcs.bcs.u64(),
  /** User encryption keys (User encryption key address -> EncryptionKey) */
  encryption_keys: object_table.ObjectTable,
  /**
   * Presign sessions for signature optimization (Presign session ID ->
   * PresignSession)
   */
  presign_sessions: object_table.ObjectTable,
  /**
   * Partial user signatures for future signing (Partial user signature ID ->
   * PartialUserSignature)
   */
  partial_centralized_signed_messages: object_table.ObjectTable,
  /** Pricing and fee management */
  pricing_and_fee_manager: pricing_and_fee_manager.PricingAndFeeManager,
  /** Current active validator committee */
  active_committee: bls_committee.BlsCommittee,
  /** Next epoch active validator committee */
  next_epoch_active_committee: import_bcs.bcs.option(bls_committee.BlsCommittee),
  /** Total number of messages processed */
  total_messages_processed: import_bcs.bcs.u64(),
  /** Last processed checkpoint sequence number */
  last_processed_checkpoint_sequence_number: import_bcs.bcs.u64(),
  /** Last checkpoint sequence number from previous epoch */
  previous_epoch_last_checkpoint_sequence_number: import_bcs.bcs.u64(),
  /** Cryptographic algorithm support configuration */
  support_config: support_config.SupportConfig,
  received_end_of_publish: import_bcs.bcs.bool(),
  /** Any extra fields that's not defined statically */
  extra_fields: bag.Bag
} });
const DWalletCap = new import_utils.MoveStruct({ name: `${$moduleName}::DWalletCap`, fields: {
  id: object.UID,
  /** ID of the controlled dWallet */
  dwallet_id: import_bcs.bcs.Address
} });
const ImportedKeyDWalletCap = new import_utils.MoveStruct({ name: `${$moduleName}::ImportedKeyDWalletCap`, fields: {
  id: object.UID,
  /** ID of the controlled imported key dWallet */
  dwallet_id: import_bcs.bcs.Address
} });
const DWalletNetworkEncryptionKeyState = new import_utils.MoveEnum({ name: `${$moduleName}::DWalletNetworkEncryptionKeyState`, fields: {
  /** DKG request was sent to the network, but didn't finish yet. */
  AwaitingNetworkDKG: null,
  /** Network DKG has completed successfully */
  NetworkDKGCompleted: null,
  /** Reconfiguration request was sent to the network, but didn't finish yet. */
  AwaitingNetworkReconfiguration: null,
  /** Network reconfiguration has completed successfully */
  NetworkReconfigurationCompleted: null
} });
const DWalletNetworkEncryptionKey = new import_utils.MoveStruct({ name: `${$moduleName}::DWalletNetworkEncryptionKey`, fields: {
  id: object.UID,
  /** Epoch when the network DKG was initiated */
  dkg_at_epoch: import_bcs.bcs.u64(),
  /** Initial network DKG output (chunked for storage efficiency) */
  network_dkg_public_output: table_vec.TableVec,
  /** Reconfiguration outputs indexed by epoch (Epoch -> Chunked Output) */
  reconfiguration_public_outputs: table.Table,
  /** Parameters for network dkg */
  dkg_params_for_network: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** Curves supported by this network encryption key */
  supported_curves: import_bcs.bcs.vector(import_bcs.bcs.u32()),
  /** Current operational state */
  state: DWalletNetworkEncryptionKeyState
} });
const EncryptionKey = new import_utils.MoveStruct({ name: `${$moduleName}::EncryptionKey`, fields: {
  /** Unique identifier for this encryption key */
  id: object.UID,
  /** Epoch when this key was created */
  created_at_epoch: import_bcs.bcs.u64(),
  /** Cryptographic curve this key supports */
  curve: import_bcs.bcs.u32(),
  /** Serialized encryption key data */
  encryption_key: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /**
   * Ed25519 signature proving encryption key authenticity, signed by the
   * `signer_public_key`. Used to verify the data originated from the
   * `signer_address`.
   */
  encryption_key_signature: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** Ed25519 public key used to create the signature */
  signer_public_key: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** Address of the encryption key owner */
  signer_address: import_bcs.bcs.Address
} });
const EncryptedUserSecretKeyShareState = new import_utils.MoveEnum({ name: `${$moduleName}::EncryptedUserSecretKeyShareState`, fields: {
  /** Waiting for network to verify the encryption proof */
  AwaitingNetworkVerification: null,
  /** Network has successfully verified the encryption */
  NetworkVerificationCompleted: null,
  /** Network has rejected the encryption verification */
  NetworkVerificationRejected: null,
  /** Key holder has signed and accepted the share */
  KeyHolderSigned: new import_utils.MoveStruct({ name: `EncryptedUserSecretKeyShareState.KeyHolderSigned`, fields: {
    user_output_signature: import_bcs.bcs.vector(import_bcs.bcs.u8())
  } })
} });
const EncryptedUserSecretKeyShare = new import_utils.MoveStruct({ name: `${$moduleName}::EncryptedUserSecretKeyShare`, fields: {
  /** Unique identifier for this encrypted share */
  id: object.UID,
  /** Epoch when this share was created */
  created_at_epoch: import_bcs.bcs.u64(),
  /** ID of the dWallet this share belongs to */
  dwallet_id: import_bcs.bcs.Address,
  /**
   * Encrypted secret share with zero-knowledge proof of correctness for the
   * dWallet's secret key share (of `dwallet_id`).
   */
  encrypted_centralized_secret_share_and_proof: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the encryption key used for encryption */
  encryption_key_id: import_bcs.bcs.Address,
  /** Address of the encryption key owner */
  encryption_key_address: import_bcs.bcs.Address,
  /** Source share ID if this was created via re-encryption (None for DKG-created) */
  source_encrypted_user_secret_key_share_id: import_bcs.bcs.option(import_bcs.bcs.Address),
  /** Current verification and acceptance state */
  state: EncryptedUserSecretKeyShareState
} });
const UnverifiedPartialUserSignatureCap = new import_utils.MoveStruct({ name: `${$moduleName}::UnverifiedPartialUserSignatureCap`, fields: {
  /** Unique identifier for this capability */
  id: object.UID,
  /** ID of the associated partial user signature */
  partial_centralized_signed_message_id: import_bcs.bcs.Address
} });
const VerifiedPartialUserSignatureCap = new import_utils.MoveStruct({ name: `${$moduleName}::VerifiedPartialUserSignatureCap`, fields: {
  /** Unique identifier for this capability */
  id: object.UID,
  /** ID of the associated verified partial user signature */
  partial_centralized_signed_message_id: import_bcs.bcs.Address
} });
const VerifiedPresignCap = new import_utils.MoveStruct({ name: `${$moduleName}::VerifiedPresignCap`, fields: {
  id: object.UID,
  /**
   * Target dWallet ID for dWallet-specific presigns
   *
   * - `Some(id)`: Can only be used with the specified dWallet (e.g. ECDSA
   *   requirement)
   * - `None`: Global presign, can be used with any compatible dWallet (e.g. Schnorr
   *   and EdDSA)
   */
  dwallet_id: import_bcs.bcs.option(import_bcs.bcs.Address),
  /** ID of the associated presign session */
  presign_id: import_bcs.bcs.Address
} });
const PartialUserSignatureState = new import_utils.MoveEnum({ name: `${$moduleName}::PartialUserSignatureState`, fields: {
  AwaitingNetworkVerification: null,
  NetworkVerificationCompleted: null,
  NetworkVerificationRejected: null
} });
const PartialUserSignature = new import_utils.MoveStruct({ name: `${$moduleName}::PartialUserSignature`, fields: {
  /** Unique identifier for this partial signature */
  id: object.UID,
  /** Epoch when this partial signature was created */
  created_at_epoch: import_bcs.bcs.u64(),
  /** Presign capability (consumed to prevent reuse) */
  presign_cap: VerifiedPresignCap,
  /** ID of the dWallet that will complete the signature */
  dwallet_id: import_bcs.bcs.Address,
  /** ID of the capability that controls completion */
  cap_id: import_bcs.bcs.Address,
  /** Cryptographic curve for the signature */
  curve: import_bcs.bcs.u32(),
  /** Signature algorithm to be used */
  signature_algorithm: import_bcs.bcs.u32(),
  /** Hash scheme to apply to the message */
  hash_scheme: import_bcs.bcs.u32(),
  /** Raw message bytes to be signed */
  message: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** User's partial signature on the message */
  message_centralized_signature: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** Current verification state */
  state: PartialUserSignatureState
} });
const DWalletState = new import_utils.MoveEnum({ name: `${$moduleName}::DWalletState`, fields: {
  /** DKG first round has been requested from the network */
  DKGRequested: null,
  /** Network rejected the DKG first round request */
  NetworkRejectedDKGRequest: null,
  /** DKG first round completed, waiting for user to initiate second round */
  AwaitingUserDKGVerificationInitiation: new import_utils.MoveStruct({ name: `DWalletState.AwaitingUserDKGVerificationInitiation`, fields: {
    first_round_output: import_bcs.bcs.vector(import_bcs.bcs.u8())
  } }),
  /** DKG second round has been requested, waiting for network verification */
  AwaitingNetworkDKGVerification: null,
  /** Network rejected the DKG second round verification */
  NetworkRejectedDKGVerification: null,
  /** Imported key verification requested, waiting for network verification */
  AwaitingNetworkImportedKeyVerification: null,
  /** Network rejected the imported key verification */
  NetworkRejectedImportedKeyVerification: null,
  /** DKG/Import completed, waiting for key holder to sign and accept */
  AwaitingKeyHolderSignature: new import_utils.MoveStruct({ name: `DWalletState.AwaitingKeyHolderSignature`, fields: {
    public_output: import_bcs.bcs.vector(import_bcs.bcs.u8())
  } }),
  /** dWallet is fully operational and ready for signing */
  Active: new import_utils.MoveStruct({ name: `DWalletState.Active`, fields: {
    public_output: import_bcs.bcs.vector(import_bcs.bcs.u8())
  } })
} });
const DWallet = new import_utils.MoveStruct({ name: `${$moduleName}::DWallet`, fields: {
  /** Unique identifier for the dWallet */
  id: object.UID,
  /** Epoch when this dWallet was created */
  created_at_epoch: import_bcs.bcs.u64(),
  /** Elliptic curve used for cryptographic operations */
  curve: import_bcs.bcs.u32(),
  /**
   * Public user secret key share (if trust-minimized mode is enabled)
   *
   * - `None`: Zero-trust mode - user participation required for signing
   * - `Some(share)`: Trust-minimized mode - network can sign independently
   */
  public_user_secret_key_share: import_bcs.bcs.option(import_bcs.bcs.vector(import_bcs.bcs.u8())),
  /** ID of the capability that controls this dWallet */
  dwallet_cap_id: import_bcs.bcs.Address,
  /** Network encryption key used for securing this dWallet's network share */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address,
  /** Whether this dWallet was created from an imported key */
  is_imported_key_dwallet: import_bcs.bcs.bool(),
  /**
   * Encrypted user secret key shares (Encryption user secret key share ID ->
   * EncryptedUserSecretKeyShare)
   */
  encrypted_user_secret_key_shares: object_table.ObjectTable,
  /** Signing sessions (Sign ID -> SignSession) */
  sign_sessions: object_table.ObjectTable,
  /** Current state of the dWallet */
  state: DWalletState
} });
const UnverifiedPresignCap = new import_utils.MoveStruct({ name: `${$moduleName}::UnverifiedPresignCap`, fields: {
  id: object.UID,
  /**
   * Target dWallet ID for dWallet-specific presigns
   *
   * - `Some(id)`: Can only be used with the specified dWallet (e.g. ECDSA
   *   requirement)
   * - `None`: Global presign, can be used with any compatible dWallet (e.g. Schnorr
   *   and EdDSA)
   */
  dwallet_id: import_bcs.bcs.option(import_bcs.bcs.Address),
  /** ID of the associated presign session */
  presign_id: import_bcs.bcs.Address
} });
const PresignState = new import_utils.MoveEnum({ name: `${$moduleName}::PresignState`, fields: {
  /** Presign has been requested and is awaiting network processing */
  Requested: null,
  /**
   * Network rejected the presign request (invalid parameters, insufficient
   * resources, etc.)
   */
  NetworkRejected: null,
  /** Presign completed successfully with cryptographic material ready for use */
  Completed: new import_utils.MoveStruct({ name: `PresignState.Completed`, fields: {
    presign: import_bcs.bcs.vector(import_bcs.bcs.u8())
  } })
} });
const PresignSession = new import_utils.MoveStruct({ name: `${$moduleName}::PresignSession`, fields: {
  /** Unique identifier for this presign session */
  id: object.UID,
  /** Epoch when this presign was created */
  created_at_epoch: import_bcs.bcs.u64(),
  /** Elliptic curve used for the presign */
  curve: import_bcs.bcs.u32(),
  /** Signature algorithm this presign supports */
  signature_algorithm: import_bcs.bcs.u32(),
  /**
   * Target dWallet ID (None for global presigns)
   *
   * - `Some(id)`: dWallet-specific presign (e.g. required for ECDSA)
   * - `None`: Global presign (e.g. available for Schnorr, EdDSA)
   */
  dwallet_id: import_bcs.bcs.option(import_bcs.bcs.Address),
  /** ID of the capability that controls this presign */
  cap_id: import_bcs.bcs.Address,
  /** Current state of the presign computation */
  state: PresignState
} });
const SignState = new import_utils.MoveEnum({ name: `${$moduleName}::SignState`, fields: {
  /** Signature has been requested and is awaiting network processing */
  Requested: null,
  /**
   * Network rejected the signature request (invalid presign, unauthorized message,
   * etc.)
   */
  NetworkRejected: null,
  /** Signature completed successfully and ready for use */
  Completed: new import_utils.MoveStruct({ name: `SignState.Completed`, fields: {
    signature: import_bcs.bcs.vector(import_bcs.bcs.u8())
  } })
} });
const SignSession = new import_utils.MoveStruct({ name: `${$moduleName}::SignSession`, fields: {
  id: object.UID,
  /** Epoch when this signing session was initiated */
  created_at_epoch: import_bcs.bcs.u64(),
  /** ID of the dWallet performing the signature */
  dwallet_id: import_bcs.bcs.Address,
  /** Current state of the signing process */
  state: SignState
} });
const MessageApproval = new import_utils.MoveStruct({ name: `${$moduleName}::MessageApproval`, fields: {
  /** ID of the dWallet authorized to sign this message */
  dwallet_id: import_bcs.bcs.Address,
  /** Cryptographic signature algorithm to use */
  signature_algorithm: import_bcs.bcs.u32(),
  /** Hash scheme to apply to the message before signing */
  hash_scheme: import_bcs.bcs.u32(),
  /** Raw message bytes to be signed */
  message: import_bcs.bcs.vector(import_bcs.bcs.u8())
} });
const ImportedKeyMessageApproval = new import_utils.MoveStruct({ name: `${$moduleName}::ImportedKeyMessageApproval`, fields: {
  /** ID of the imported key dWallet authorized to sign this message */
  dwallet_id: import_bcs.bcs.Address,
  /** Cryptographic signature algorithm to use */
  signature_algorithm: import_bcs.bcs.u32(),
  /** Hash scheme to apply to the message before signing */
  hash_scheme: import_bcs.bcs.u32(),
  /** Raw message bytes to be signed */
  message: import_bcs.bcs.vector(import_bcs.bcs.u8())
} });
const SignDuringDKGRequest = new import_utils.MoveStruct({ name: `${$moduleName}::SignDuringDKGRequest`, fields: {
  presign_id: import_bcs.bcs.Address,
  presign: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  curve: import_bcs.bcs.u32(),
  signature_algorithm: import_bcs.bcs.u32(),
  hash_scheme: import_bcs.bcs.u32(),
  message: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  message_centralized_signature: import_bcs.bcs.vector(import_bcs.bcs.u8())
} });
const DWalletNetworkDKGEncryptionKeyRequestEvent = new import_utils.MoveStruct({ name: `${$moduleName}::DWalletNetworkDKGEncryptionKeyRequestEvent`, fields: {
  /** ID of the network encryption key to be generated */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address,
  /** Parameters for the network */
  params_for_network: import_bcs.bcs.vector(import_bcs.bcs.u8())
} });
const CompletedDWalletNetworkDKGEncryptionKeyEvent = new import_utils.MoveStruct({ name: `${$moduleName}::CompletedDWalletNetworkDKGEncryptionKeyEvent`, fields: {
  /** ID of the successfully generated network encryption key */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address
} });
const RejectedDWalletNetworkDKGEncryptionKeyEvent = new import_utils.MoveStruct({ name: `${$moduleName}::RejectedDWalletNetworkDKGEncryptionKeyEvent`, fields: {
  /** ID of the rejected network encryption key */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address
} });
const DWalletEncryptionKeyReconfigurationRequestEvent = new import_utils.MoveStruct({ name: `${$moduleName}::DWalletEncryptionKeyReconfigurationRequestEvent`, fields: {
  /** ID of the network encryption key to be reconfigured */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address
} });
const CompletedDWalletEncryptionKeyReconfigurationEvent = new import_utils.MoveStruct({ name: `${$moduleName}::CompletedDWalletEncryptionKeyReconfigurationEvent`, fields: {
  /** ID of the successfully reconfigured network encryption key */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address
} });
const RejectedDWalletEncryptionKeyReconfigurationEvent = new import_utils.MoveStruct({ name: `${$moduleName}::RejectedDWalletEncryptionKeyReconfigurationEvent`, fields: {
  /** ID of the network encryption key that failed reconfiguration */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address
} });
const DWalletDKGFirstRoundRequestEvent = new import_utils.MoveStruct({ name: `${$moduleName}::DWalletDKGFirstRoundRequestEvent`, fields: {
  /** ID of the dWallet being created */
  dwallet_id: import_bcs.bcs.Address,
  /** ID of the capability that controls the dWallet */
  dwallet_cap_id: import_bcs.bcs.Address,
  /** Network encryption key for securing the dWallet's network share */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address,
  /** Elliptic curve for the dWallet's cryptographic operations */
  curve: import_bcs.bcs.u32()
} });
const CompletedDWalletDKGFirstRoundEvent = new import_utils.MoveStruct({ name: `${$moduleName}::CompletedDWalletDKGFirstRoundEvent`, fields: {
  /** ID of the dWallet being created */
  dwallet_id: import_bcs.bcs.Address,
  /** Public output from the first round of DKG */
  first_round_output: import_bcs.bcs.vector(import_bcs.bcs.u8())
} });
const RejectedDWalletDKGFirstRoundEvent = new import_utils.MoveStruct({ name: `${$moduleName}::RejectedDWalletDKGFirstRoundEvent`, fields: {
  /** ID of the dWallet whose DKG first round was rejected */
  dwallet_id: import_bcs.bcs.Address
} });
const DWalletDKGSecondRoundRequestEvent = new import_utils.MoveStruct({ name: `${$moduleName}::DWalletDKGSecondRoundRequestEvent`, fields: {
  /** ID of the encrypted user secret key share being created */
  encrypted_user_secret_key_share_id: import_bcs.bcs.Address,
  /** ID of the dWallet being created through DKG */
  dwallet_id: import_bcs.bcs.Address,
  /** Cryptographic output from the network's first round of DKG */
  first_round_output: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** User's public key share with cryptographic proof of correctness */
  centralized_public_key_share_and_proof: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the dWallet capability that authorizes this operation */
  dwallet_cap_id: import_bcs.bcs.Address,
  /** User's encrypted secret key share with zero-knowledge proof */
  encrypted_centralized_secret_share_and_proof: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** Serialized encryption key used to encrypt the user's secret share */
  encryption_key: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the encryption key object */
  encryption_key_id: import_bcs.bcs.Address,
  /** Address of the encryption key owner */
  encryption_key_address: import_bcs.bcs.Address,
  /** User's contribution to the DKG public output */
  user_public_output: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** Ed25519 public key for verifying the user's signature */
  signer_public_key: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the network encryption key for securing network shares */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address,
  /** Elliptic curve for the dWallet's cryptographic operations */
  curve: import_bcs.bcs.u32()
} });
const CompletedDWalletDKGSecondRoundEvent = new import_utils.MoveStruct({ name: `${$moduleName}::CompletedDWalletDKGSecondRoundEvent`, fields: {
  /** ID of the successfully created dWallet */
  dwallet_id: import_bcs.bcs.Address,
  /** Complete public output from the DKG process (public key and metadata) */
  public_output: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the user's encrypted secret key share */
  encrypted_user_secret_key_share_id: import_bcs.bcs.Address
} });
const RejectedDWalletDKGSecondRoundEvent = new import_utils.MoveStruct({ name: `${$moduleName}::RejectedDWalletDKGSecondRoundEvent`, fields: {
  /** ID of the dWallet whose DKG second round was rejected */
  dwallet_id: import_bcs.bcs.Address,
  /** Public output that was being processed when rejection occurred */
  public_output: import_bcs.bcs.vector(import_bcs.bcs.u8())
} });
const SignDuringDKGRequestEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SignDuringDKGRequestEvent`, fields: {
  sign_id: import_bcs.bcs.Address,
  presign_id: import_bcs.bcs.Address,
  presign: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  signature_algorithm: import_bcs.bcs.u32(),
  hash_scheme: import_bcs.bcs.u32(),
  message: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  message_centralized_signature: import_bcs.bcs.vector(import_bcs.bcs.u8())
} });
const UserSecretKeyShareEventType = new import_utils.MoveEnum({ name: `${$moduleName}::UserSecretKeyShareEventType`, fields: {
  Encrypted: new import_utils.MoveStruct({ name: `UserSecretKeyShareEventType.Encrypted`, fields: {
    encrypted_user_secret_key_share_id: import_bcs.bcs.Address,
    encrypted_centralized_secret_share_and_proof: import_bcs.bcs.vector(import_bcs.bcs.u8()),
    encryption_key: import_bcs.bcs.vector(import_bcs.bcs.u8()),
    encryption_key_id: import_bcs.bcs.Address,
    encryption_key_address: import_bcs.bcs.Address,
    signer_public_key: import_bcs.bcs.vector(import_bcs.bcs.u8())
  } }),
  Public: new import_utils.MoveStruct({ name: `UserSecretKeyShareEventType.Public`, fields: {
    public_user_secret_key_share: import_bcs.bcs.vector(import_bcs.bcs.u8())
  } })
} });
const DWalletDKGRequestEvent = new import_utils.MoveStruct({ name: `${$moduleName}::DWalletDKGRequestEvent`, fields: {
  /** ID of the dWallet being created through DKG */
  dwallet_id: import_bcs.bcs.Address,
  /** User's public key share with cryptographic proof of correctness */
  centralized_public_key_share_and_proof: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** User's contribution to the DKG public output */
  user_public_output: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the dWallet capability that authorizes this operation */
  dwallet_cap_id: import_bcs.bcs.Address,
  /** ID of the network encryption key for securing network shares */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address,
  /** Elliptic curve for the dWallet's cryptographic operations */
  curve: import_bcs.bcs.u32(),
  /** User's secret key share */
  user_secret_key_share: UserSecretKeyShareEventType,
  /** Sign during DKG request */
  sign_during_dkg_request: import_bcs.bcs.option(SignDuringDKGRequestEvent)
} });
const CompletedDWalletDKGEvent = new import_utils.MoveStruct({ name: `${$moduleName}::CompletedDWalletDKGEvent`, fields: {
  /** ID of the successfully created dWallet */
  dwallet_id: import_bcs.bcs.Address,
  /** Complete public output from the DKG process (public key and metadata) */
  public_output: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the user's encrypted secret key share */
  encrypted_user_secret_key_share_id: import_bcs.bcs.option(import_bcs.bcs.Address),
  /** ID of the user's signature during DKG if it was requested */
  sign_id: import_bcs.bcs.option(import_bcs.bcs.Address)
} });
const RejectedDWalletDKGEvent = new import_utils.MoveStruct({ name: `${$moduleName}::RejectedDWalletDKGEvent`, fields: {
  /** ID of the dWallet whose DKG second round was rejected */
  dwallet_id: import_bcs.bcs.Address,
  /** Public output that was being processed when rejection occurred */
  public_output: import_bcs.bcs.vector(import_bcs.bcs.u8())
} });
const DWalletImportedKeyVerificationRequestEvent = new import_utils.MoveStruct({ name: `${$moduleName}::DWalletImportedKeyVerificationRequestEvent`, fields: {
  /** ID of the imported key dWallet being verified */
  dwallet_id: import_bcs.bcs.Address,
  /** ID of the encrypted user secret key share being created */
  encrypted_user_secret_key_share_id: import_bcs.bcs.Address,
  /** User's cryptographic message for importing computation */
  centralized_party_message: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the imported key dWallet capability */
  dwallet_cap_id: import_bcs.bcs.Address,
  /** User's encrypted secret key share with proof of correctness */
  encrypted_centralized_secret_share_and_proof: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** Serialized encryption key used for user share encryption */
  encryption_key: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the encryption key object */
  encryption_key_id: import_bcs.bcs.Address,
  /** Address of the encryption key owner */
  encryption_key_address: import_bcs.bcs.Address,
  /** User's public key contribution and verification data */
  user_public_output: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /**
   * Ed25519 public key for signature verification, used to verify the user's
   * signature on the public output
   */
  signer_public_key: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the network encryption key for securing network shares */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address,
  /** Elliptic curve for the imported key dWallet */
  curve: import_bcs.bcs.u32()
} });
const CompletedDWalletImportedKeyVerificationEvent = new import_utils.MoveStruct({ name: `${$moduleName}::CompletedDWalletImportedKeyVerificationEvent`, fields: {
  /** ID of the successfully verified imported key dWallet */
  dwallet_id: import_bcs.bcs.Address,
  /** Public output from the verification process */
  public_output: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the user's encrypted secret key share */
  encrypted_user_secret_key_share_id: import_bcs.bcs.Address
} });
const RejectedDWalletImportedKeyVerificationEvent = new import_utils.MoveStruct({ name: `${$moduleName}::RejectedDWalletImportedKeyVerificationEvent`, fields: {
  /** ID of the imported key dWallet that failed verification */
  dwallet_id: import_bcs.bcs.Address
} });
const CreatedEncryptionKeyEvent = new import_utils.MoveStruct({ name: `${$moduleName}::CreatedEncryptionKeyEvent`, fields: {
  /** ID of the newly created encryption key */
  encryption_key_id: import_bcs.bcs.Address,
  /** Address of the encryption key owner */
  signer_address: import_bcs.bcs.Address
} });
const EncryptedShareVerificationRequestEvent = new import_utils.MoveStruct({ name: `${$moduleName}::EncryptedShareVerificationRequestEvent`, fields: {
  /** User's encrypted secret key share with zero-knowledge proof of correctness */
  encrypted_centralized_secret_share_and_proof: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /**
   * Public output of the dWallet (used for verification), this is the public output
   * of the dWallet that the user's share is being encrypted to. This value is taken
   * from the the dWallet object during event creation, and we cannot get it from the
   * user's side.
   */
  public_output: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the dWallet this encrypted share belongs to */
  dwallet_id: import_bcs.bcs.Address,
  /** Serialized encryption key used for the re-encryption */
  encryption_key: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the encryption key object */
  encryption_key_id: import_bcs.bcs.Address,
  /** ID of the new encrypted user secret key share being created */
  encrypted_user_secret_key_share_id: import_bcs.bcs.Address,
  /** ID of the source encrypted share (if this is a re-encryption) */
  source_encrypted_user_secret_key_share_id: import_bcs.bcs.Address,
  /** ID of the network encryption key securing network shares */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address,
  /** Elliptic curve for the dWallet */
  curve: import_bcs.bcs.u32()
} });
const CompletedEncryptedShareVerificationEvent = new import_utils.MoveStruct({ name: `${$moduleName}::CompletedEncryptedShareVerificationEvent`, fields: {
  /** ID of the successfully verified encrypted user secret key share */
  encrypted_user_secret_key_share_id: import_bcs.bcs.Address,
  /** ID of the dWallet associated with this encrypted share */
  dwallet_id: import_bcs.bcs.Address
} });
const RejectedEncryptedShareVerificationEvent = new import_utils.MoveStruct({ name: `${$moduleName}::RejectedEncryptedShareVerificationEvent`, fields: {
  /** ID of the encrypted user secret key share that failed verification */
  encrypted_user_secret_key_share_id: import_bcs.bcs.Address,
  /** ID of the dWallet associated with the failed share */
  dwallet_id: import_bcs.bcs.Address
} });
const AcceptEncryptedUserShareEvent = new import_utils.MoveStruct({ name: `${$moduleName}::AcceptEncryptedUserShareEvent`, fields: {
  /** ID of the accepted encrypted user secret key share */
  encrypted_user_secret_key_share_id: import_bcs.bcs.Address,
  /** ID of the dWallet associated with this share */
  dwallet_id: import_bcs.bcs.Address,
  /** User's signature on the public output proving acceptance */
  user_output_signature: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the encryption key used for this share */
  encryption_key_id: import_bcs.bcs.Address,
  /** Address of the user who accepted the share */
  encryption_key_address: import_bcs.bcs.Address
} });
const MakeDWalletUserSecretKeySharePublicRequestEvent = new import_utils.MoveStruct({ name: `${$moduleName}::MakeDWalletUserSecretKeySharePublicRequestEvent`, fields: {
  /** The user's secret key share to be made public */
  public_user_secret_key_share: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** dWallet's public output for verification */
  public_output: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** Elliptic curve for the dWallet */
  curve: import_bcs.bcs.u32(),
  /** ID of the dWallet being transitioned to trust-minimized mode */
  dwallet_id: import_bcs.bcs.Address,
  /** ID of the network encryption key */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address
} });
const CompletedMakeDWalletUserSecretKeySharePublicEvent = new import_utils.MoveStruct({ name: `${$moduleName}::CompletedMakeDWalletUserSecretKeySharePublicEvent`, fields: {
  /** ID of the dWallet that successfully transitioned to trust-minimized mode */
  dwallet_id: import_bcs.bcs.Address,
  /** The user's secret key share that was made public */
  public_user_secret_key_share: import_bcs.bcs.vector(import_bcs.bcs.u8())
} });
const RejectedMakeDWalletUserSecretKeySharePublicEvent = new import_utils.MoveStruct({ name: `${$moduleName}::RejectedMakeDWalletUserSecretKeySharePublicEvent`, fields: {
  /** ID of the dWallet that failed to transition to trust-minimized mode */
  dwallet_id: import_bcs.bcs.Address
} });
const PresignRequestEvent = new import_utils.MoveStruct({ name: `${$moduleName}::PresignRequestEvent`, fields: {
  /**
     * Target dWallet ID for dWallet-specific presigns
     *
     * - `Some(id)`: dWallet-specific presign (required for ECDSA)
     * - `None`: Global presign (available for Schnorr, EdDSA)
     */
  dwallet_id: import_bcs.bcs.option(import_bcs.bcs.Address),
  /** Unique identifier for this presign session */
  presign_id: import_bcs.bcs.Address,
  /** dWallet's public output for verification (None for global presigns) */
  dwallet_public_output: import_bcs.bcs.option(import_bcs.bcs.vector(import_bcs.bcs.u8())),
  /** ID of the network encryption key securing the presign */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address,
  /** Elliptic curve for the presign computation */
  curve: import_bcs.bcs.u32(),
  /** Signature algorithm for the presign (determines presign type) */
  signature_algorithm: import_bcs.bcs.u32()
} });
const CompletedPresignEvent = new import_utils.MoveStruct({ name: `${$moduleName}::CompletedPresignEvent`, fields: {
  /** Target dWallet ID (None for global presigns) */
  dwallet_id: import_bcs.bcs.option(import_bcs.bcs.Address),
  /** Unique identifier for the completed presign */
  presign_id: import_bcs.bcs.Address,
  /** Precomputed cryptographic material for signature acceleration */
  presign: import_bcs.bcs.vector(import_bcs.bcs.u8())
} });
const RejectedPresignEvent = new import_utils.MoveStruct({ name: `${$moduleName}::RejectedPresignEvent`, fields: {
  /** Target dWallet ID (None for global presigns) */
  dwallet_id: import_bcs.bcs.option(import_bcs.bcs.Address),
  /** ID of the presign that failed generation */
  presign_id: import_bcs.bcs.Address
} });
const SignRequestEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SignRequestEvent`, fields: {
  /** Unique identifier for this signing session */
  sign_id: import_bcs.bcs.Address,
  /** ID of the dWallet performing the signature */
  dwallet_id: import_bcs.bcs.Address,
  /** dWallet's public output for signature verification */
  dwallet_public_output: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** Elliptic curve for the signature */
  curve: import_bcs.bcs.u32(),
  /** Cryptographic signature algorithm */
  signature_algorithm: import_bcs.bcs.u32(),
  /** Hash scheme applied to the message */
  hash_scheme: import_bcs.bcs.u32(),
  /** Raw message bytes to be signed */
  message: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the network encryption key securing network shares */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address,
  /** ID of the presign used for acceleration */
  presign_id: import_bcs.bcs.Address,
  /** Precomputed cryptographic material for fast signing */
  presign: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** User's partial signature on the message */
  message_centralized_signature: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** Whether this uses future sign capabilities */
  is_future_sign: import_bcs.bcs.bool()
} });
const CompletedSignEvent = new import_utils.MoveStruct({ name: `${$moduleName}::CompletedSignEvent`, fields: {
  /** Unique identifier for the completed signing session */
  sign_id: import_bcs.bcs.Address,
  /** Complete cryptographic signature ready for use */
  signature: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** Whether this signature used future sign capabilities */
  is_future_sign: import_bcs.bcs.bool()
} });
const RejectedSignEvent = new import_utils.MoveStruct({ name: `${$moduleName}::RejectedSignEvent`, fields: {
  /** ID of the signing session that failed */
  sign_id: import_bcs.bcs.Address,
  /** Whether this rejection involved future sign capabilities */
  is_future_sign: import_bcs.bcs.bool()
} });
const FutureSignRequestEvent = new import_utils.MoveStruct({ name: `${$moduleName}::FutureSignRequestEvent`, fields: {
  /** ID of the dWallet that will complete the future signature */
  dwallet_id: import_bcs.bcs.Address,
  /** ID of the partial user signature being validated */
  partial_centralized_signed_message_id: import_bcs.bcs.Address,
  /** Message that will be signed when conditions are met */
  message: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** Precomputed cryptographic material for the future signature */
  presign: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** dWallet's public output for verification */
  dwallet_public_output: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** Elliptic curve for the signature */
  curve: import_bcs.bcs.u32(),
  /** Signature algorithm for the future signature */
  signature_algorithm: import_bcs.bcs.u32(),
  /** Hash scheme to be applied to the message */
  hash_scheme: import_bcs.bcs.u32(),
  /** User's partial signature proving authorization */
  message_centralized_signature: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  /** ID of the network encryption key */
  dwallet_network_encryption_key_id: import_bcs.bcs.Address
} });
const CompletedFutureSignEvent = new import_utils.MoveStruct({ name: `${$moduleName}::CompletedFutureSignEvent`, fields: {
  /** ID of the dWallet associated with the future signature */
  dwallet_id: import_bcs.bcs.Address,
  /** ID of the validated partial user signature */
  partial_centralized_signed_message_id: import_bcs.bcs.Address
} });
const RejectedFutureSignEvent = new import_utils.MoveStruct({ name: `${$moduleName}::RejectedFutureSignEvent`, fields: {
  /** ID of the dWallet associated with the failed request */
  dwallet_id: import_bcs.bcs.Address,
  /** ID of the partial user signature that failed validation */
  partial_centralized_signed_message_id: import_bcs.bcs.Address
} });
const DWalletCheckpointInfoEvent = new import_utils.MoveStruct({ name: `${$moduleName}::DWalletCheckpointInfoEvent`, fields: {
  epoch: import_bcs.bcs.u64(),
  sequence_number: import_bcs.bcs.u64()
} });
const SetMaxActiveSessionsBufferEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetMaxActiveSessionsBufferEvent`, fields: {
  max_active_sessions_buffer: import_bcs.bcs.u64()
} });
const SetGasFeeReimbursementSuiSystemCallValueEvent = new import_utils.MoveStruct({ name: `${$moduleName}::SetGasFeeReimbursementSuiSystemCallValueEvent`, fields: {
  gas_fee_reimbursement_sui_system_call_value: import_bcs.bcs.u64()
} });
const EndOfEpochEvent = new import_utils.MoveStruct({ name: `${$moduleName}::EndOfEpochEvent`, fields: {
  epoch: import_bcs.bcs.u64()
} });
function requestDwalletDkgImpl(options) {
  const packageAddress = options.package ?? "@local-pkg/2pc-mpc";
  const argumentsTypes = [
    `${packageAddress}::coordinator_inner::DWalletCoordinatorInner`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID",
    "u32",
    "vector<u8>",
    "vector<u8>",
    `${packageAddress}::coordinator_inner::UserSecretKeyShareEventType`,
    `0x0000000000000000000000000000000000000000000000000000000000000001::option::Option<${packageAddress}::coordinator_inner::SignDuringDKGRequest>`,
    `${packageAddress}::sessions_manager::SessionIdentifier`,
    `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::ika::IKA>`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI>"
  ];
  const parameterNames = ["self", "dwalletNetworkEncryptionKeyId", "curve", "centralizedPublicKeyShareAndProof", "userPublicOutput", "userSecretKeyShare", "signDuringDkgRequest", "sessionIdentifier", "paymentIka", "paymentSui"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "coordinator_inner",
    function: "request_dwallet_dkg_impl",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function dwalletId(options) {
  const packageAddress = options.package ?? "@local-pkg/2pc-mpc";
  const argumentsTypes = [
    `${packageAddress}::coordinator_inner::DWalletCap`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "coordinator_inner",
    function: "dwallet_id",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function importedKeyDwalletId(options) {
  const packageAddress = options.package ?? "@local-pkg/2pc-mpc";
  const argumentsTypes = [
    `${packageAddress}::coordinator_inner::ImportedKeyDWalletCap`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "coordinator_inner",
    function: "imported_key_dwallet_id",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function isImportedKeyDwallet(options) {
  const packageAddress = options.package ?? "@local-pkg/2pc-mpc";
  const argumentsTypes = [
    `${packageAddress}::coordinator_inner::DWallet`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "coordinator_inner",
    function: "is_imported_key_dwallet",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function isDwalletActive(options) {
  const packageAddress = options.package ?? "@local-pkg/2pc-mpc";
  const argumentsTypes = [
    `${packageAddress}::coordinator_inner::DWallet`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "coordinator_inner",
    function: "is_dwallet_active",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function dwalletNetworkEncryptionKeyId(options) {
  const packageAddress = options.package ?? "@local-pkg/2pc-mpc";
  const argumentsTypes = [
    `${packageAddress}::coordinator_inner::DWallet`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "coordinator_inner",
    function: "dwallet_network_encryption_key_id",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function curve(options) {
  const packageAddress = options.package ?? "@local-pkg/2pc-mpc";
  const argumentsTypes = [
    `${packageAddress}::coordinator_inner::DWallet`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "coordinator_inner",
    function: "curve",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function validateActiveAndGetPublicOutput(options) {
  const packageAddress = options.package ?? "@local-pkg/2pc-mpc";
  const argumentsTypes = [
    `${packageAddress}::coordinator_inner::DWallet`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "coordinator_inner",
    function: "validate_active_and_get_public_output",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function hasSignSession(options) {
  const packageAddress = options.package ?? "@local-pkg/2pc-mpc";
  const argumentsTypes = [
    `${packageAddress}::coordinator_inner::DWallet`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "signId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "coordinator_inner",
    function: "has_sign_session",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function getSignSession(options) {
  const packageAddress = options.package ?? "@local-pkg/2pc-mpc";
  const argumentsTypes = [
    `${packageAddress}::coordinator_inner::DWallet`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::object::ID"
  ];
  const parameterNames = ["self", "signId"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "coordinator_inner",
    function: "get_sign_session",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
function getSignSignature(options) {
  const packageAddress = options.package ?? "@local-pkg/2pc-mpc";
  const argumentsTypes = [
    `${packageAddress}::coordinator_inner::SignSession`
  ];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "coordinator_inner",
    function: "get_sign_signature",
    arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes, parameterNames)
  });
}
//# sourceMappingURL=coordinator_inner.js.map
