"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var ika_client_exports = {};
__export(ika_client_exports, {
  IkaClient: () => IkaClient
});
module.exports = __toCommonJS(ika_client_exports);
var import_transactions = require("@mysten/sui/transactions");
var import_utils = require("@mysten/sui/utils");
var CoordinatorInnerModule = __toESM(require("../generated/ika_dwallet_2pc_mpc/coordinator_inner.js"));
var CoordinatorModule = __toESM(require("../generated/ika_dwallet_2pc_mpc/coordinator.js"));
var import_table_vec = require("../generated/ika_system/deps/sui/table_vec.js");
var SystemModule = __toESM(require("../generated/ika_system/system.js"));
var import_coordinator = require("../tx/coordinator.js");
var import_cryptography = require("./cryptography.js");
var import_errors = require("./errors.js");
var import_hash_signature_validation = require("./hash-signature-validation.js");
var import_types = require("./types.js");
var import_utils2 = require("./utils.js");
var _IkaClient_instances, getObjects_fn, fetchObjectsFromNetwork_fn, fetchEncryptionKeys_fn, fetchEncryptionKeysFromNetwork_fn, processBatchedObjects_fn, getCacheKey_fn, getDWalletKind_fn, pollUntilCondition_fn, pollUntilState_fn;
class IkaClient {
  /**
   * Creates a new IkaClient instance
   *
   * @param options - Configuration options for the client
   * @param options.suiClient - The Sui client instance to use for blockchain interactions
   * @param options.config - The Ika network configuration
   * @param options.cache - Whether to enable caching (default: true)
   */
  constructor({ suiClient, config, cache = true, encryptionKeyOptions }) {
    __privateAdd(this, _IkaClient_instances);
    /** The Ika network configuration including package IDs and object references */
    __publicField(this, "ikaConfig");
    /** Default encryption key options for the client */
    __publicField(this, "encryptionKeyOptions");
    /** The underlying Sui client for blockchain interactions */
    __publicField(this, "client");
    /** Whether to enable caching of network objects and parameters */
    __publicField(this, "cache");
    /** Cached network public parameters by encryption key ID and curve to avoid repeated fetching */
    __publicField(this, "cachedProtocolPublicParameters", /* @__PURE__ */ new Map());
    /** Cached network objects (coordinator and system inner objects) - separate from encryption keys */
    __publicField(this, "cachedObjects");
    /** Cached encryption keys by ID for efficient access */
    __publicField(this, "cachedEncryptionKeys", /* @__PURE__ */ new Map());
    /** Promise for ongoing object fetching to prevent duplicate requests */
    __publicField(this, "objectsPromise");
    /** Promise for ongoing encryption key fetching to prevent duplicate requests */
    __publicField(this, "encryptionKeysPromise");
    this.client = suiClient;
    this.ikaConfig = config;
    this.cache = cache;
    this.encryptionKeyOptions = encryptionKeyOptions || { autoDetect: true };
  }
  /**
   * Invalidate all cached data including objects and public parameters.
   * This forces the client to refetch data on the next request.
   */
  invalidateCache() {
    this.cachedObjects = void 0;
    this.cachedProtocolPublicParameters.clear();
    this.objectsPromise = void 0;
    this.cachedEncryptionKeys.clear();
    this.encryptionKeysPromise = void 0;
  }
  /**
   * Invalidate only the cached objects (coordinator and system inner objects).
   * Public parameters and encryption key caches are preserved.
   */
  invalidateObjectCache() {
    this.cachedObjects = void 0;
    this.objectsPromise = void 0;
  }
  /**
   * Invalidate only the cached encryption keys.
   * Network objects and public parameters caches are preserved.
   */
  invalidateEncryptionKeyCache() {
    this.cachedEncryptionKeys.clear();
    this.encryptionKeysPromise = void 0;
  }
  /**
   * Invalidate cached protocol public parameters for a specific encryption key and/or curve.
   * If no parameters are provided, clears all cached protocol parameters.
   * If only encryptionKeyID is provided, clears all curves for that key.
   * If both are provided, clears only that specific combination.
   *
   * @param encryptionKeyID - Optional specific encryption key ID to invalidate
   * @param curve - Optional specific curve to invalidate
   */
  invalidateProtocolPublicParametersCache(encryptionKeyID, curve) {
    if (encryptionKeyID !== void 0 && curve !== void 0) {
      this.cachedProtocolPublicParameters.delete(__privateMethod(this, _IkaClient_instances, getCacheKey_fn).call(this, encryptionKeyID, curve));
    } else if (encryptionKeyID !== void 0) {
      for (const key of this.cachedProtocolPublicParameters.keys()) {
        if (key.startsWith(`${encryptionKeyID}-`)) {
          this.cachedProtocolPublicParameters.delete(key);
        }
      }
    } else {
      this.cachedProtocolPublicParameters.clear();
    }
  }
  /**
   * Initialize the client by fetching and caching network objects.
   * This method should be called before using other client methods.
   *
   * @returns Promise that resolves when initialization is complete
   */
  async initialize() {
    await this.ensureInitialized();
  }
  /**
   * Ensure the client is initialized with core network objects.
   * This method handles caching and prevents duplicate initialization requests.
   *
   * @returns Promise resolving to the core network objects
   * @throws {NetworkError} If initialization fails
   * @private
   */
  async ensureInitialized() {
    if (!this.cache) {
      return __privateMethod(this, _IkaClient_instances, getObjects_fn).call(this);
    }
    if (this.cachedObjects) {
      return this.cachedObjects;
    }
    if (this.objectsPromise) {
      await this.objectsPromise;
      return this.cachedObjects;
    }
    await __privateMethod(this, _IkaClient_instances, getObjects_fn).call(this);
    return this.cachedObjects;
  }
  /**
   * Get all available network encryption keys.
   * This method fetches and caches all encryption keys for efficient access.
   *
   * @returns Promise resolving to an array of all network encryption keys
   * @throws {NetworkError} If the encryption keys cannot be fetched
   */
  async getAllNetworkEncryptionKeys() {
    if (!this.cache) {
      return __privateMethod(this, _IkaClient_instances, fetchEncryptionKeys_fn).call(this);
    }
    if (this.cachedEncryptionKeys.size > 0) {
      return Array.from(this.cachedEncryptionKeys.values());
    }
    if (this.encryptionKeysPromise) {
      await this.encryptionKeysPromise;
      return Array.from(this.cachedEncryptionKeys.values());
    }
    await __privateMethod(this, _IkaClient_instances, fetchEncryptionKeys_fn).call(this);
    return Array.from(this.cachedEncryptionKeys.values());
  }
  /**
   * Get the latest network encryption key.
   * This is the most recent encryption key created for the network.
   *
   * @returns Promise resolving to the latest network encryption key
   * @throws {NetworkError} If the encryption keys cannot be fetched
   */
  async getLatestNetworkEncryptionKey() {
    const keys = await this.getAllNetworkEncryptionKeys();
    if (keys.length === 0) {
      throw new import_errors.NetworkError("No network encryption keys found");
    }
    return keys[keys.length - 1];
  }
  /**
   * Get a specific network encryption key by ID.
   *
   * @param encryptionKeyID - The ID of the encryption key to retrieve
   * @returns Promise resolving to the specified network encryption key
   * @throws {ObjectNotFoundError} If the encryption key is not found
   * @throws {NetworkError} If the encryption keys cannot be fetched
   */
  async getNetworkEncryptionKey(encryptionKeyID) {
    const keys = await this.getAllNetworkEncryptionKeys();
    const key = keys.find((k) => k.id === encryptionKeyID);
    if (!key) {
      throw new import_errors.ObjectNotFoundError(`Network encryption key ${encryptionKeyID} not found`);
    }
    return key;
  }
  /**
   * Get the network encryption key used by a specific dWallet.
   * This method automatically detects which encryption key the dWallet uses.
   *
   * @param dwalletID - The ID of the dWallet to check
   * @returns Promise resolving to the network encryption key used by the dWallet
   * @throws {InvalidObjectError} If the dWallet cannot be parsed
   * @throws {NetworkError} If the network request fails
   */
  async getDWalletNetworkEncryptionKey(dwalletID) {
    const dWallet = await this.getDWallet(dwalletID);
    const encryptionKeyID = dWallet.dwallet_network_encryption_key_id;
    return this.getNetworkEncryptionKey(encryptionKeyID);
  }
  /**
   * Get the network encryption key based on client configuration.
   * This method respects the client's encryption key options.
   *
   * @returns Promise resolving to the appropriate network encryption key
   * @throws {NetworkError} If the encryption keys cannot be fetched
   */
  async getConfiguredNetworkEncryptionKey() {
    if (this.encryptionKeyOptions.encryptionKeyID) {
      return this.getNetworkEncryptionKey(this.encryptionKeyOptions.encryptionKeyID);
    }
    return this.getLatestNetworkEncryptionKey();
  }
  /**
   * Retrieve a DWallet object by its ID.
   *
   * @param dwalletID - The unique identifier of the DWallet to retrieve
   * @returns Promise resolving to the DWallet object
   * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
   * @throws {NetworkError} If the network request fails
   */
  async getDWallet(dwalletID) {
    await this.ensureInitialized();
    return this.client.getObject({
      id: dwalletID,
      options: { showBcs: true }
    }).then((obj) => {
      const dWallet = CoordinatorInnerModule.DWallet.fromBase64((0, import_utils2.objResToBcs)(obj));
      return {
        ...dWallet,
        kind: __privateMethod(this, _IkaClient_instances, getDWalletKind_fn).call(this, dWallet)
      };
    });
  }
  async getDWalletInParticularState(dwalletID, state, options = {}) {
    return __privateMethod(this, _IkaClient_instances, pollUntilState_fn).call(this, () => this.getDWallet(dwalletID), state, `DWallet ${dwalletID} to reach state ${state}`, options);
  }
  /**
   * Retrieve a presign session object by its ID.
   *
   * @param presignID - The unique identifier of the presign session to retrieve
   * @returns Promise resolving to the Presign object
   * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
   * @throws {NetworkError} If the network request fails
   */
  async getPresign(presignID) {
    await this.ensureInitialized();
    return this.client.getObject({
      id: presignID,
      options: { showBcs: true }
    }).then((obj) => {
      return CoordinatorInnerModule.PresignSession.fromBase64((0, import_utils2.objResToBcs)(obj));
    });
  }
  async getPresignInParticularState(presignID, state, options = {}) {
    return __privateMethod(this, _IkaClient_instances, pollUntilState_fn).call(this, () => this.getPresign(presignID), state, `presign ${presignID} to reach state ${state}`, options);
  }
  /**
   * Retrieve an encrypted user secret key share object by its ID.
   *
   * @param encryptedUserSecretKeyShareID - The unique identifier of the encrypted share to retrieve
   * @returns Promise resolving to the EncryptedUserSecretKeyShare object
   * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
   * @throws {NetworkError} If the network request fails
   */
  async getEncryptedUserSecretKeyShare(encryptedUserSecretKeyShareID) {
    await this.ensureInitialized();
    return this.client.getObject({
      id: encryptedUserSecretKeyShareID,
      options: { showBcs: true }
    }).then((obj) => {
      return CoordinatorInnerModule.EncryptedUserSecretKeyShare.fromBase64((0, import_utils2.objResToBcs)(obj));
    });
  }
  async getEncryptedUserSecretKeyShareInParticularState(encryptedUserSecretKeyShareID, state, options = {}) {
    return __privateMethod(this, _IkaClient_instances, pollUntilState_fn).call(this, () => this.getEncryptedUserSecretKeyShare(encryptedUserSecretKeyShareID), state, `encrypted user secret key share ${encryptedUserSecretKeyShareID} to reach state ${state}`, options);
  }
  /**
   * Retrieve a partial user signature object by its ID.
   *
   * @param partialCentralizedSignedMessageID - The unique identifier of the partial signature to retrieve
   * @returns Promise resolving to the PartialUserSignature object
   * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
   * @throws {NetworkError} If the network request fails
   */
  async getPartialUserSignature(partialCentralizedSignedMessageID) {
    await this.ensureInitialized();
    return this.client.getObject({
      id: partialCentralizedSignedMessageID,
      options: { showBcs: true }
    }).then((obj) => {
      return CoordinatorInnerModule.PartialUserSignature.fromBase64((0, import_utils2.objResToBcs)(obj));
    });
  }
  async getPartialUserSignatureInParticularState(partialCentralizedSignedMessageID, state, options = {}) {
    return __privateMethod(this, _IkaClient_instances, pollUntilState_fn).call(this, () => this.getPartialUserSignature(partialCentralizedSignedMessageID), state, `partial user signature ${partialCentralizedSignedMessageID} to reach state ${state}`, options);
  }
  /**
   * Retrieve a sign session object by its ID.
   *
   * @param signID - The unique identifier of the sign session to retrieve
   * @param curve - The curve to use for parsing
   * @param signatureAlgorithm - The signature algorithm to use for parsing (must be valid for the curve)
   *
   * @returns Promise resolving to the Sign object
   * @throws {InvalidObjectError} If the object cannot be parsed or is invalid
   * @throws {NetworkError} If the network request fails
   */
  async getSign(signID, curve, signatureAlgorithm) {
    await this.ensureInitialized();
    (0, import_hash_signature_validation.validateCurveSignatureAlgorithm)(curve, signatureAlgorithm);
    const unparsedSign = await this.client.getObject({
      id: signID,
      options: { showBcs: true }
    });
    const sign = CoordinatorInnerModule.SignSession.fromBase64((0, import_utils2.objResToBcs)(unparsedSign));
    if (sign.state.$kind === "Completed") {
      sign.state.Completed.signature = Array.from(
        await (0, import_cryptography.parseSignatureFromSignOutput)(
          curve,
          signatureAlgorithm,
          Uint8Array.from(sign.state.Completed.signature)
        )
      );
    }
    return sign;
  }
  async getSignInParticularState(signID, curve, signatureAlgorithm, state, options = {}) {
    return __privateMethod(this, _IkaClient_instances, pollUntilState_fn).call(this, () => this.getSign(signID, curve, signatureAlgorithm), state, `sign ${signID} to reach state ${state}`, options);
  }
  /**
   * Retrieve multiple DWallet objects by their IDs in a single batch request.
   * This is more efficient than making individual requests for multiple DWallets.
   *
   * @param dwalletIDs - Array of unique identifiers for the DWallets to retrieve
   * @returns Promise resolving to an array of DWallet objects
   * @throws {InvalidObjectError} If any object cannot be parsed or is invalid
   * @throws {NetworkError} If the network request fails
   */
  async getMultipleDWallets(dwalletIDs) {
    await this.ensureInitialized();
    return this.client.multiGetObjects({
      ids: dwalletIDs,
      options: { showBcs: true }
    }).then((objs) => {
      return objs.map((obj) => {
        const dWallet = CoordinatorInnerModule.DWallet.fromBase64((0, import_utils2.objResToBcs)(obj));
        return {
          ...dWallet,
          kind: __privateMethod(this, _IkaClient_instances, getDWalletKind_fn).call(this, dWallet)
        };
      });
    });
  }
  /**
   * Retrieve DWallet capabilities owned by a specific address.
   * DWallet capabilities grant the holder permission to use the associated DWallet.
   *
   * @param address - The Sui address to query for owned DWallet capabilities
   * @param cursor - Optional cursor for pagination (from previous request)
   * @param limit - Optional limit on the number of results to return
   * @returns Promise resolving to paginated results containing DWallet capabilities
   * @throws {InvalidObjectError} If any object cannot be parsed or is invalid
   * @throws {NetworkError} If the network request fails
   */
  async getOwnedDWalletCaps(address, cursor, limit) {
    await this.ensureInitialized();
    const response = await this.client.getOwnedObjects({
      owner: address,
      filter: {
        StructType: `${this.ikaConfig.packages.ikaDwallet2pcMpcOriginalPackage}::coordinator_inner::DWalletCap`
      },
      options: {
        showBcs: true
      },
      cursor,
      limit
    });
    return {
      dWalletCaps: response.data.map(
        (obj) => CoordinatorInnerModule.DWalletCap.fromBase64((0, import_utils2.objResToBcs)(obj))
      ),
      cursor: response.nextCursor,
      hasNextPage: response.hasNextPage
    };
  }
  /**
   * Get cached protocol public parameters for a specific encryption key and curve.
   * Returns undefined if not cached or if the cache is invalid.
   *
   * @param encryptionKeyID - The ID of the encryption key to get cached parameters for
   * @param curve - The curve to get cached parameters for
   * @returns Cached protocol public parameters or undefined if not cached
   */
  getCachedProtocolPublicParameters(encryptionKeyID, curve) {
    const cacheKey = __privateMethod(this, _IkaClient_instances, getCacheKey_fn).call(this, encryptionKeyID, curve);
    const cachedParams = this.cachedProtocolPublicParameters.get(cacheKey);
    if (!cachedParams) {
      return void 0;
    }
    const currentKey = this.cachedEncryptionKeys.get(encryptionKeyID);
    if (!currentKey) {
      return void 0;
    }
    if (cachedParams.networkEncryptionKeyPublicOutputID === currentKey.networkDKGOutputID && cachedParams.epoch === currentKey.epoch && cachedParams.curve === curve) {
      return cachedParams.protocolPublicParameters;
    }
    this.cachedProtocolPublicParameters.delete(cacheKey);
    return void 0;
  }
  /**
   * Check if protocol public parameters are cached for a specific encryption key and curve.
   *
   * @param encryptionKeyID - The ID of the encryption key to check
   * @param curve - The curve to check
   * @returns True if valid cached parameters exist, false otherwise
   */
  isProtocolPublicParametersCached(encryptionKeyID, curve) {
    return this.getCachedProtocolPublicParameters(encryptionKeyID, curve) !== void 0;
  }
  /**
   * Get the current encryption key options for the client.
   *
   * @returns The current encryption key options
   */
  getEncryptionKeyOptions() {
    return { ...this.encryptionKeyOptions };
  }
  /**
   * Set the encryption key options for the client.
   * This affects all subsequent calls to methods that use encryption keys.
   *
   * @param options - The new encryption key options
   */
  setEncryptionKeyOptions(options) {
    this.encryptionKeyOptions = { ...options };
  }
  /**
   * Set a specific encryption key ID to use for all operations.
   * This is a convenience method for setting just the encryption key ID.
   *
   * @param encryptionKeyID - The encryption key ID to use
   */
  setEncryptionKeyID(encryptionKeyID) {
    this.encryptionKeyOptions = { ...this.encryptionKeyOptions, encryptionKeyID };
  }
  /**
   * Retrieve the protocol public parameters used for cryptographic operations.
   * These parameters are cached by encryption key ID and only refetched when the epoch or decryption key changes.
   *
   * @param dWallet - The DWallet to get the protocol public parameters for
   * @param curve - The curve to use for key generation
   * @returns Promise resolving to the protocol public parameters as bytes
   * @throws {ObjectNotFoundError} If the public parameters cannot be found
   * @throws {NetworkError} If the network request fails
   */
  async getProtocolPublicParameters(dWallet, curve) {
    await __privateMethod(this, _IkaClient_instances, fetchEncryptionKeysFromNetwork_fn).call(this);
    let networkEncryptionKey;
    if (dWallet) {
      networkEncryptionKey = await this.getDWalletNetworkEncryptionKey(dWallet.id.id);
    } else {
      networkEncryptionKey = await this.getConfiguredNetworkEncryptionKey();
    }
    const encryptionKeyID = networkEncryptionKey.id;
    const networkEncryptionKeyPublicOutputID = networkEncryptionKey.networkDKGOutputID;
    const epoch = networkEncryptionKey.epoch;
    let selectedCurve;
    if (dWallet) {
      selectedCurve = (0, import_hash_signature_validation.fromNumberToCurve)(dWallet.curve);
    } else {
      selectedCurve = curve !== void 0 ? curve : (0, import_hash_signature_validation.fromNumberToCurve)(0);
    }
    const cacheKey = __privateMethod(this, _IkaClient_instances, getCacheKey_fn).call(this, encryptionKeyID, selectedCurve);
    const cachedParams = this.cachedProtocolPublicParameters.get(cacheKey);
    if (cachedParams) {
      if (cachedParams.networkEncryptionKeyPublicOutputID === networkEncryptionKeyPublicOutputID && cachedParams.epoch === epoch && cachedParams.curve === selectedCurve) {
        return cachedParams.protocolPublicParameters;
      }
    }
    const protocolPublicParameters = !networkEncryptionKey.reconfigurationOutputID ? await (0, import_cryptography.networkDkgPublicOutputToProtocolPublicParameters)(
      selectedCurve,
      await this.readTableVecAsRawBytes(networkEncryptionKeyPublicOutputID)
    ) : await (0, import_cryptography.reconfigurationPublicOutputToProtocolPublicParameters)(
      selectedCurve,
      await this.readTableVecAsRawBytes(networkEncryptionKey.reconfigurationOutputID),
      await this.readTableVecAsRawBytes(networkEncryptionKeyPublicOutputID)
    );
    this.cachedProtocolPublicParameters.set(cacheKey, {
      networkEncryptionKeyPublicOutputID,
      epoch,
      curve: selectedCurve,
      protocolPublicParameters
    });
    return protocolPublicParameters;
  }
  /**
   * Get the active encryption key for a specific address.
   * This key is used for encrypting user shares and other cryptographic operations.
   *
   * @param address - The Sui address to get the encryption key for
   * @returns Promise resolving to the EncryptionKey object
   * @throws {InvalidObjectError} If the encryption key object cannot be parsed
   * @throws {NetworkError} If the network request fails
   */
  async getActiveEncryptionKey(address) {
    await this.ensureInitialized();
    const tx = new import_transactions.Transaction();
    (0, import_coordinator.getActiveEncryptionKey)(
      this.ikaConfig,
      tx.sharedObjectRef({
        objectId: this.ikaConfig.objects.ikaDWalletCoordinator.objectID,
        initialSharedVersion: this.ikaConfig.objects.ikaDWalletCoordinator.initialSharedVersion,
        mutable: true
      }),
      address,
      tx
    );
    const res = await this.client.devInspectTransactionBlock({
      sender: address,
      transactionBlock: tx
    });
    const objIDArray = new Uint8Array(res.results?.at(0)?.returnValues?.at(0)?.at(0));
    const objID = (0, import_utils.toHex)(objIDArray);
    const obj = await this.client.getObject({
      id: objID,
      options: { showBcs: true }
    });
    return CoordinatorInnerModule.EncryptionKey.fromBase64((0, import_utils2.objResToBcs)(obj));
  }
  /**
   * Get the current network epoch number.
   * The epoch is used for versioning and determining when to refresh cached parameters.
   *
   * @returns Promise resolving to the current epoch number
   * @throws {NetworkError} If the network objects cannot be fetched
   */
  async getEpoch() {
    const objects = await this.ensureInitialized();
    return Number(objects.coordinatorInner.current_epoch);
  }
  /**
   * Read a table vector as raw bytes from the blockchain.
   * This method handles paginated dynamic field retrieval and assembles the data in order.
   *
   * @param tableID - The ID of the table object to read
   * @returns Promise resolving to the concatenated raw bytes from the table
   * @throws {ObjectNotFoundError} If the table or its dynamic fields are not found
   * @throws {InvalidObjectError} If table indices are invalid
   * @throws {NetworkError} If network requests fail
   * @private
   */
  async readTableVecAsRawBytes(tableID) {
    try {
      let cursor = null;
      const allTableRows = [];
      do {
        const dynamicFieldPage = await this.client.getDynamicFields({
          parentId: tableID,
          cursor
        });
        if (!dynamicFieldPage?.data?.length) {
          if (allTableRows.length === 0) {
            throw new import_errors.ObjectNotFoundError("Dynamic fields", tableID);
          }
          break;
        }
        allTableRows.push(...dynamicFieldPage.data);
        cursor = dynamicFieldPage.nextCursor;
        if (!dynamicFieldPage.hasNextPage) {
          break;
        }
      } while (cursor);
      const dataMap = /* @__PURE__ */ new Map();
      const objectIds = new Set(allTableRows.map((tableRowResult) => tableRowResult.objectId));
      await __privateMethod(this, _IkaClient_instances, processBatchedObjects_fn).call(this, [...objectIds], ({ objectId, fields }) => {
        const tableIndex = parseInt(fields.name);
        if (isNaN(tableIndex)) {
          throw new import_errors.InvalidObjectError("Table index (expected numeric name)", objectId);
        }
        dataMap.set(tableIndex, fields.value);
      });
      const indices = Array.from(dataMap.keys()).sort((a, b) => a - b);
      if (indices.length === 0) {
        throw new import_errors.ObjectNotFoundError("No table chunks found", tableID);
      }
      const orderedChunks = indices.map((idx) => dataMap.get(idx)).filter((chunk) => !!chunk);
      const totalLength = orderedChunks.reduce((acc, arr) => acc + arr.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of orderedChunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      return result;
    } catch (error) {
      if (error instanceof import_errors.InvalidObjectError || error instanceof import_errors.ObjectNotFoundError || error instanceof import_errors.NetworkError) {
        throw error;
      }
      throw new import_errors.NetworkError(
        `Failed to read table vector as raw bytes: ${tableID}`,
        error
      );
    }
  }
}
_IkaClient_instances = new WeakSet();
getObjects_fn = async function() {
  if (this.cachedObjects) {
    return {
      coordinatorInner: this.cachedObjects.coordinatorInner,
      systemInner: this.cachedObjects.systemInner
    };
  }
  if (this.objectsPromise) {
    return this.objectsPromise;
  }
  this.objectsPromise = __privateMethod(this, _IkaClient_instances, fetchObjectsFromNetwork_fn).call(this);
  try {
    const result = await this.objectsPromise;
    this.cachedObjects = {
      coordinatorInner: result.coordinatorInner,
      systemInner: result.systemInner
    };
    return result;
  } catch (error) {
    this.objectsPromise = void 0;
    throw error;
  }
};
fetchObjectsFromNetwork_fn = async function() {
  try {
    const [coordinator, system] = await this.client.multiGetObjects({
      ids: [
        this.ikaConfig.objects.ikaDWalletCoordinator.objectID,
        this.ikaConfig.objects.ikaSystemObject.objectID
      ],
      options: { showBcs: true, showOwner: true }
    });
    const coordinatorParsed = CoordinatorModule.DWalletCoordinator.fromBase64(
      (0, import_utils2.objResToBcs)(coordinator)
    );
    const systemParsed = SystemModule.System.fromBase64((0, import_utils2.objResToBcs)(system));
    const [coordinatorDFs, systemDFs] = await Promise.all([
      this.client.getDynamicFields({
        parentId: coordinatorParsed.id.id
      }),
      this.client.getDynamicFields({
        parentId: systemParsed.id.id
      })
    ]);
    if (!coordinatorDFs.data?.length || !systemDFs.data?.length) {
      throw new import_errors.ObjectNotFoundError("Dynamic fields for coordinator or system");
    }
    const coordinatorInnerDF = coordinatorDFs.data[coordinatorDFs.data.length - 1];
    const systemInnerDF = systemDFs.data[systemDFs.data.length - 1];
    const [coordinatorInner, systemInner] = await this.client.multiGetObjects({
      ids: [coordinatorInnerDF.objectId, systemInnerDF.objectId],
      options: { showBcs: true }
    });
    const coordinatorInnerParsed = import_types.CoordinatorInnerDynamicField.fromBase64(
      (0, import_utils2.objResToBcs)(coordinatorInner)
    ).value;
    const systemInnerParsed = import_types.SystemInnerDynamicField.fromBase64((0, import_utils2.objResToBcs)(systemInner)).value;
    this.ikaConfig.packages.ikaSystemPackage = systemParsed.package_id;
    this.ikaConfig.packages.ikaDwallet2pcMpcPackage = coordinatorParsed.package_id;
    this.ikaConfig.objects.ikaSystemObject.initialSharedVersion = system.data?.owner?.Shared?.initial_shared_version ?? 0;
    this.ikaConfig.objects.ikaDWalletCoordinator.initialSharedVersion = coordinator.data?.owner?.Shared?.initial_shared_version ?? 0;
    return {
      coordinatorInner: coordinatorInnerParsed,
      systemInner: systemInnerParsed
    };
  } catch (error) {
    if (error instanceof import_errors.InvalidObjectError || error instanceof import_errors.ObjectNotFoundError) {
      throw error;
    }
    throw new import_errors.NetworkError("Failed to fetch objects", error);
  }
};
fetchEncryptionKeys_fn = async function() {
  if (this.encryptionKeysPromise) {
    return this.encryptionKeysPromise;
  }
  this.encryptionKeysPromise = __privateMethod(this, _IkaClient_instances, fetchEncryptionKeysFromNetwork_fn).call(this);
  try {
    const result = await this.encryptionKeysPromise;
    return result;
  } catch (error) {
    this.encryptionKeysPromise = void 0;
    throw error;
  }
};
fetchEncryptionKeysFromNetwork_fn = async function() {
  try {
    const objects = await this.ensureInitialized();
    const keysDFs = await this.client.getDynamicFields({
      parentId: objects.coordinatorInner.dwallet_network_encryption_keys.id.id
    });
    if (!keysDFs.data?.length) {
      throw new import_errors.ObjectNotFoundError("Network encryption keys");
    }
    const encryptionKeys = [];
    for (const keyDF of keysDFs.data) {
      const keyName = keyDF.name.value;
      const keyObject = await this.client.getObject({
        id: keyDF.objectId,
        options: { showBcs: true }
      });
      const keyParsed = CoordinatorInnerModule.DWalletNetworkEncryptionKey.fromBase64(
        (0, import_utils2.objResToBcs)(keyObject)
      );
      const reconfigOutputsDFs = await (0, import_utils2.fetchAllDynamicFields)(
        this.client,
        keyParsed.reconfiguration_public_outputs.id.id
      );
      const lastReconfigOutput = (await Promise.all(
        reconfigOutputsDFs.map(async (df) => {
          const name = df.name.value;
          const reconfigObject = await this.client.getObject({
            id: df.objectId,
            options: { showBcs: true }
          });
          const parsedValue = (0, import_types.DynamicField)(import_table_vec.TableVec).fromBase64((0, import_utils2.objResToBcs)(reconfigObject));
          return {
            name,
            parsedValue
          };
        })
      )).sort((a, b) => Number(a.name) - Number(b.name)).at(-2);
      const encryptionKey = {
        id: keyName,
        epoch: Number(keyParsed.dkg_at_epoch),
        networkDKGOutputID: keyParsed.network_dkg_public_output.contents.id.id,
        reconfigurationOutputID: lastReconfigOutput?.parsedValue.value.contents.id.id
      };
      encryptionKeys.push(encryptionKey);
      this.cachedEncryptionKeys.set(keyName, encryptionKey);
    }
    encryptionKeys.sort((a, b) => a.epoch - b.epoch);
    return encryptionKeys;
  } catch (error) {
    if (error instanceof import_errors.InvalidObjectError || error instanceof import_errors.ObjectNotFoundError) {
      throw error;
    }
    throw new import_errors.NetworkError("Failed to fetch encryption keys", error);
  }
};
processBatchedObjects_fn = async function(objectIds, processor) {
  const batchSize = 50;
  try {
    const results = [];
    for (let i = 0; i < objectIds.length; i += batchSize) {
      const batchIds = objectIds.slice(i, i + batchSize);
      const dynFields = await this.client.multiGetObjects({
        ids: batchIds,
        options: { showContent: true }
      });
      for (const dynField of dynFields) {
        if (dynField.error) {
          const errorInfo = "object_id" in dynField.error ? `object ${dynField.error.object_id}` : "unknown object";
          throw new import_errors.NetworkError(`Failed to fetch ${errorInfo}: ${dynField.error.code}`);
        }
        const objectIdForError = dynField.data?.objectId;
        const content = dynField.data?.content;
        if (!content || content.dataType !== "moveObject") {
          throw new import_errors.InvalidObjectError("Object content (expected moveObject)", objectIdForError);
        }
        const fields = content.fields;
        if (!fields) {
          throw new import_errors.InvalidObjectError("Object content.fields missing", objectIdForError);
        }
        const name = typeof fields.name === "string" ? fields.name : String(fields.name);
        const value = fields.value instanceof Uint8Array ? fields.value : new Uint8Array(fields.value);
        results.push(
          processor({
            objectId: objectIdForError ?? "unknown",
            fields: { name, value }
          })
        );
      }
    }
    return results;
  } catch (error) {
    if (error instanceof import_errors.NetworkError || error instanceof import_errors.InvalidObjectError) {
      throw error;
    }
    throw new import_errors.NetworkError("Failed to process batched objects", error);
  }
};
/**
 * Generate a cache key for protocol public parameters based on encryption key ID and curve.
 *
 * @param encryptionKeyID - The encryption key ID
 * @param curve - The curve
 * @returns A unique cache key string
 * @private
 */
getCacheKey_fn = function(encryptionKeyID, curve) {
  return `${encryptionKeyID}-${curve}`;
};
getDWalletKind_fn = function(dWallet) {
  if (dWallet.is_imported_key_dwallet && dWallet.public_user_secret_key_share) {
    return "imported-key-shared";
  }
  if (dWallet.is_imported_key_dwallet) {
    return "imported-key";
  }
  if (dWallet.public_user_secret_key_share) {
    return "shared";
  }
  return "zero-trust";
};
pollUntilCondition_fn = async function(fetcher, condition, errorContext, options = {}) {
  await this.ensureInitialized();
  const {
    timeout = 3e4,
    interval = 1e3,
    maxInterval = 5e3,
    backoffMultiplier = 1.5,
    signal
  } = options;
  if (signal?.aborted) {
    throw new Error("Operation aborted");
  }
  const startTime = Date.now();
  let currentInterval = interval;
  let lastError;
  while (Date.now() - startTime < timeout) {
    if (signal?.aborted) {
      throw new Error("Operation aborted");
    }
    try {
      const obj = await fetcher();
      if (condition(obj)) {
        return obj;
      }
    } catch (error) {
      lastError = error;
    }
    const waitTime = currentInterval;
    await new Promise((resolve, reject) => {
      const timeoutId = setTimeout(resolve, waitTime);
      signal?.addEventListener("abort", () => {
        clearTimeout(timeoutId);
        reject(new Error("Operation aborted"));
      });
    });
    currentInterval = Math.min(currentInterval * backoffMultiplier, maxInterval);
  }
  const errorMessage = lastError ? `Timeout waiting for ${errorContext}. Last error: ${lastError.message}` : `Timeout waiting for ${errorContext}`;
  throw new Error(errorMessage);
};
pollUntilState_fn = async function(fetcher, state, errorContext, options = {}) {
  return __privateMethod(this, _IkaClient_instances, pollUntilCondition_fn).call(this, fetcher, (obj) => obj.state.$kind === state, errorContext, options);
};
//# sourceMappingURL=ika-client.js.map
