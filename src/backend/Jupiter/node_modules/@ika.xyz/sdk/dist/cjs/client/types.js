"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var types_exports = {};
__export(types_exports, {
  CoordinatorInnerDynamicField: () => CoordinatorInnerDynamicField,
  Curve: () => Curve,
  DWalletKind: () => DWalletKind,
  DynamicField: () => DynamicField,
  Hash: () => Hash,
  SignatureAlgorithm: () => SignatureAlgorithm,
  SystemInnerDynamicField: () => SystemInnerDynamicField
});
module.exports = __toCommonJS(types_exports);
var import_bcs = require("@mysten/sui/bcs");
var CoordinatorInnerModule = __toESM(require("../generated/ika_dwallet_2pc_mpc/coordinator_inner.js"));
var SystemInnerModule = __toESM(require("../generated/ika_system/system_inner.js"));
const DWalletKind = {
  ZeroTrust: "zero-trust",
  ImportedKey: "imported-key",
  ImportedKeyShared: "imported-key-shared",
  Shared: "shared"
};
const Hash = {
  /** KECCAK256 (SHA3) - Compatible with: ECDSASecp256k1 */
  KECCAK256: "KECCAK256",
  /** SHA256 - Compatible with: ECDSASecp256k1, Taproot, ECDSASecp256r1 */
  SHA256: "SHA256",
  /** Double SHA256: h(x) = sha256(sha256(x)) - Compatible with: ECDSASecp256k1, ECDSASecp256r1 */
  DoubleSHA256: "DoubleSHA256",
  /** SHA512 - Compatible with: EdDSA only */
  SHA512: "SHA512",
  /** Merlin (STROBE-based transcript construction) - Compatible with: SchnorrkelSubstrate only */
  Merlin: "Merlin"
};
const Curve = {
  /** secp256k1 - Used by: ECDSASecp256k1, Taproot */
  SECP256K1: "SECP256K1",
  /** Ristretto - Used by: SchnorrkelSubstrate */
  RISTRETTO: "RISTRETTO",
  /** Ed25519 - Used by: EdDSA */
  ED25519: "ED25519",
  /** secp256r1 (P-256) - Used by: ECDSASecp256r1 */
  SECP256R1: "SECP256R1"
};
const SignatureAlgorithm = {
  /** ECDSA with secp256k1 curve - Valid hashes: KECCAK256, SHA256, DoubleSHA256 */
  ECDSASecp256k1: "ECDSASecp256k1",
  /** Taproot (Bitcoin) - Valid hash: SHA256 only */
  Taproot: "Taproot",
  /** ECDSA with secp256r1 (P-256) curve - Valid hashes: SHA256, DoubleSHA256 */
  ECDSASecp256r1: "ECDSASecp256r1",
  /** EdDSA (Ed25519) - Valid hash: SHA512 only */
  EdDSA: "EdDSA",
  /** Schnorrkel/Ristretto (Substrate) - Valid hash: Merlin only */
  SchnorrkelSubstrate: "SchnorrkelSubstrate"
};
function DynamicField(...typeParameters) {
  return new import_bcs.BcsStruct({
    name: `dynamic_field::Field<u64, ${typeParameters[0].name}>`,
    fields: {
      id: import_bcs.bcs.Address,
      name: import_bcs.bcs.u64(),
      value: typeParameters[0]
    }
  });
}
const CoordinatorInnerDynamicField = DynamicField(
  CoordinatorInnerModule.DWalletCoordinatorInner
);
const SystemInnerDynamicField = DynamicField(SystemInnerModule.SystemInner);
//# sourceMappingURL=types.js.map
