{
  "version": 3,
  "sources": ["../../../../src/generated/ika_system/validator_set.ts"],
  "sourcesContent": ["/**************************************************************\n * THIS FILE IS GENERATED AND SHOULD NOT BE MANUALLY MODIFIED *\n **************************************************************/\nimport { MoveStruct, normalizeMoveArguments, type RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport { type Transaction } from '@mysten/sui/transactions';\nimport * as object_table from './deps/sui/object_table.js';\nimport * as bls_committee from './deps/ika_common/bls_committee.js';\nimport * as extended_field from './deps/ika_common/extended_field.js';\nimport * as vec_map from './deps/sui/vec_map.js';\nimport * as vec_set from './deps/sui/vec_set.js';\nimport * as bag from './deps/sui/bag.js';\nimport * as token_exchange_rate from './token_exchange_rate.js';\nconst $moduleName = '@local-pkg/system::validator_set';\nexport const ValidatorSet = new MoveStruct({ name: `${$moduleName}::ValidatorSet`, fields: {\n        /** Total amount of stake from all active validators at the beginning of the epoch. */\n        total_stake: bcs.u64(),\n        /** How many reward are slashed to punish a validator, in bps. */\n        reward_slashing_rate: bcs.u16(),\n        /** A table that contains all validators */\n        validators: object_table.ObjectTable,\n        /** The current list of active committee of validators. */\n        active_committee: bls_committee.BlsCommittee,\n        /**\n         * The next list of active committee of validators. It will become the\n         * active_committee at the end of the epoch.\n         */\n        next_epoch_active_committee: bcs.option(bls_committee.BlsCommittee),\n        /** The current list of previous committee of validators. */\n        previous_committee: bls_committee.BlsCommittee,\n        /**\n         * The next list of pending active set of validators to be\n         * next_epoch_active_committee. It will start from the last\n         * next_epoch_active_committee and will be process between middle of the epochs and\n         * will be finalize at the middle of the epoch.\n         */\n        pending_active_set: extended_field.ExtendedField,\n        /**\n         * A map storing the records of validator reporting each other. There is an entry\n         * in the map for each validator that has been reported at least once. The entry\n         * VecSet contains all the validators that reported them. If a validator has never\n         * been reported they don't have an entry in this map. This map persists across\n         * epoch: a peer continues being in a reported state until the reporter doesn't\n         * explicitly remove their report. Note that in case we want to support validator\n         * address change in future, the reports should be based on validator ids\n         */\n        validator_report_records: vec_map.VecMap(bcs.Address, vec_set.VecSet(bcs.Address)),\n        /** Any extra fields that's not defined statically. */\n        extra_fields: bag.Bag\n    } });\nexport const ValidatorEpochInfoEventV1 = new MoveStruct({ name: `${$moduleName}::ValidatorEpochInfoEventV1`, fields: {\n        epoch: bcs.u64(),\n        validator_id: bcs.Address,\n        stake: bcs.u64(),\n        commission_rate: bcs.u16(),\n        staking_rewards: bcs.u64(),\n        token_exchange_rate: token_exchange_rate.TokenExchangeRate,\n        tallying_rule_reporters: bcs.vector(bcs.Address),\n        tallying_rule_global_score: bcs.u64()\n    } });\nexport const ValidatorJoinEvent = new MoveStruct({ name: `${$moduleName}::ValidatorJoinEvent`, fields: {\n        epoch: bcs.u64(),\n        validator_id: bcs.Address\n    } });\nexport const ValidatorLeaveEvent = new MoveStruct({ name: `${$moduleName}::ValidatorLeaveEvent`, fields: {\n        withdrawing_epoch: bcs.u64(),\n        validator_id: bcs.Address,\n        is_voluntary: bcs.bool()\n    } });\nexport interface TotalStakeArguments {\n    self: RawTransactionArgument<string>;\n}\nexport interface TotalStakeOptions {\n    package?: string;\n    arguments: TotalStakeArguments | [\n        self: RawTransactionArgument<string>\n    ];\n}\nexport function totalStake(options: TotalStakeOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::validator_set::ValidatorSet`\n    ] satisfies string[];\n    const parameterNames = [\"self\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'validator_set',\n        function: 'total_stake',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface ValidatorTotalStakeAmountArguments {\n    self: RawTransactionArgument<string>;\n    validatorId: RawTransactionArgument<string>;\n}\nexport interface ValidatorTotalStakeAmountOptions {\n    package?: string;\n    arguments: ValidatorTotalStakeAmountArguments | [\n        self: RawTransactionArgument<string>,\n        validatorId: RawTransactionArgument<string>\n    ];\n}\nexport function validatorTotalStakeAmount(options: ValidatorTotalStakeAmountOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::validator_set::ValidatorSet`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::object::ID'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"validatorId\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'validator_set',\n        function: 'validator_total_stake_amount',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface GetValidatorArguments {\n    self: RawTransactionArgument<string>;\n    validatorId: RawTransactionArgument<string>;\n}\nexport interface GetValidatorOptions {\n    package?: string;\n    arguments: GetValidatorArguments | [\n        self: RawTransactionArgument<string>,\n        validatorId: RawTransactionArgument<string>\n    ];\n}\n/** Get reference to a validator by id. */\nexport function getValidator(options: GetValidatorOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::validator_set::ValidatorSet`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::object::ID'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"validatorId\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'validator_set',\n        function: 'get_validator',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface ActiveCommitteeArguments {\n    self: RawTransactionArgument<string>;\n}\nexport interface ActiveCommitteeOptions {\n    package?: string;\n    arguments: ActiveCommitteeArguments | [\n        self: RawTransactionArgument<string>\n    ];\n}\n/** Return the active validators in `self` */\nexport function activeCommittee(options: ActiveCommitteeOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::validator_set::ValidatorSet`\n    ] satisfies string[];\n    const parameterNames = [\"self\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'validator_set',\n        function: 'active_committee',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface NextEpochActiveCommitteeArguments {\n    self: RawTransactionArgument<string>;\n}\nexport interface NextEpochActiveCommitteeOptions {\n    package?: string;\n    arguments: NextEpochActiveCommitteeArguments | [\n        self: RawTransactionArgument<string>\n    ];\n}\n/** Return the next epoch active committee in `self` */\nexport function nextEpochActiveCommittee(options: NextEpochActiveCommitteeOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::validator_set::ValidatorSet`\n    ] satisfies string[];\n    const parameterNames = [\"self\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'validator_set',\n        function: 'next_epoch_active_committee',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface PendingActiveSetArguments {\n    self: RawTransactionArgument<string>;\n}\nexport interface PendingActiveSetOptions {\n    package?: string;\n    arguments: PendingActiveSetArguments | [\n        self: RawTransactionArgument<string>\n    ];\n}\n/** Return the pending active set in `self` */\nexport function pendingActiveSet(options: PendingActiveSetOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::validator_set::ValidatorSet`\n    ] satisfies string[];\n    const parameterNames = [\"self\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'validator_set',\n        function: 'pending_active_set',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface IsValidatorCandidateArguments {\n    self: RawTransactionArgument<string>;\n    validatorId: RawTransactionArgument<string>;\n}\nexport interface IsValidatorCandidateOptions {\n    package?: string;\n    arguments: IsValidatorCandidateArguments | [\n        self: RawTransactionArgument<string>,\n        validatorId: RawTransactionArgument<string>\n    ];\n}\n/** Returns true if the `validator_id` is a validator candidate. */\nexport function isValidatorCandidate(options: IsValidatorCandidateOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::validator_set::ValidatorSet`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::object::ID'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"validatorId\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'validator_set',\n        function: 'is_validator_candidate',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}\nexport interface IsInactiveValidatorArguments {\n    self: RawTransactionArgument<string>;\n    validatorId: RawTransactionArgument<string>;\n}\nexport interface IsInactiveValidatorOptions {\n    package?: string;\n    arguments: IsInactiveValidatorArguments | [\n        self: RawTransactionArgument<string>,\n        validatorId: RawTransactionArgument<string>\n    ];\n}\n/**\n * Returns true if the validator identified by `validator_id` is of an inactive\n * validator.\n */\nexport function isInactiveValidator(options: IsInactiveValidatorOptions) {\n    const packageAddress = options.package ?? '@local-pkg/system';\n    const argumentsTypes = [\n        `${packageAddress}::validator_set::ValidatorSet`,\n        '0x0000000000000000000000000000000000000000000000000000000000000002::object::ID'\n    ] satisfies string[];\n    const parameterNames = [\"self\", \"validatorId\"];\n    return (tx: Transaction) => tx.moveCall({\n        package: packageAddress,\n        module: 'validator_set',\n        function: 'is_inactive_validator',\n        arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n    });\n}"],
  "mappings": "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",
  "names": []
}
