"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var system_exports = {};
__export(system_exports, {
  activeCommittee: () => activeCommittee,
  addUpgradeCapByCap: () => addUpgradeCapByCap,
  advanceEpoch: () => advanceEpoch,
  authorizeUpgrade: () => authorizeUpgrade,
  calculateRewards: () => calculateRewards,
  canWithdrawStakedIkaEarly: () => canWithdrawStakedIkaEarly,
  collectCommission: () => collectCommission,
  commitUpgrade: () => commitUpgrade,
  createSystemCurrentStatusInfo: () => createSystemCurrentStatusInfo,
  finalizeUpgrade: () => finalizeUpgrade,
  initiateAdvanceEpoch: () => initiateAdvanceEpoch,
  initiateMidEpochReconfiguration: () => initiateMidEpochReconfiguration,
  nextEpochActiveCommittee: () => nextEpochActiveCommittee,
  processCheckpointMessageByCap: () => processCheckpointMessageByCap,
  processCheckpointMessageByQuorum: () => processCheckpointMessageByQuorum,
  reportValidator: () => reportValidator,
  requestAddStake: () => requestAddStake,
  requestAddValidator: () => requestAddValidator,
  requestAddValidatorCandidate: () => requestAddValidatorCandidate,
  requestRemoveValidator: () => requestRemoveValidator,
  requestRemoveValidatorCandidate: () => requestRemoveValidatorCandidate,
  requestWithdrawStake: () => requestWithdrawStake,
  rotateCommissionCap: () => rotateCommissionCap,
  rotateOperationCap: () => rotateOperationCap,
  setApprovedUpgradeByCap: () => setApprovedUpgradeByCap,
  setNextCommission: () => setNextCommission,
  setNextEpochConsensusAddress: () => setNextEpochConsensusAddress,
  setNextEpochConsensusPubkeyBytes: () => setNextEpochConsensusPubkeyBytes,
  setNextEpochMpcDataBytes: () => setNextEpochMpcDataBytes,
  setNextEpochNetworkAddress: () => setNextEpochNetworkAddress,
  setNextEpochNetworkPubkeyBytes: () => setNextEpochNetworkPubkeyBytes,
  setNextEpochP2pAddress: () => setNextEpochP2pAddress,
  setNextEpochProtocolPubkeyBytes: () => setNextEpochProtocolPubkeyBytes,
  setOrRemoveWitnessApprovingAdvanceEpochByCap: () => setOrRemoveWitnessApprovingAdvanceEpochByCap,
  setValidatorMetadata: () => setValidatorMetadata,
  setValidatorName: () => setValidatorName,
  tryMigrate: () => tryMigrate,
  tryMigrateByCap: () => tryMigrateByCap,
  undoReportValidator: () => undoReportValidator,
  validatorMetadata: () => validatorMetadata,
  verifyCommissionCap: () => verifyCommissionCap,
  verifyOperationCap: () => verifyOperationCap,
  verifyProtocolCap: () => verifyProtocolCap,
  verifyValidatorCap: () => verifyValidatorCap,
  version: () => version,
  withdrawStake: () => withdrawStake
});
module.exports = __toCommonJS(system_exports);
var import_bcs = require("@mysten/sui/bcs");
function requestAddValidatorCandidate(ikaConfig, systemObjectRef, name, protocolPubkeyBytes, networkPubkeyBytes, consensusPubkeyBytes, mpcDataBytes, proofOfPossessionBytes, networkAddress, p2pAddress, consensusAddress, commissionRate, metadata, tx) {
  const [validatorCap, validatorOperationCap, validatorCommissionCap] = tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::request_add_validator_candidate`,
    arguments: [
      systemObjectRef,
      tx.pure.string(name),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(protocolPubkeyBytes)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(networkPubkeyBytes)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(consensusPubkeyBytes)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.vector(import_bcs.bcs.u8())).serialize(mpcDataBytes)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(proofOfPossessionBytes)),
      tx.pure.string(networkAddress),
      tx.pure.string(p2pAddress),
      tx.pure.string(consensusAddress),
      tx.pure.u16(commissionRate),
      tx.moveCall({
        target: `${ikaConfig.packages.ikaSystemPackage}::validator_metadata::new`,
        arguments: [
          tx.pure.string(metadata.imageUrl),
          tx.pure.string(metadata.projectUrl),
          tx.pure.string(metadata.description)
        ]
      })
    ]
  });
  return {
    validatorCap,
    validatorOperationCap,
    validatorCommissionCap
  };
}
function requestRemoveValidatorCandidate(ikaConfig, systemObjectRef, validatorCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::request_remove_validator_candidate`,
    arguments: [systemObjectRef, tx.object(validatorCap)]
  });
}
function requestAddValidator(ikaConfig, systemObjectRef, validatorCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::request_add_validator`,
    arguments: [systemObjectRef, tx.object(validatorCap)]
  });
}
function requestRemoveValidator(ikaConfig, systemObjectRef, validatorCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::request_remove_validator`,
    arguments: [systemObjectRef, tx.object(validatorCap)]
  });
}
function setNextCommission(ikaConfig, systemObjectRef, newCommissionRate, validatorOperationCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::set_next_commission`,
    arguments: [systemObjectRef, tx.pure.u16(newCommissionRate), tx.object(validatorOperationCap)]
  });
}
function requestAddStake(ikaConfig, systemObjectRef, stakeCoin, validatorId, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::request_add_stake`,
    arguments: [systemObjectRef, stakeCoin, tx.pure.id(validatorId)]
  });
}
function requestWithdrawStake(ikaConfig, systemObjectRef, stakedIka, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::request_withdraw_stake`,
    arguments: [systemObjectRef, tx.object(stakedIka)]
  });
}
function withdrawStake(ikaConfig, systemObjectRef, stakedIka, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::withdraw_stake`,
    arguments: [systemObjectRef, tx.object(stakedIka)]
  });
}
function reportValidator(ikaConfig, systemObjectRef, validatorOperationCap, reporteeId, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::report_validator`,
    arguments: [systemObjectRef, tx.object(validatorOperationCap), tx.pure.id(reporteeId)]
  });
}
function undoReportValidator(ikaConfig, systemObjectRef, validatorOperationCap, reporteeId, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::undo_report_validator`,
    arguments: [systemObjectRef, tx.object(validatorOperationCap), tx.pure.id(reporteeId)]
  });
}
function rotateOperationCap(ikaConfig, systemObjectRef, validatorCap, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::rotate_operation_cap`,
    arguments: [systemObjectRef, tx.object(validatorCap)]
  });
}
function rotateCommissionCap(ikaConfig, systemObjectRef, validatorCap, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::rotate_commission_cap`,
    arguments: [systemObjectRef, tx.object(validatorCap)]
  });
}
function collectCommission(ikaConfig, systemObjectRef, validatorCommissionCap, amount, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::collect_commission`,
    arguments: [
      systemObjectRef,
      tx.object(validatorCommissionCap),
      amount !== null ? tx.pure(import_bcs.bcs.option(import_bcs.bcs.u64()).serialize(amount)) : tx.pure(import_bcs.bcs.option(import_bcs.bcs.u64()).serialize(null))
    ]
  });
}
function setValidatorName(ikaConfig, systemObjectRef, name, validatorOperationCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::set_validator_name`,
    arguments: [systemObjectRef, tx.pure.string(name), tx.object(validatorOperationCap)]
  });
}
function validatorMetadata(ikaConfig, systemObjectRef, validatorId, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::validator_metadata`,
    arguments: [systemObjectRef, tx.pure.id(validatorId)]
  });
}
function setValidatorMetadata(ikaConfig, systemObjectRef, metadata, validatorOperationCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::set_validator_metadata`,
    arguments: [
      systemObjectRef,
      tx.moveCall({
        target: `${ikaConfig.packages.ikaSystemPackage}::validator_metadata::new`,
        arguments: [
          tx.pure.string(metadata.imageUrl),
          tx.pure.string(metadata.projectUrl),
          tx.pure.string(metadata.description)
        ]
      }),
      tx.object(validatorOperationCap)
    ]
  });
}
function setNextEpochNetworkAddress(ikaConfig, systemObjectRef, networkAddress, validatorOperationCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::set_next_epoch_network_address`,
    arguments: [systemObjectRef, tx.pure.string(networkAddress), tx.object(validatorOperationCap)]
  });
}
function setNextEpochP2pAddress(ikaConfig, systemObjectRef, p2pAddress, validatorOperationCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::set_next_epoch_p2p_address`,
    arguments: [systemObjectRef, tx.pure.string(p2pAddress), tx.object(validatorOperationCap)]
  });
}
function setNextEpochConsensusAddress(ikaConfig, systemObjectRef, consensusAddress, validatorOperationCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::set_next_epoch_consensus_address`,
    arguments: [
      systemObjectRef,
      tx.pure.string(consensusAddress),
      tx.object(validatorOperationCap)
    ]
  });
}
function setNextEpochProtocolPubkeyBytes(ikaConfig, systemObjectRef, protocolPubkey, proofOfPossessionBytes, validatorOperationCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::set_next_epoch_protocol_pubkey_bytes`,
    arguments: [
      systemObjectRef,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(protocolPubkey)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(proofOfPossessionBytes)),
      tx.object(validatorOperationCap)
    ]
  });
}
function setNextEpochNetworkPubkeyBytes(ikaConfig, systemObjectRef, networkPubkey, validatorOperationCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::set_next_epoch_network_pubkey_bytes`,
    arguments: [
      systemObjectRef,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(networkPubkey)),
      tx.object(validatorOperationCap)
    ]
  });
}
function setNextEpochConsensusPubkeyBytes(ikaConfig, systemObjectRef, consensusPubkeyBytes, validatorOperationCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::set_next_epoch_consensus_pubkey_bytes`,
    arguments: [
      systemObjectRef,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(consensusPubkeyBytes)),
      tx.object(validatorOperationCap)
    ]
  });
}
function setNextEpochMpcDataBytes(ikaConfig, systemObjectRef, mpcData, validatorOperationCap, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::set_next_epoch_mpc_data_bytes`,
    arguments: [
      systemObjectRef,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.vector(import_bcs.bcs.u8())).serialize(mpcData)),
      tx.object(validatorOperationCap)
    ]
  });
}
function activeCommittee(ikaConfig, systemObjectRef, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::active_committee`,
    arguments: [systemObjectRef]
  });
}
function nextEpochActiveCommittee(ikaConfig, systemObjectRef, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::next_epoch_active_committee`,
    arguments: [systemObjectRef]
  });
}
function initiateMidEpochReconfiguration(ikaConfig, systemObjectRef, clock, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::initiate_mid_epoch_reconfiguration`,
    arguments: [systemObjectRef, tx.object(clock)]
  });
}
function createSystemCurrentStatusInfo(ikaConfig, systemObjectRef, clock, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::create_system_current_status_info`,
    arguments: [systemObjectRef, tx.object(clock)]
  });
}
function initiateAdvanceEpoch(ikaConfig, systemObjectRef, clock, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::initiate_advance_epoch`,
    arguments: [systemObjectRef, tx.object(clock)]
  });
}
function advanceEpoch(ikaConfig, systemObjectRef, advanceEpochApprover, clock, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::advance_epoch`,
    arguments: [systemObjectRef, tx.object(advanceEpochApprover), tx.object(clock)]
  });
}
function verifyValidatorCap(ikaConfig, systemObjectRef, validatorCap, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::verify_validator_cap`,
    arguments: [systemObjectRef, tx.object(validatorCap)]
  });
}
function verifyOperationCap(ikaConfig, systemObjectRef, validatorOperationCap, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::verify_operation_cap`,
    arguments: [systemObjectRef, tx.object(validatorOperationCap)]
  });
}
function verifyCommissionCap(ikaConfig, systemObjectRef, validatorCommissionCap, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::verify_commission_cap`,
    arguments: [systemObjectRef, tx.object(validatorCommissionCap)]
  });
}
function authorizeUpgrade(ikaConfig, systemObjectRef, packageId, tx) {
  const [upgradeTicket, upgradePackageApprover] = tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::authorize_upgrade`,
    arguments: [systemObjectRef, tx.pure.id(packageId)]
  });
  return {
    upgradeTicket,
    upgradePackageApprover
  };
}
function commitUpgrade(ikaConfig, systemObjectRef, upgradeReceipt, upgradePackageApprover, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::commit_upgrade`,
    arguments: [systemObjectRef, tx.object(upgradeReceipt), tx.object(upgradePackageApprover)]
  });
}
function finalizeUpgrade(ikaConfig, systemObjectRef, upgradePackageApprover, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::finalize_upgrade`,
    arguments: [systemObjectRef, tx.object(upgradePackageApprover)]
  });
}
function processCheckpointMessageByQuorum(ikaConfig, systemObjectRef, signature, signersBitmap, message, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::process_checkpoint_message_by_quorum`,
    arguments: [
      systemObjectRef,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(signature)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(signersBitmap)),
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(message))
    ]
  });
}
function addUpgradeCapByCap(ikaConfig, systemObjectRef, upgradeCap, protocolCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::add_upgrade_cap_by_cap`,
    arguments: [systemObjectRef, tx.object(upgradeCap), tx.object(protocolCap)]
  });
}
function verifyProtocolCap(ikaConfig, systemObjectRef, protocolCap, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::verify_protocol_cap`,
    arguments: [systemObjectRef, tx.object(protocolCap)]
  });
}
function processCheckpointMessageByCap(ikaConfig, systemObjectRef, message, protocolCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::process_checkpoint_message_by_cap`,
    arguments: [
      systemObjectRef,
      tx.pure(import_bcs.bcs.vector(import_bcs.bcs.u8()).serialize(message)),
      tx.object(protocolCap)
    ]
  });
}
function setApprovedUpgradeByCap(ikaConfig, systemObjectRef, packageId, digest, protocolCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::set_approved_upgrade_by_cap`,
    arguments: [
      systemObjectRef,
      tx.pure.id(packageId),
      digest !== null ? tx.pure(import_bcs.bcs.option(import_bcs.bcs.vector(import_bcs.bcs.u8())).serialize(digest)) : tx.pure(import_bcs.bcs.option(import_bcs.bcs.vector(import_bcs.bcs.u8())).serialize(null)),
      tx.object(protocolCap)
    ]
  });
}
function setOrRemoveWitnessApprovingAdvanceEpochByCap(ikaConfig, systemObjectRef, witnessType, remove, protocolCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::set_or_remove_witness_approving_advance_epoch_by_cap`,
    arguments: [
      systemObjectRef,
      tx.pure.string(witnessType),
      tx.pure.bool(remove),
      tx.object(protocolCap)
    ]
  });
}
function tryMigrateByCap(ikaConfig, systemObjectRef, protocolCap, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::try_migrate_by_cap`,
    arguments: [systemObjectRef, tx.object(protocolCap)]
  });
}
function tryMigrate(ikaConfig, systemObjectRef, tx) {
  tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::try_migrate`,
    arguments: [systemObjectRef]
  });
}
function calculateRewards(ikaConfig, systemObjectRef, validatorId, stakedPrincipal, activationEpoch, withdrawEpoch, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::calculate_rewards`,
    arguments: [
      systemObjectRef,
      tx.pure.id(validatorId),
      tx.pure.u64(stakedPrincipal),
      tx.pure.u64(activationEpoch),
      tx.pure.u64(withdrawEpoch)
    ]
  });
}
function canWithdrawStakedIkaEarly(ikaConfig, systemObjectRef, stakedIka, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::can_withdraw_staked_ika_early`,
    arguments: [systemObjectRef, tx.object(stakedIka)]
  });
}
function version(ikaConfig, systemObjectRef, tx) {
  return tx.moveCall({
    target: `${ikaConfig.packages.ikaSystemPackage}::system::version`,
    arguments: [systemObjectRef]
  });
}
//# sourceMappingURL=system.js.map
