"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var hash_signature_validation_exports = {};
__export(hash_signature_validation_exports, {
  createValidatedSigningParams: () => createValidatedSigningParams,
  fromAbsoluteNumberToHash: () => fromAbsoluteNumberToHash,
  fromAbsoluteNumberToSignatureAlgorithm: () => fromAbsoluteNumberToSignatureAlgorithm,
  fromCurveAndSignatureAlgorithmAndHashToNumbers: () => fromCurveAndSignatureAlgorithmAndHashToNumbers,
  fromCurveAndSignatureAlgorithmToNumbers: () => fromCurveAndSignatureAlgorithmToNumbers,
  fromCurveToNumber: () => fromCurveToNumber,
  fromHashToAbsoluteNumber: () => fromHashToAbsoluteNumber,
  fromHashToNumber: () => fromHashToNumber,
  fromNumberToCurve: () => fromNumberToCurve,
  fromNumberToHash: () => fromNumberToHash,
  fromNumberToSignatureAlgorithm: () => fromNumberToSignatureAlgorithm,
  fromNumbersToCurveAndSignatureAlgorithm: () => fromNumbersToCurveAndSignatureAlgorithm,
  fromNumbersToCurveAndSignatureAlgorithmAndHash: () => fromNumbersToCurveAndSignatureAlgorithmAndHash,
  fromSignatureAlgorithmToAbsoluteNumber: () => fromSignatureAlgorithmToAbsoluteNumber,
  fromSignatureAlgorithmToNumber: () => fromSignatureAlgorithmToNumber,
  getCurveName: () => getCurveName,
  getHashName: () => getHashName,
  getSignatureAlgorithmName: () => getSignatureAlgorithmName,
  getValidHashesForCurveAndSignature: () => getValidHashesForCurveAndSignature,
  getValidHashesForSignatureAlgorithm: () => getValidHashesForSignatureAlgorithm,
  getValidSignatureAlgorithmsForCurve: () => getValidSignatureAlgorithmsForCurve,
  isValidHashForCurveAndSignature: () => isValidHashForCurveAndSignature,
  isValidHashForSignature: () => isValidHashForSignature,
  isValidSignatureAlgorithmForCurve: () => isValidSignatureAlgorithmForCurve,
  validateCurveSignatureAlgorithm: () => validateCurveSignatureAlgorithm,
  validateHashSignatureCombination: () => validateHashSignatureCombination
});
module.exports = __toCommonJS(hash_signature_validation_exports);
var import_types = require("./types.js");
const VALID_HASH_SIGNATURE_COMBINATIONS = {
  [import_types.SignatureAlgorithm.ECDSASecp256k1]: [import_types.Hash.KECCAK256, import_types.Hash.SHA256, import_types.Hash.DoubleSHA256],
  [import_types.SignatureAlgorithm.Taproot]: [import_types.Hash.SHA256],
  [import_types.SignatureAlgorithm.ECDSASecp256r1]: [import_types.Hash.SHA256],
  [import_types.SignatureAlgorithm.EdDSA]: [import_types.Hash.SHA512],
  [import_types.SignatureAlgorithm.SchnorrkelSubstrate]: [import_types.Hash.Merlin]
};
const SIGNATURE_ALGORITHM_TO_CURVE = {
  [import_types.SignatureAlgorithm.ECDSASecp256k1]: import_types.Curve.SECP256K1,
  [import_types.SignatureAlgorithm.Taproot]: import_types.Curve.SECP256K1,
  [import_types.SignatureAlgorithm.ECDSASecp256r1]: import_types.Curve.SECP256R1,
  [import_types.SignatureAlgorithm.EdDSA]: import_types.Curve.ED25519,
  [import_types.SignatureAlgorithm.SchnorrkelSubstrate]: import_types.Curve.RISTRETTO
};
const SIGNATURE_ALGORITHM_ABSOLUTE_NUMBERS = {
  [import_types.SignatureAlgorithm.ECDSASecp256k1]: 0,
  [import_types.SignatureAlgorithm.Taproot]: 1,
  [import_types.SignatureAlgorithm.ECDSASecp256r1]: 2,
  [import_types.SignatureAlgorithm.EdDSA]: 3,
  [import_types.SignatureAlgorithm.SchnorrkelSubstrate]: 4
};
const HASH_ABSOLUTE_NUMBERS = {
  [import_types.Hash.KECCAK256]: 0,
  [import_types.Hash.SHA256]: 1,
  [import_types.Hash.DoubleSHA256]: 2,
  [import_types.Hash.SHA512]: 3,
  [import_types.Hash.Merlin]: 4
};
const CURVE_SIGNATURE_HASH_CONFIG = {
  [import_types.Curve.SECP256K1]: {
    curveNumber: 0,
    signatureAlgorithms: {
      [import_types.SignatureAlgorithm.ECDSASecp256k1]: {
        signatureAlgorithmNumber: 0,
        hashes: {
          [import_types.Hash.KECCAK256]: 0,
          [import_types.Hash.SHA256]: 1,
          [import_types.Hash.DoubleSHA256]: 2
        }
      },
      [import_types.SignatureAlgorithm.Taproot]: {
        signatureAlgorithmNumber: 1,
        hashes: {
          [import_types.Hash.SHA256]: 0
        }
      }
    }
  },
  [import_types.Curve.SECP256R1]: {
    curveNumber: 1,
    signatureAlgorithms: {
      [import_types.SignatureAlgorithm.ECDSASecp256r1]: {
        signatureAlgorithmNumber: 0,
        hashes: {
          [import_types.Hash.SHA256]: 0
        }
      }
    }
  },
  [import_types.Curve.ED25519]: {
    curveNumber: 2,
    signatureAlgorithms: {
      [import_types.SignatureAlgorithm.EdDSA]: {
        signatureAlgorithmNumber: 0,
        hashes: {
          [import_types.Hash.SHA512]: 0
        }
      }
    }
  },
  [import_types.Curve.RISTRETTO]: {
    curveNumber: 3,
    signatureAlgorithms: {
      [import_types.SignatureAlgorithm.SchnorrkelSubstrate]: {
        signatureAlgorithmNumber: 0,
        hashes: {
          [import_types.Hash.Merlin]: 0
        }
      }
    }
  }
};
function getHashName(hash) {
  switch (hash) {
    case import_types.Hash.KECCAK256:
      return "KECCAK256 (SHA3)";
    case import_types.Hash.SHA256:
      return "SHA256";
    case import_types.Hash.DoubleSHA256:
      return "DoubleSHA256";
    case import_types.Hash.SHA512:
      return "SHA512";
    case import_types.Hash.Merlin:
      return "Merlin";
    default:
      return `Unknown Hash (${hash})`;
  }
}
function getSignatureAlgorithmName(signatureAlgorithm) {
  switch (signatureAlgorithm) {
    case import_types.SignatureAlgorithm.ECDSASecp256k1:
      return "ECDSASecp256k1";
    case import_types.SignatureAlgorithm.Taproot:
      return "Taproot";
    case import_types.SignatureAlgorithm.ECDSASecp256r1:
      return "ECDSASecp256r1";
    case import_types.SignatureAlgorithm.EdDSA:
      return "EdDSA";
    case import_types.SignatureAlgorithm.SchnorrkelSubstrate:
      return "SchnorrkelSubstrate (Ristretto)";
    default:
      return `Unknown SignatureAlgorithm (${signatureAlgorithm})`;
  }
}
function getCurveName(curve) {
  switch (curve) {
    case import_types.Curve.SECP256K1:
      return "secp256k1";
    case import_types.Curve.SECP256R1:
      return "secp256r1";
    case import_types.Curve.ED25519:
      return "Ed25519";
    case import_types.Curve.RISTRETTO:
      return "Ristretto";
    default:
      return `Unknown Curve (${curve})`;
  }
}
function validateHashSignatureCombination(hash, signatureAlgorithm) {
  const validHashes = VALID_HASH_SIGNATURE_COMBINATIONS[signatureAlgorithm];
  if (!validHashes.includes(hash)) {
    const supportedHashNames = validHashes.map(getHashName).join(", ");
    throw new Error(
      `Invalid hash and signature algorithm combination: ${getSignatureAlgorithmName(signatureAlgorithm)} does not support ${getHashName(hash)}. Supported hash algorithms for ${getSignatureAlgorithmName(signatureAlgorithm)}: ${supportedHashNames}`
    );
  }
}
function validateCurveSignatureAlgorithm(curve, signatureAlgorithm) {
  const expectedCurve = SIGNATURE_ALGORITHM_TO_CURVE[signatureAlgorithm];
  if (curve !== expectedCurve) {
    throw new Error(
      `Invalid curve and signature algorithm combination: ${getSignatureAlgorithmName(signatureAlgorithm)} requires ${getCurveName(expectedCurve)}, but ${getCurveName(curve)} was provided.`
    );
  }
}
function isValidHashForSignature(hash, signatureAlgorithm) {
  const validHashes = VALID_HASH_SIGNATURE_COMBINATIONS[signatureAlgorithm];
  return validHashes.includes(hash);
}
function createValidatedSigningParams(hashScheme, signatureAlgorithm) {
  validateHashSignatureCombination(hashScheme, signatureAlgorithm);
  return { hashScheme, signatureAlgorithm };
}
function getValidHashesForSignatureAlgorithm(signatureAlgorithm) {
  const validHashes = VALID_HASH_SIGNATURE_COMBINATIONS[signatureAlgorithm];
  return validHashes.map(getHashName);
}
function fromCurveToNumber(curve) {
  const config = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!config) {
    throw new Error(`Unknown curve: ${curve}`);
  }
  return config.curveNumber;
}
function fromSignatureAlgorithmToNumber(curve, signatureAlgorithm) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) {
    throw new Error(`Unknown curve: ${curve}`);
  }
  const signatureAlgorithms = curveConfig.signatureAlgorithms;
  const signatureConfig = signatureAlgorithms[signatureAlgorithm];
  if (!signatureConfig) {
    throw new Error(
      `Invalid signature algorithm ${signatureAlgorithm} for curve ${curve}. Valid algorithms: ${Object.keys(curveConfig.signatureAlgorithms).join(", ")}`
    );
  }
  return signatureConfig.signatureAlgorithmNumber;
}
function fromHashToNumber(curve, signatureAlgorithm, hash) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) {
    throw new Error(`Unknown curve: ${curve}`);
  }
  const signatureAlgorithms = curveConfig.signatureAlgorithms;
  const signatureConfig = signatureAlgorithms[signatureAlgorithm];
  if (!signatureConfig) {
    throw new Error(
      `Invalid signature algorithm ${signatureAlgorithm} for curve ${curve}. Valid algorithms: ${Object.keys(curveConfig.signatureAlgorithms).join(", ")}`
    );
  }
  const hashes = signatureConfig.hashes;
  const hashNumber = hashes[hash];
  if (hashNumber === void 0) {
    throw new Error(
      `Invalid hash ${hash} for ${signatureAlgorithm} on ${curve}. Valid hashes: ${Object.keys(signatureConfig.hashes).join(", ")}`
    );
  }
  return hashNumber;
}
function fromCurveAndSignatureAlgorithmToNumbers(curve, signatureAlgorithm) {
  const curveNumber = fromCurveToNumber(curve);
  const signatureAlgorithmNumber = fromSignatureAlgorithmToNumber(curve, signatureAlgorithm);
  return {
    curveNumber,
    signatureAlgorithmNumber
  };
}
function fromCurveAndSignatureAlgorithmAndHashToNumbers(curve, signatureAlgorithm, hash) {
  const curveNumber = fromCurveToNumber(curve);
  const signatureAlgorithmNumber = fromSignatureAlgorithmToNumber(curve, signatureAlgorithm);
  const hashNumber = fromHashToNumber(curve, signatureAlgorithm, hash);
  return {
    curveNumber,
    signatureAlgorithmNumber,
    hashNumber
  };
}
function isValidSignatureAlgorithmForCurve(curve, signatureAlgorithm) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) return false;
  return signatureAlgorithm in curveConfig.signatureAlgorithms;
}
function isValidHashForCurveAndSignature(curve, signatureAlgorithm, hash) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) return false;
  const signatureAlgorithms = curveConfig.signatureAlgorithms;
  const signatureConfig = signatureAlgorithms[signatureAlgorithm];
  if (!signatureConfig) return false;
  const hashes = signatureConfig.hashes;
  return hash in hashes;
}
function getValidSignatureAlgorithmsForCurve(curve) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) return [];
  return Object.keys(curveConfig.signatureAlgorithms);
}
function getValidHashesForCurveAndSignature(curve, signatureAlgorithm) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) return [];
  const signatureAlgorithms = curveConfig.signatureAlgorithms;
  const signatureConfig = signatureAlgorithms[signatureAlgorithm];
  if (!signatureConfig) return [];
  return Object.keys(signatureConfig.hashes);
}
function fromNumberToCurve(curveNumber) {
  for (const [curve, config] of Object.entries(CURVE_SIGNATURE_HASH_CONFIG)) {
    if (config.curveNumber === curveNumber) {
      return curve;
    }
  }
  throw new Error(`Unknown curve number: ${curveNumber}`);
}
function fromAbsoluteNumberToSignatureAlgorithm(absoluteNumber) {
  for (const [signatureAlgorithm, number] of Object.entries(SIGNATURE_ALGORITHM_ABSOLUTE_NUMBERS)) {
    if (number === absoluteNumber) {
      return signatureAlgorithm;
    }
  }
  throw new Error(`Unknown absolute signature algorithm number: ${absoluteNumber}`);
}
function fromSignatureAlgorithmToAbsoluteNumber(signatureAlgorithm) {
  const absoluteNumber = SIGNATURE_ALGORITHM_ABSOLUTE_NUMBERS[signatureAlgorithm];
  if (absoluteNumber === void 0) {
    throw new Error(`Unknown signature algorithm: ${signatureAlgorithm}`);
  }
  return absoluteNumber;
}
function fromAbsoluteNumberToHash(absoluteNumber) {
  for (const [hash, number] of Object.entries(HASH_ABSOLUTE_NUMBERS)) {
    if (number === absoluteNumber) {
      return hash;
    }
  }
  throw new Error(`Unknown absolute hash number: ${absoluteNumber}`);
}
function fromHashToAbsoluteNumber(hash) {
  const absoluteNumber = HASH_ABSOLUTE_NUMBERS[hash];
  if (absoluteNumber === void 0) {
    throw new Error(`Unknown hash: ${hash}`);
  }
  return absoluteNumber;
}
function fromNumberToSignatureAlgorithm(curve, signatureAlgorithmNumber) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) {
    throw new Error(`Unknown curve: ${curve}`);
  }
  const signatureAlgorithms = curveConfig.signatureAlgorithms;
  for (const [signatureAlgorithm, config] of Object.entries(signatureAlgorithms)) {
    if (config.signatureAlgorithmNumber === signatureAlgorithmNumber) {
      return signatureAlgorithm;
    }
  }
  throw new Error(
    `Unknown signature algorithm number ${signatureAlgorithmNumber} for curve ${curve}`
  );
}
function fromNumberToHash(curve, signatureAlgorithm, hashNumber) {
  const curveConfig = CURVE_SIGNATURE_HASH_CONFIG[curve];
  if (!curveConfig) {
    throw new Error(`Unknown curve: ${curve}`);
  }
  const signatureAlgorithms = curveConfig.signatureAlgorithms;
  const signatureConfig = signatureAlgorithms[signatureAlgorithm];
  if (!signatureConfig) {
    throw new Error(`Invalid signature algorithm ${signatureAlgorithm} for curve ${curve}`);
  }
  const hashes = signatureConfig.hashes;
  for (const [hash, number] of Object.entries(hashes)) {
    if (number === hashNumber) {
      return hash;
    }
  }
  throw new Error(`Unknown hash number ${hashNumber} for ${signatureAlgorithm} on ${curve}`);
}
function fromNumbersToCurveAndSignatureAlgorithm(curveNumber, signatureAlgorithmNumber) {
  const curve = fromNumberToCurve(curveNumber);
  const signatureAlgorithm = fromNumberToSignatureAlgorithm(curve, signatureAlgorithmNumber);
  return {
    curve,
    signatureAlgorithm
  };
}
function fromNumbersToCurveAndSignatureAlgorithmAndHash(curveNumber, signatureAlgorithmNumber, hashNumber) {
  const curve = fromNumberToCurve(curveNumber);
  const signatureAlgorithm = fromNumberToSignatureAlgorithm(curve, signatureAlgorithmNumber);
  const hash = fromNumberToHash(curve, signatureAlgorithm, hashNumber);
  return {
    curve,
    signatureAlgorithm,
    hash
  };
}
//# sourceMappingURL=hash-signature-validation.js.map
